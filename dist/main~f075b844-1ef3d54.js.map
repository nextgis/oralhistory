{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/icons/src/index.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/utility.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/QmsKit.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/image_icons.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/geom_type.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/VectorAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/MvtAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/TileAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/ZoomControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/CompassControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/AttributionControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/MapboxglMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createButtonControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/decorators.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/NgwMap.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/CancelablePromise.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/NgwConnector.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createGeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createRasterAdapter.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeUtil.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeHelper.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/BaseProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/Item.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/CheckProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/ItemProperties.ts","webpack:///./nextgisweb_frontend/packages/item/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerItem.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwResource.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createAsyncAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createWebMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/identifyUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwKit.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/utils/src/dom.ts","webpack:///./nextgisweb_frontend/packages/utils/src/clipboard.ts","webpack:///./nextgisweb_frontend/packages/utils/src/events.ts","webpack:///./nextgisweb_frontend/packages/utils/src/index.ts"],"names":["svgPath","brill","circle","rect","marker","cross","star","triangle","plus","minus","asterisk","STROKE","getIcon","opt","shape","color","strokeColor","size","anchor","stroke","scale","pathAlias","svg","width","height","content","s","DOMParser","parseFromString","documentElement","insertSvg","fistChild","firstChild","transform","setAttribute","String","type","iconSize","iconAnchor","html","XMLSerializer","serializeToString","alias","tms","loadJSON","url","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","JSON","parse","er","open","send","createQmsAdapter","webMap","map","options","this","baseLayer","addLayer","qms","qmsId","webMapAdapter","mapAdapter","layerAdapters","maxZoom","minZoom","protocol","location","replace","name","attribution","copyright_text","z_max","z_min","updateQmsOptions","getLayerAdapters","createAdapter","webmap","_createAdapter","utils","canvg","getImageData","img","canvas","window","document","createElement","context","getContext","Error","HTMLImageElement","drawImage","Canvg","fromString","start","ID","_layerId","allowedByType","line","fill","icon","concat","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","typeAliasForFilter","backAliases","a","layerType","backAlias","push","findMostFrequentGeomType","arr","counts","fry","length","maxName","c","maxCount","geometryFilter","geometry","backType","indexOf","PAINT","opacity","radius","selected","featureIdName","_types","_selectedFeatureIds","_sourceId","source","_selectionName","$onLayerClick","_onLayerClick","bind","layer","types","paint","_onAddLayer","t","geomType","_detectPaintType","_getLayerNameFromType","geomFilter","undefined","_addLayer","selectedPaint","selectionLayer","_getSelectionLayerNameFromType","_addEventsListeners","removeLayer","forEach","layerId","sourceId","_updateLayerPaint","layerName","layers","selName","_paint","nativePaint","_createPaintForType","p","setLayoutProperty","setPaintProperty","mapboxPaint","_registerImage","allowed","allowedType","find","x","Array","isArray","paramName","duration","_getRendromId","feature","id","hasImage","svgStr","Image","crossOrigin","src","btoa","onload","imageData","image","addImage","_selectFeature","_unselectFeature","_getAdditionalLayerOptions","filter","mType","layout","layerOpt","minzoom","maxzoom","visibility","filters","nativeFilter","e","preventDefault","queryRenderedFeatures","point","isSelected","unselectOnSecondClick","onLayerClick","falsePaint","properties","selectable","on","getCanvas","style","cursor","BaseAdapter","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","like","ilike","reversOperations","select","_updateFilter","unselect","MvtAdapter","sources","includes","addSource","tiles","sourceLayer","selLayerName","_createFilterDefinitions","setFilter","_operationsAliases","field","operation","value","operationAlias","subdomains","split","headers","transformRequests","resourceType","staticUrl","sourceOptions","tileSize","before","OPTIONS","Object","assign","TileAdapter","showCompass","_createButton","className","ariaLabel","fn","element","label","title","showZoom","_features","_filteredFeatureIds","_sources","data","addData","getSource","removeSource","clearLayer","cb","features","setData","detectedType","geojson","f","geometries","g","detectType","filterGeometries","rendromId","_rendromId","_filterFun","_filter","getLayers","filtered","visible","fun","removeFilter","getSelected","findFeatureFun","_getPaintFromCallback","multiselect","index","splice","ok","newFeatures","geomCollection","toSave","selectionArray","filteredArray","createControl","control","getDefaultPosition","onAdd","classList","add","bar","addClass","appendChild","_container","onRemove","parentNode","removeChild","remove","fitBoundsOptions","emitter","MapboxglMapAdapter","controlAdapters","isLoaded","_universalEvents","_sourceDataLoading","create","accessToken","target","mapOpt","container","attributionControl","bounds","fitOptions","transformRequest","transformed","_transformRequest","version","center","zoom","once","emit","destroy","getContainer","setView","jumpTo","setCenter","latLng","getCenter","lng","lat","setZoom","getZoom","fitBounds","linear","setRotation","angle","showLayer","layerIds","_toggleLayer","hideLayer","setLayerOrder","order","_sortTimerId","clearTimeout","setTimeout","_setLayerOrder","setLayerOpacity","_map","_onMapLoad","then","getLayer","createButtonControl","link","HTMLElement","innerHTML","child","firstElementChild","lineHeight","offsetHeight","onClick","stopPropagation","addEventListener","parent","removeEventListener","addControl","position","removeControl","onMapClick","evt","lngLat","y","pixel","top","left","_resolve","baseLayers","orderedLayers","l","sort","b","nextLayer","nextLayerId","mem","_getLayerIds","moveLayer","firstRealLayer","_layers","getDependLayers","_onMapSourceData","dataType","isSourceLoaded","_onDataLoad","_onMapError","keys","tile","params","r","TILE","MVT","OSM","OsmAdapter","GEOJSON","ZOOM","ZoomControl","COMPASS","CompassControl","ATTRIBUTION","AttributionControl","onMapLoad","decorators","onLoad","appendNgwResources","resource","defOptions","overwriteOptions","Number","resourceId","baseUrl","controls","controlsOptions","customAttribution","pixelRadius","kits","connector","auth","identification","starterKits","runtimeParams","prepareWebMapOptions","_ngwLayers","_createWebMap","_addControls","fit","controlDef","addNgwLayer","keyname","adapter","adapterOptions","getLayerId","getActiveBaseLayer","console","error","getNgwLayerItem","getNgwLayerItems","getNgwLayerFeature","getNgwLayerFeatures","getIdentifyGeoJson","identify","multiple","getNgwLayers","getNgwLayerByResourceId","n","getIdentificationIds","ids","some","dependLayers","dependFit","item","parentId","zoomToLayer","layerDef","ngwLayer","getExtent","extent","get","getNgwResourceExtent","event","enableSelection","__selectFromNgwRaster","ev","_selectFromNgwRaster","__selectFromNgwVector","_selectFromNgwVector","disableSelection","off","_isFitFromResource","_initMapState","qmsLayerName","qmsLayerOptions","addBaseLayer","resources","layerFitAllowed","webmapId","_emitStatusEvent","controlAdapterName","controlOptions","featureId","identifyFeature","fields","geom","featureCount","sourceType","nl","promises","all","getIds","metresPerPixel","Math","abs","cos","PI","pow","sendIdentifyRequest","resp","fixUrlStr","deepmerge","handleCallback","callback","executor","onCancel","_canceled","_promise","CancelablePromise","values","catch","onfulfilled","onrejected","cancel","errorCallback","_destroy","finally","onfinally","templateRe","template","str","key","routeStr","_loadingQueue","_loadingStatus","_keynames","route","setNextGisWeb","logout","connect","login","password","getUserInfo","makeQuery","credentials","_rejectLoadingQueue","user","getAuthorizationHeaders","client","makeClientId","Authorization","unescape","encodeURIComponent","getResourceByKeyname","getResourceChildren","request","apiItems","apiItem","shift","replaceParams","arg","paramArray","join","post","method","nocache","patch","put","delete","_getJson","_executeLoadingQueue","_setLoadingQueue","waiting","timestamp","Date","q","isError","queue","wait","responseType","xhr","processingResponce","forError","response","message","statusText","onerror","upload","onprogress","lengthComputable","percentComplete","loaded","total","onProgress","h","header","setRequestHeader","withCredentials","file","FormData","append","d","stringify","abort","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","fid","limit","intersects","filterById","featureIds","idFilterWorkAround","createGeoJsonAdapter","geoJsonAdapterCb","_lastFilterArgs","_dataPromise","geoJsonOptions","updateGeoJsonAdapterOptions","_opt","propertiesFilter","addLayerOptions","beforeRemove","updateLayer","createRasterAdapter","IMAGE","_options","getLayerAdapterOptions","layerAdapterOptions","tileAdapterOptions","addOptions","filterIn","filterFunc","relationFunc","_filtered","children","relChild","events","_children","setParent","_parent","addChild","getParent","getParents","tree","getRoot","toReturn","getChildren","getDescendants","EventEmitter","_blocked","_value","getProperty","call","isGroup","isBlocked","parents","parentProp","property","set","_prepareValue","update","_fireChangeEvent","getValue","_callOnSet","_removeEventsListener","onSet","prop","CheckProperty","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","getHierarchyValue","every","turnOff","hierarchy","blockChilds","turnOn","unblockChilds","block","_block","_unBlock","_blockChild","_unBlockChild","BaseProperty","propertiesList","_properties","_propertiesList","_setPropertyHandler","propOpt","handlers","ItemProperties","handler","list","initProperties","WebMapLayerItem","_rootDescendantsCount","item_type","_sumUp","root","_init","initItem","newLayer","_layer","i","reverse","layer_adapter","toUpperCase","layer_max_scale_denom","_mapScaleToZoomLevel","layer_min_scale_denom","minScale","maxScale","drawOrderEnabled","subOrder","draw_order_position","layer_enabled","transparency","layer_transparency","bringToFront","log","setScaleRatio","totalValue","_getWebMapLayerItem","_getWebMapIds","_webmapLayersIds","$$onMapClick","_onMapClick","getWebMapExtent","visibleLayers","getWebMapConfig","root_item","draw_order_enabled","_updateItemsParams","display_name","layer_style_id","updateWmsParams","webMapItem","promise","_sendIdentifyRequest","_extent","styles","createAdapterFromFirstStyle","childrenStyles","firstStyle","createAsyncAdapter","adapterType","resourceItem","createWebMapAdapter","cls","parentOptions","basemap_layer","prototype","resourceAdapter","derivedCtor","baseCtor","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","defineProperty","bbox","now","isImageAllowed","simplification","bottom","right","getNgwLayerExtent","maxLat","maxLon","minLat","minLon","res","_pixelsInMeter","d2r","r2d","earthsradius","points","rlat","rlng","extp","theta","ex","ey","sin","getCirclePoly","polygon","tan","pixelsInMeterWidth","div","cssText","body","px","offsetWidth","centerLat","LN2","getZoomFromScale","getMapWidthForLanInMeters","round","getIdentifyGeoJsonParams","paramsList","isNaN","sortingArr","layerFeatures","withGeom","onLoadSync","resourceIds","_getLayerAdapter","tagName","el","text","copy","navigator","clipboard","writeText","clipboardData","copyToClipboard","input","copyNodeContentsToClipboard","setSelectionRange","execCommand","Clipboard","_eventsStatus","setEventStatus","getEventStatus","_eventName","mergeArray","array","dst"],"mappings":"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","file":"main~f075b844-1ef3d54.js","sourcesContent":["/**\n * @module icons\n */\n\n// tslint:disable:max-line-length\nimport { IconOptions as WebmapIcoOptions } from '@nextgis/webmap';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star:\n    '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>'\n};\n\nexport interface IconOptions {\n  shape?:\n    | 'circle'\n    | 'brill'\n    | 'rect'\n    | 'marker'\n    | 'star'\n    | 'asterisk'\n    | 'triangle'\n    | 'plus'\n    | 'minus';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n}\n\nconst STROKE = 0.8;\n\nfunction insertSvg(\n  width: number,\n  height: number,\n  stroke = 0,\n  content?: string\n) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${width + stroke} ${height + stroke}\"\n  >${content}</svg>`;\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\nexport function getIcon(opt: IconOptions = {}): WebmapIcoOptions {\n  // default values\n  const shape = opt.shape || 'circle';\n  const color = opt.color || 'blue';\n  const strokeColor = opt.strokeColor || 'white';\n  const size = opt.size || 12;\n\n  const anchor = size / 2;\n  const defSize = 12;\n  const stroke = typeof opt.stroke === 'number' ? opt.stroke : STROKE;\n  const scale = size / defSize;\n\n  const pathAlias = svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(size, size, stroke * scale, path);\n  const fistChild = svg.firstChild as SVGElement;\n\n  const transform = `scale(${scale})`;\n\n  fistChild.setAttribute('fill', color);\n  if (stroke) {\n    fistChild.setAttribute('stroke', strokeColor);\n    fistChild.setAttribute('stroke-width', String(stroke));\n  }\n  fistChild.setAttribute('transform', transform);\n  const s = new XMLSerializer();\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: [anchor, anchor],\n    html: s.serializeToString(svg),\n    svg\n  };\n}\n","import {\n  WebMap,\n  BaseLayerAdapter,\n  LayerAdaptersOptions,\n  Type,\n  AdapterOptions\n} from '@nextgis/webmap';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  QmsAdapterOptions,\n  QmsBasemap,\n  QmsLayerType,\n  QmsAdapter as QA\n} from './interfaces';\n\nconst alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE'\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  const serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min\n  };\n}\n\nexport function loadJSON<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = 'https://qms.nextgis.com'\n): Type<BaseLayerAdapter> {\n  class QmsAdapter<M = any> implements BaseLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      this.options = options;\n      this.options.baseLayer = true;\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        this.qms = await loadJSON<QmsBasemap>(\n          url + '/api/v1/geoservices/' + options.qmsId\n        );\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const webMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (webMapAdapter) {\n          if (type === 'TILE') {\n            options = {\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms)\n            };\n            this.options = options;\n            const adapter = new webMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","/**\n * @module qms-kit\n */\n\nimport WebMap, { StarterKit, Type, BaseLayerAdapter } from '@nextgis/webmap';\nimport { QmsOptions } from './interfaces';\nimport { createQmsAdapter } from './utility';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com'\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap))\n      }\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<BaseLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n","/**\n * @module qms-kit\n */\n\nimport { QmsKit } from './QmsKit';\n\nexport * from './interfaces';\n\nexport { QmsKit };\nexport default QmsKit;\n","let canvg: any;\ntry {\n  canvg = require('canvg');\n} catch (er) {\n  // ignore\n}\ninterface GetImgOpt {\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  sdf?: string;\n  pixelRatio?: number;\n}\n\n// const defAddImgOpt = {\n//   width: 12,\n//   height: 12,\n//   x: 0,\n//   y: 0,\n//   sdf: undefined,\n//   pixelRatio: 2\n// };\n\n// // from /mapbox-gl/src/util/browser.js\nexport function getImageData(\n  img: string | HTMLImageElement,\n  opt: GetImgOpt\n): ImageData {\n  const canvas = window.document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('failed to create canvas 2d context');\n  }\n  canvas.setAttribute('width', String(opt.width));\n  canvas.setAttribute('height', String(opt.height));\n  if (!canvg && img instanceof HTMLImageElement) {\n    context.drawImage(img, 0, 0, opt.width, opt.height);\n  } else if (typeof img === 'string') {\n    if (canvg.Canvg) {\n      // for canvg v.3.x.x\n      const v = canvg.Canvg.fromString(context, img);\n      v.start();\n    } else {\n      // for canvg v.2.x.x\n      canvg(canvas, img);\n    }\n  }\n  return context.getImageData(0, 0, opt.width, opt.height);\n}\n\nexport function getImage(svgStr: string, opt: GetImgOpt): Promise<ImageData> {\n  return new Promise(resolve => {\n    if (canvg) {\n      resolve(getImageData(svgStr, opt));\n    } else {\n      const svgImage = new Image();\n      svgImage.crossOrigin = 'Anonymous';\n      svgImage.src = 'data:image/svg+xml;base64,' + btoa(svgStr);\n\n      svgImage.onload = () => {\n        const imageData = getImageData(svgImage, opt);\n        resolve(imageData);\n      };\n    }\n  });\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map } from 'mapbox-gl';\nimport { BaseLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\nexport abstract class BaseAdapter<O extends AdapterOptions = AdapterOptions>\n  implements BaseLayerAdapter<Map, TLayer, O> {\n  layer?: TLayer;\n  protected readonly _layerId: string;\n\n  constructor(public map: Map, public options: O) {\n    this._layerId = `layer-${ID++}`;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addLayer(options: O): TLayer | Promise<TLayer> | undefined {\n    return [''];\n  }\n}\n","import {\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  FeatureCollection,\n  Feature,\n  GeometryCollection\n} from 'geojson';\nimport { VectorAdapterLayerType } from '@nextgis/webmap';\n\nexport const allowedParams: Array<[string, string] | string> = [\n  'color',\n  'opacity'\n];\nexport const allowedByType = {\n  circle: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity'],\n    ['strokeColor', 'stroke-color'],\n    ['strokeOpacity', 'stroke-opacity'],\n    ['weight', 'stroke-width'],\n    'radius'\n  ],\n  line: [\n    ['strokeColor', 'color'],\n    ['strokeOpacity', 'opacity'],\n    ['weight', 'width']\n  ],\n  fill: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity']\n  ],\n  icon: allowedParams.concat([])\n};\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'circle',\n  LineString: 'line',\n  MultiPoint: 'circle',\n  Polygon: 'fill',\n  MultiLineString: 'line',\n  MultiPolygon: 'fill',\n  GeometryCollection: 'fill'\n};\n\nexport const typeAliasForFilter: {\n  [key in VectorAdapterLayerType]: GeoJsonGeometryTypes;\n} = {\n  circle: 'Point',\n  line: 'LineString',\n  fill: 'Polygon',\n  icon: 'Point'\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {\n  icon: ['Point']\n};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[]\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      f => f.geometry.type\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      g => g.type\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n\n// Static functions\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType\n): boolean {\n  const backType = backAliases[type];\n  if (backType) {\n    return backType.indexOf(geometry) !== -1;\n  }\n  return false;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  IconOptions,\n  VectorLayerAdapter,\n  VectorAdapterOptions\n} from '@nextgis/webmap';\nimport {\n  Feature as F,\n  GeometryObject,\n  Geometry,\n  GeoJsonProperties\n} from 'geojson';\nimport {\n  Map,\n  MapLayerMouseEvent,\n  AnySourceData\n  // BackgroundPaint, FillPaint, FillExtrusionPaint, LinePaint, SymbolPaint,\n  // RasterPaint, CirclePaint, HeatmapPaint, HillshadePaint,\n} from 'mapbox-gl';\n\n// type MapboxPaint = BackgroundPaint | FillPaint | FillExtrusionPaint | LinePaint | SymbolPaint |\n//   RasterPaint | CirclePaint | HeatmapPaint | HillshadePaint;\n\nimport { getImage } from '../util/image_icons';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { BaseAdapter } from './BaseAdapter';\nimport { typeAliasForFilter, allowedByType } from '../util/geom_type';\n\nexport interface Feature<\n  G extends GeometryObject | null = Geometry,\n  P = GeoJsonProperties\n  > extends F<G, P> {\n  _rendromId?: string;\n}\n\nconst PAINT = {\n  color: 'blue',\n  opacity: 1,\n  radius: 10\n};\n\ntype MapboxLayerType = 'fill' | 'line' | 'symbol' | 'circle';\n\nexport abstract class VectorAdapter<\n  O extends VectorAdapterOptions = VectorAdapterOptions\n  > extends BaseAdapter<O>\n  implements VectorLayerAdapter<Map, TLayer, O, Feature> {\n  selected = false;\n\n  protected featureIdName = 'id';\n  protected _types: VectorAdapterLayerType[] = ['fill', 'circle', 'line'];\n  protected readonly _sourceId: string;\n  protected readonly _selectionName: string;\n  protected _selectedFeatureIds: string[] = [];\n\n  private $onLayerClick?: (e: MapLayerMouseEvent) => void;\n\n  constructor(public map: Map, public options: O) {\n    super(map, options);\n    this._sourceId = this.options.source\n      ? (this.options.source as string)\n      : `source-${this._layerId}`;\n    this._selectionName = this._layerId + '-highlighted';\n    this.$onLayerClick = this._onLayerClick.bind(this);\n  }\n\n  async addLayer(options: O): Promise<TLayer> {\n    options = this.options = { ...this.options, ...(options || {}) };\n\n    this.layer = [];\n    const types = (this._types = options.type ? [options.type] : this._types);\n    if (options.paint) {\n      this._onAddLayer(this._sourceId);\n      // const types = this._types;\n      for (const t of types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          let type = t;\n          if (t === 'circle') {\n            const paintType = this._detectPaintType(options.paint);\n            if (paintType === 'icon') {\n              type = 'icon';\n            }\n          }\n          const layer = this._getLayerNameFromType(t);\n          // const geomFilter = ['==', '$type', geomType];\n          const geomFilter =\n            types.length > 1 ? ['==', '$type', geomType] : undefined;\n          await this._addLayer(layer, type, geomFilter);\n          this.layer.push(layer);\n          if (options.selectedPaint) {\n            const selectionLayer = this._getSelectionLayerNameFromType(t);\n            await this._addLayer(selectionLayer, type, [\n              geomFilter,\n              ['in', this.featureIdName, '']\n            ]);\n            this.layer.push(selectionLayer);\n          }\n        }\n      }\n    }\n\n    this._addEventsListeners();\n\n    return this.layer;\n  }\n\n  removeLayer() {\n    const map = this.map;\n    if (this.layer) {\n      this.layer.forEach(layerId => {\n        map.removeLayer(layerId);\n      });\n    }\n  }\n\n  protected _onAddLayer(sourceId: string, options?: AnySourceData) {\n    // ignore\n  }\n\n  protected async _updateLayerPaint(type: VectorAdapterLayerType) {\n    const layerName = this._getLayerNameFromType(type);\n\n    if (this.options.paint) {\n      const layers: [string, VectorAdapterLayerPaint | GetPaintCallback][] = [\n        [layerName, this.options.paint]\n      ];\n      if (this.options.selectedPaint) {\n        const selName = this._getSelectionLayerNameFromType(type);\n        layers.push([selName, this.options.selectedPaint]);\n      }\n\n      for (const [name, paint] of layers) {\n        let _paint: any;\n        if (this.options.nativePaint) {\n          _paint =\n            typeof this.options.nativePaint === 'boolean'\n              ? paint\n              : this.options.nativePaint;\n        } else {\n          _paint = await this._createPaintForType(paint, type, name);\n        }\n\n        if ('icon-image' in _paint) {\n          // If true, the icon will be visible even if it collides with other previously drawn symbols.\n          _paint['icon-allow-overlap'] = true;\n          for (const p in _paint) {\n            this.map.setLayoutProperty(name, p, _paint[p]);\n          }\n        } else {\n          for (const p in _paint) {\n            this.map.setPaintProperty(name, p, _paint[p]);\n          }\n        }\n      }\n    }\n  }\n\n  protected _getLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._layerId;\n  }\n\n  protected _getSelectionLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._selectionName;\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name?: string\n  ): Promise<any> {\n    if (typeof paint !== 'function') {\n      const mapboxPaint: any = {};\n      const _paint = { ...PAINT, ...(paint || {}) };\n      if (paint.type === 'icon' && paint.html) {\n        await this._registerImage(paint);\n        return {\n          'icon-image': paint.html\n        };\n      } else {\n        for (const p in _paint) {\n          const allowed = allowedByType[type];\n          if (allowed) {\n            const allowedType = allowed.find(x => {\n              if (typeof x === 'string') {\n                return x === p;\n              } else if (Array.isArray(x)) {\n                return x[0] === p;\n              }\n              return false;\n            });\n            if (allowedType) {\n              const paramName = Array.isArray(allowedType)\n                ? allowedType[1]\n                : allowedType;\n              // @ts-ignore\n              mapboxPaint[type + '-' + paramName] = _paint[p];\n            }\n          }\n        }\n        mapboxPaint[type + '-opacity-transition'] = { duration: 0 };\n        return mapboxPaint;\n      }\n    }\n  }\n\n  protected _getRendromId(feature: Feature): string | undefined {\n    // @ts-ignore\n    return feature.id;\n  }\n\n  protected async _registerImage(paint: IconOptions) {\n    if (paint.html) {\n      const imageExist = this.map.hasImage(paint.html);\n      if (!imageExist) {\n        let width = 12;\n        let height = 12;\n        if (paint.iconSize) {\n          width = paint.iconSize[0];\n          height = paint.iconSize[1];\n        }\n        const image = await getImage(paint.html, {\n          width,\n          height\n        });\n\n        this.map.addImage(paint.html, image);\n      }\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _unselectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _getAdditionalLayerOptions() {\n    return {};\n  }\n\n  protected async _addLayer(\n    name: string,\n    type: VectorAdapterLayerType,\n    filter?: any[]\n  ) {\n    let mType: MapboxLayerType;\n    if (type === 'icon') {\n      mType = 'symbol';\n    } else {\n      mType = type;\n    }\n    const layout = (this.options.layout || {}) as mapboxgl.AnyLayout;\n    const layerOpt: mapboxgl.Layer = {\n      id: name,\n      type: mType,\n      source: this._sourceId,\n      minzoom: this.options.minZoom,\n      maxzoom: this.options.maxZoom,\n      layout: {\n        visibility: 'none',\n        ...layout\n      },\n      ...this._getAdditionalLayerOptions()\n    };\n    const filters = [\n      'all',\n      ...(filter || []),\n      this.options.nativeFilter\n    ].filter(x => x);\n\n    if (filters.length > 1) {\n      layerOpt.filter = filters;\n    }\n\n    this.map.addLayer(layerOpt);\n  }\n\n  private _onLayerClick(e: mapboxgl.MapLayerMouseEvent) {\n    e.preventDefault();\n    const features = this.map.queryRenderedFeatures(e.point, {\n      layers: this.layer\n    });\n    const feature = features[0] as Feature;\n    if (feature) {\n      const id = this._getRendromId(feature);\n      if (id !== undefined) {\n        let isSelected = this._selectedFeatureIds.indexOf(id) !== -1;\n        if (isSelected) {\n          if (this.options && this.options.unselectOnSecondClick) {\n            this._unselectFeature(feature);\n            isSelected = false;\n          }\n        } else {\n          this._selectFeature(feature);\n          isSelected = true;\n        }\n        if (this.options.onLayerClick) {\n          this.options.onLayerClick({\n            layer: this,\n            feature,\n            selected: isSelected\n          });\n        }\n      }\n    }\n  }\n\n  private _detectPaintType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback\n  ): string | undefined {\n    if ('type' in paint) {\n      return paint.type;\n    } else if (typeof paint === 'function') {\n      try {\n        const falsePaint = paint({\n          type: 'Feature',\n          properties: {},\n          geometry: {} as Geometry\n        });\n        return this._detectPaintType(falsePaint);\n      } catch (er) {\n        //\n      }\n    }\n  }\n\n  private _addEventsListeners() {\n    if (this.layer && this.options && this.options.selectable) {\n      this.layer.forEach(x => {\n        if (this.$onLayerClick) {\n          const onLayerClick = this.$onLayerClick;\n          this.map.on('click', x, (e: MapLayerMouseEvent) => {\n            onLayerClick(e);\n          });\n        }\n\n        this.map.on('mousemove', x, () => {\n          this.map.getCanvas().style.cursor = 'pointer';\n        });\n        this.map.on('mouseleave', x, () => {\n          this.map.getCanvas().style.cursor = '';\n        });\n      });\n    }\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  MvtAdapterOptions,\n  PropertiesFilter,\n  Operations\n} from '@nextgis/webmap';\nimport { VectorAdapter } from './VectorAdapter';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nimport { typeAliasForFilter } from '../util/geom_type';\n\nexport const operationsAliases: { [key in Operations]: string } = {\n  gt: '>',\n  lt: '<',\n  ge: '>=',\n  le: '<=',\n  eq: '==',\n  ne: '!=',\n  in: 'in',\n  notin: '!in',\n  // NOT SUPPORTED\n  like: '==',\n  // NOT SUPPORTED\n  ilike: '=='\n};\n\nconst reversOperations: { [key in Operations]: string } = {\n  gt: operationsAliases.le,\n  lt: operationsAliases.ge,\n  ge: operationsAliases.lt,\n  le: operationsAliases.gt,\n  eq: operationsAliases.ne,\n  ne: operationsAliases.eq,\n  in: operationsAliases.notin,\n  notin: operationsAliases.in,\n  like: operationsAliases.ne,\n  ilike: operationsAliases.ne\n};\n\nexport class MvtAdapter extends VectorAdapter<MvtAdapterOptions> {\n  static sources: string[] = [];\n\n  source?: string;\n\n  select(properties: PropertiesFilter) {\n    if (typeof properties !== 'function') {\n      this._updateFilter(properties);\n    }\n    this.selected = true;\n  }\n\n  unselect() {\n    this._updateFilter();\n    this.selected = false;\n  }\n\n  async addLayer(options: MvtAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    this._updateLayerPaint(this.options.type || 'fill');\n\n    return layer;\n  }\n\n  protected _getAdditionalLayerOptions() {\n    const exist = MvtAdapter.sources.includes(this.options.url);\n    if (!exist) {\n      this.map.addSource(this.options.url, {\n        type: 'vector',\n        tiles: [this.options.url]\n      });\n      this.source = this.options.url;\n      MvtAdapter.sources.push(this.options.url);\n    }\n    const mvtLayerOptions: Partial<mapboxgl.Layer> = {\n      source: this.options.url,\n      'source-layer': this.options.sourceLayer\n    };\n    return mvtLayerOptions;\n  }\n\n  private _updateFilter(properties?: PropertiesFilter) {\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              const filters = properties\n                ? this._createFilterDefinitions(properties, operationsAliases)\n                : [];\n              this.map.setFilter(selLayerName, ['all', geomFilter, ...filters]);\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filters = properties\n              ? this._createFilterDefinitions(properties, reversOperations)\n              : [];\n            this.map.setFilter(layerName, ['all', geomFilter, ...filters]);\n          }\n        }\n      });\n    }\n  }\n\n  private _createFilterDefinitions(\n    filters: PropertiesFilter,\n    _operationsAliases: { [key in Operations]: string }\n  ) {\n    return filters.map(x => {\n      const [field, operation, value] = x;\n      const operationAlias = _operationsAliases[operation];\n      if (operation === 'in' || operation === 'notin') {\n        return [operationAlias, field, ...value];\n      }\n      return [operationAlias, field, value];\n    });\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { BaseAdapter } from './BaseAdapter';\nimport { RasterSource, ResourceType } from 'mapbox-gl';\n\nexport class TileAdapter extends BaseAdapter<TileAdapterOptions>\n  implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    options = { ...this.options, ...(options || {}) };\n\n    let tiles: string[];\n    if (options && options.subdomains) {\n      tiles = options.subdomains.split('').map(x => {\n        const subUrl = options.url.replace('{s}', x);\n        return subUrl;\n      });\n    } else {\n      tiles = [options.url];\n    }\n    if (options.headers) {\n      // @ts-ignore\n      const transformRequests = this.map.transformRequests;\n      transformRequests.push((url: string, resourceType: ResourceType) => {\n        let staticUrl = url;\n        staticUrl = staticUrl.replace(/(z=\\d+)/, 'z={z}');\n        staticUrl = staticUrl.replace(/(x=\\d+)/, 'x={x}');\n        staticUrl = staticUrl.replace(/(y=\\d+)/, 'y={y}');\n        if (staticUrl === options.url) {\n          return {\n            url,\n            headers: options.headers\n          };\n        }\n      });\n    }\n\n    const sourceOptions: RasterSource = {\n      type: 'raster',\n      // point to our third-party tiles. Note that some examples\n      // show a \"url\" property. This only applies to tilesets with\n      // corresponding TileJSON (such as mapbox tiles).\n      tiles,\n      tileSize: 256 // opt && opt.tileSize ||\n    };\n    if (options.attribution) {\n      sourceOptions.attribution = options.attribution;\n    }\n\n    this.map.addLayer(\n      {\n        id: this._layerId,\n        type: 'raster',\n        layout: {\n          visibility: 'none'\n        },\n        minzoom: this.options.minZoom,\n        maxzoom: this.options.maxZoom,\n        source: sourceOptions\n        // TODO: clean remove before options from all existing apps\n      },\n      // @ts-ignore\n      options.before\n    );\n    const layer = (this.layer = [this._layerId]);\n    return layer;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileAdapter } from './TileAdapter';\n\nconst OPTIONS = {\n  url: 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n  attribution:\n    '&copy; <a href=\"http://osm.org/copyright\" target=\"_blank\">OpenStreetMap</a> contributors',\n  subdomains: 'abc'\n};\n\nexport class OsmAdapter extends TileAdapter implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    return super.addLayer(Object.assign({}, OPTIONS, options));\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\nimport { ZoomControlOptions } from '@nextgis/webmap';\n\nexport class ZoomControl extends NavigationControl {\n  options: ZoomControlOptions & any;\n\n  constructor(options: ZoomControlOptions & any = {}) {\n    options = { ...options, showCompass: false };\n    super(options);\n  }\n\n  _createButton(className: string, ariaLabel: string, fn: () => any) {\n    // @ts-ignore\n    const element = super._createButton(className, ariaLabel, fn);\n    const aliases: any = {\n      'Zoom in': 'zoomInTitle',\n      'Zoom out': 'zoomOutTitle'\n    };\n    const alias = aliases[ariaLabel];\n    const label = alias && this.options[alias];\n    if (label) {\n      element.title = label;\n      element.setAttribute('aria-label', label);\n    }\n\n    return element;\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\n\nexport class CompassControl extends NavigationControl {\n  constructor(options = {}) {\n    options = Object.assign({}, options, { showZoom: false });\n    super(options);\n  }\n}\n","// import { MapControl } from '@nextgis/webmap';\nimport { AttributionControl as AC } from 'mapbox-gl';\n\nexport class AttributionControl extends AC {}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map, GeoJSONSource, GeoJSONSourceRaw } from 'mapbox-gl';\nimport {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  DataLayerFilter,\n  LayerDefinition\n} from '@nextgis/webmap';\nimport {\n  GeoJsonObject,\n  FeatureCollection,\n  GeometryCollection,\n  GeometryObject\n} from 'geojson';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { VectorAdapter, Feature } from './VectorAdapter';\nimport {\n  detectType,\n  typeAlias,\n  typeAliasForFilter,\n  geometryFilter\n} from '../util/geom_type';\n\nlet ID = 0;\n\nexport class GeoJsonAdapter extends VectorAdapter<GeoJsonAdapterOptions> {\n  selected = false;\n  source?: string;\n  protected featureIdName = '_rendromId';\n  private _features: Feature[] = [];\n  private _filteredFeatureIds: string[] = [];\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _sources: Record<string, GeoJSONSource> = {};\n\n  constructor(public map: Map, public options: GeoJsonAdapterOptions) {\n    super(map, options);\n    this.source = this._sourceId;\n  }\n\n  async addLayer(options: GeoJsonAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    if (this.options.data) {\n      this.addData(this.options.data);\n    }\n    return layer;\n  }\n\n  removeLayer() {\n    super.removeLayer();\n    const source = this.map.getSource(this._sourceId);\n    if (source) {\n      this.map.removeSource(this._sourceId);\n    }\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean) {\n    let features: Feature[] = [];\n    const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n    if (cb) {\n      features = this._features = this._features.filter(x => !cb(x));\n    }\n    source.setData({ type: 'FeatureCollection', features });\n  }\n\n  async addData(data: GeoJsonObject) {\n    let type: VectorAdapterLayerType | undefined;\n    if (this.options.type) {\n      type = this.options.type;\n    }\n    if (!type && data) {\n      const detectedType = detectType(data);\n      type = typeAlias[detectedType];\n    }\n    if (data && type) {\n      const features = this.filterGeometries(data, type);\n      features.forEach(x => {\n        // to avoid id = 0 is false\n        const rendromId = '_' + ID++;\n        x._rendromId = rendromId;\n        if (x.properties) {\n          x.properties[this.featureIdName] = rendromId;\n        }\n      });\n      if (this._filterFun) {\n        this._filter(this._filterFun);\n      }\n      await this._updateLayerPaint(type);\n      const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n      source.setData({ type: 'FeatureCollection', features: this._features });\n    }\n  }\n\n  getLayers() {\n    const filtered = this._filteredFeatureIds.length;\n    return this._features.map(feature => {\n      let visible = false;\n      if (filtered) {\n        const id = this._getRendromId(feature);\n        if (id !== undefined) {\n          visible = this._filteredFeatureIds.indexOf(id) !== -1;\n        }\n      }\n      return {\n        feature,\n        visible\n      };\n    });\n  }\n\n  filter(fun: DataLayerFilter<Feature, TLayer>) {\n    this._filterFun = fun;\n    this._filter(fun);\n  }\n\n  removeFilter() {\n    this._filterFun = undefined;\n    this._filteredFeatureIds = [];\n    this._updateFilter();\n  }\n\n  getSelected() {\n    const features: LayerDefinition<Feature, TLayer>[] = [];\n    this._features.forEach(x => {\n      const id = this._getRendromId(x);\n      if (id && this._selectedFeatureIds.indexOf(id) !== -1) {\n        features.push({ feature: x });\n      }\n    });\n    return features;\n  }\n\n  select(findFeatureFun?: (opt: { feature: Feature }) => boolean) {\n    if (findFeatureFun) {\n      const features = this._features.filter(x =>\n        findFeatureFun({ feature: x })\n      );\n      this._selectFeature(features);\n    } else if (!this.selected) {\n      this._selectFeature(this._features);\n    }\n    this.selected = true;\n  }\n\n  unselect(findFeatureFun?: (opt: { feature: Feature }) => boolean) {\n    if (findFeatureFun) {\n      const features = this._features.filter(x =>\n        findFeatureFun({ feature: x })\n      );\n      this._unselectFeature(features);\n    } else if (this.selected) {\n      this._unselectFeature(this._features);\n    }\n    this.selected = !!this._selectedFeatureIds.length;\n  }\n\n  protected _onAddLayer(sourceId: string) {\n    let source = this.map.getSource(sourceId) as GeoJSONSource;\n    if (!source) {\n      const sourceOpt: GeoJSONSourceRaw = {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features: []\n        }\n      };\n      const _opts: Array<keyof GeoJsonAdapterOptions> = [\n        'cluster',\n        'clusterMaxZoom',\n        'clusterRadius'\n      ];\n      _opts.forEach(x => {\n        const opt = this.options[x] as GeoJsonAdapterOptions;\n        if (opt !== undefined) {\n          //@ts-ignore\n          sourceOpt[x] = opt;\n        }\n      });\n      this.map.addSource(sourceId, sourceOpt);\n      source = this.map.getSource(sourceId) as GeoJSONSource;\n    }\n    this._sources[sourceId] = source;\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  protected _getRendromId(feature: Feature): string | undefined {\n    // @ts-ignore\n    const id = feature._rendromId;\n    if (id !== undefined) {\n      return id;\n    } else if (\n      feature.properties &&\n      feature.properties._rendromId !== undefined\n    ) {\n      return feature.properties._rendromId;\n    }\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ): Promise<any> {\n    if (typeof paint === 'function') {\n      return await this._getPaintFromCallback(paint, type, name);\n    } else {\n      return super._createPaintForType(paint, type, name);\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    if (this.options && !this.options.multiselect) {\n      this._selectedFeatureIds = [];\n    }\n    let features: Feature[] = [];\n    if (Array.isArray(feature)) {\n      features = feature;\n    } else {\n      features = [feature];\n    }\n    features.forEach(f => {\n      const id = this._getRendromId(f);\n      if (id !== undefined) {\n        this._selectedFeatureIds.push(id);\n      }\n    });\n    this._updateFilter();\n  }\n\n  protected _unselectFeature(feature: Feature | Feature[]) {\n    let features: Feature[] = [];\n    if (Array.isArray(feature)) {\n      features = feature;\n    } else {\n      features = [feature];\n    }\n    features.forEach(f => {\n      const id = this._getRendromId(f);\n      if (id !== undefined) {\n        const index = this._selectedFeatureIds.indexOf(id);\n        if (index !== -1) {\n          this._selectedFeatureIds.splice(index, 1);\n        }\n      }\n    });\n    this._updateFilter();\n  }\n\n  private _filter(fun: DataLayerFilter<Feature, TLayer>) {\n    this._filteredFeatureIds = [];\n    this._features.forEach(feature => {\n      const ok = fun({ feature });\n      const id = this._getRendromId(feature);\n      if (ok && id) {\n        this._filteredFeatureIds.push(id);\n      }\n    });\n    this._updateFilter();\n  }\n\n  private filterGeometries(\n    data: GeoJsonObject,\n    type: VectorAdapterLayerType\n  ): Feature[] {\n    let newFeatures: Feature[] = [];\n    if (data.type === 'FeatureCollection') {\n      const features = (data as FeatureCollection).features.filter(f =>\n        geometryFilter(f.geometry.type, type)\n      ) as Feature[];\n      (data as FeatureCollection).features = features;\n      newFeatures = features;\n    } else if (data.type === 'Feature') {\n      const allow = geometryFilter((data as Feature).geometry.type, type);\n      if (!allow) {\n        return [];\n      }\n      newFeatures.push(data as Feature);\n    } else if (data.type === 'GeometryCollection') {\n      const geomCollection = data as GeometryCollection;\n      geomCollection.geometries = geomCollection.geometries.filter(g =>\n        geometryFilter(g.type, type)\n      );\n      newFeatures = geomCollection.geometries.map(x => {\n        const f: Feature = {\n          type: 'Feature',\n          geometry: x as GeometryObject,\n          properties: {}\n        };\n        return f;\n      });\n    } else if (typeAlias[data.type]) {\n      const obj: Feature = {\n        type: 'Feature',\n        geometry: data as GeometryObject,\n        properties: {}\n      };\n      newFeatures = [obj];\n    }\n    this._features = this._features.concat(newFeatures);\n    return newFeatures;\n  }\n\n  private async _getPaintFromCallback(\n    paint: GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ) {\n    const style: any = {};\n    for (const feature of this._features) {\n      const _paint = paint(feature);\n      if (_paint.type === 'icon') {\n        await this._registerImage(_paint);\n        if (feature.properties) {\n          feature.properties['_icon-image-' + name] = _paint.html;\n        }\n        style['icon-image'] = `{_icon-image-${name}}`;\n      } else {\n        for (const p in _paint) {\n          // @ts-ignore\n          const toSave = _paint[p];\n          if (feature.properties) {\n            feature.properties[`_paint_${p}_${name}`] = toSave;\n          }\n          style[p] = ['get', `_paint_${p}_${name}`];\n        }\n      }\n    }\n    if ('icon-image' in style) {\n      return style;\n    }\n    const styleFromCb = this._createPaintForType(style, type, name);\n    return styleFromCb;\n  }\n\n  private _updateFilter() {\n    let selectionArray: string[] = [];\n    const filteredArray: string[] = [];\n\n    if (this._filteredFeatureIds.length) {\n      this._features.forEach(x => {\n        const id = this._getRendromId(x);\n        if (id !== undefined && this._filteredFeatureIds.indexOf(id) !== -1) {\n          if (this._selectedFeatureIds.indexOf(id) !== -1) {\n            selectionArray.push(id);\n          } else {\n            filteredArray.push(id);\n          }\n        }\n      });\n    } else {\n      selectionArray = this._selectedFeatureIds;\n    }\n\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              this.map.setFilter(selLayerName, [\n                'all',\n                geomFilter,\n                ['in', this.featureIdName, ...selectionArray]\n              ]);\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            if (this._filteredFeatureIds.length) {\n              this.map.setFilter(layerName, [\n                'all',\n                geomFilter,\n                ['in', this.featureIdName, ...filteredArray]\n              ]);\n            } else {\n              this.map.setFilter(layerName, [\n                'all',\n                geomFilter,\n                ['!in', this.featureIdName, ...selectionArray]\n              ]);\n            }\n          }\n        }\n      });\n    }\n  }\n}\n","import { MapControl, CreateControlOptions } from '@nextgis/webmap';\nimport { IControl } from 'mapbox-gl';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {}\n): IControl {\n  class Control implements IControl {\n    private _container?: HTMLElement;\n\n    getDefaultPosition() {\n      return 'top-left';\n    }\n\n    onAdd() {\n      const element = document.createElement('div');\n      const content: HTMLElement = control.onAdd();\n      element.classList.add('mapboxgl-ctrl');\n      if (options.bar) {\n        // add custom css for boarder style\n        element.classList.add('mapboxgl-bar');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      element.appendChild(content);\n      this._container = element;\n      return this._container;\n    }\n\n    onRemove() {\n      if (this._container) {\n        const parent = this._container.parentNode;\n        if (parent) {\n          parent.removeChild(this._container);\n        }\n      }\n      return control.onRemove();\n    }\n\n    remove() {\n      this.onRemove();\n    }\n  }\n\n  return new Control();\n  // return control;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  MapAdapter,\n  FitOptions,\n  MapControl,\n  ControlPositions,\n  ButtonControlOptions,\n  LngLatArray,\n  MapOptions,\n  LayerAdapter,\n  LngLatBoundsArray,\n  WebMapEvents,\n  CreateControlOptions\n} from '@nextgis/webmap';\nimport { MvtAdapter } from './layer-adapters/MvtAdapter';\nimport mapboxgl, {\n  Map,\n  IControl,\n  MapEventType,\n  EventData,\n  MapboxOptions,\n  RequestParameters,\n  ResourceType\n} from 'mapbox-gl';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter';\nimport { EventEmitter } from 'events';\nimport { ZoomControl } from './controls/ZoomControl';\nimport { CompassControl } from './controls/CompassControl';\nimport { AttributionControl } from './controls/AttributionControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { createControl } from './controls/createControl';\nimport { createButtonControl } from './controls/createButtonControl';\n\nexport type TLayer = string[];\ntype TLayerAdapter = LayerAdapter<Map, TLayer>;\n\nconst fitBoundsOptions: FitOptions = {\n  // padding: 100\n};\n\nexport interface MapboxglMapAdapterOptions extends MapOptions {\n  style?: Partial<mapboxgl.Style> | string;\n  accessToken?: string;\n}\n\nexport class MapboxglMapAdapter implements MapAdapter<Map, TLayer, IControl> {\n  static layerAdapters = {\n    TILE: TileAdapter,\n    // IMAGE: ImageAdapter,\n    MVT: MvtAdapter,\n    OSM: OsmAdapter,\n    GEOJSON: GeoJsonAdapter\n  };\n\n  static controlAdapters: { [name: string]: any } = {\n    ZOOM: ZoomControl,\n    COMPASS: CompassControl,\n    ATTRIBUTION: AttributionControl\n  };\n\n  options: MapboxglMapAdapterOptions = {};\n  map!: Map;\n\n  emitter = new EventEmitter();\n\n  layerAdapters = MapboxglMapAdapter.layerAdapters;\n  controlAdapters = MapboxglMapAdapter.controlAdapters;\n  isLoaded = false;\n\n  private _universalEvents: Array<keyof WebMapEvents> = [\n    'zoomstart',\n    'zoom',\n    'zoomend',\n    'movestart',\n    'move',\n    'moveend'\n  ];\n\n  private _sourceDataLoading: { [name: string]: any[] } = {};\n  private _sortTimerId?: number;\n\n  // create(options: MapOptions = {target: 'map'}) {\n  create(options: MapboxglMapAdapterOptions) {\n    return new Promise((resolve, reject) => {\n      if (!this.map) {\n        this.options = options;\n        if (options.accessToken) {\n          mapboxgl.accessToken = options.accessToken;\n        }\n        if (options.target) {\n          const mapOpt: MapboxOptions = {\n            container: options.target,\n            attributionControl: false,\n            // @ts-ignore\n            bounds: options.bounds,\n            fitBoundsOptions: { ...options.fitOptions, ...fitBoundsOptions },\n            transformRequest: (url: string, resourceType: ResourceType) => {\n              const transformed = this._transformRequest(url, resourceType);\n              if (transformed) {\n                return transformed;\n              } else {\n                return {\n                  url\n                };\n              }\n            }\n          };\n          if (typeof options.style === 'string') {\n            mapOpt.style = options.style;\n          } else {\n            mapOpt.style = {\n              ...{\n                version: 8,\n                name: 'Empty style',\n                sources: {},\n                layers: []\n              },\n              ...options.style\n            };\n          }\n          if (options.center !== undefined) {\n            mapOpt.center = options.center;\n          }\n          if (options.zoom !== undefined) {\n            mapOpt.zoom = options.zoom - 1;\n          }\n          if (options.maxZoom) {\n            mapOpt.maxZoom = options.maxZoom - 1;\n          }\n          if (options.minZoom) {\n            mapOpt.minZoom = options.minZoom - 1;\n          }\n          this.map = new Map(mapOpt);\n          // @ts-ignore\n          this.map.transformRequests = [];\n\n          this.map.once('load', () => {\n            this.isLoaded = true;\n            this.emitter.emit('create', this);\n            resolve(this);\n          });\n          this._addEventsListeners();\n        }\n      }\n    });\n  }\n\n  destroy() {\n    if (this.map) {\n      this.map.remove();\n    }\n  }\n\n  getContainer() {\n    return this.map && this.map.getContainer();\n  }\n\n  setView(center: LngLatArray, zoom?: number) {\n    if (this.map) {\n      const options: mapboxgl.CameraOptions = { center };\n      if (zoom) {\n        options.zoom = zoom - 1;\n      }\n      this.map.jumpTo(options);\n    }\n  }\n\n  setCenter(latLng: LngLatArray): void {\n    if (this.map) {\n      this.map.setCenter(latLng);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    if (this.map) {\n      const center = this.map.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom - 1);\n    }\n  }\n\n  getZoom(): number | undefined {\n    if (this.map) {\n      const zoom = this.map.getZoom();\n      return zoom ? zoom + 1 : undefined;\n    }\n  }\n\n  // [extent_left, extent_bottom, extent_right, extent_top];\n  fitBounds(e: LngLatBoundsArray, options: FitOptions = {}): void {\n    if (this.map) {\n      this.map.fitBounds(\n        [\n          [e[0], e[1]],\n          [e[2], e[3]]\n        ],\n        {\n          linear: true,\n          ...options,\n          ...fitBoundsOptions\n        }\n      );\n    }\n  }\n\n  setRotation(angle: number): void {\n    // ignore\n  }\n\n  showLayer(layerIds: string[]): void {\n    layerIds.forEach(layerId => {\n      this._toggleLayer(layerId, true);\n    });\n  }\n\n  hideLayer(layerIds: string[]): void {\n    layerIds.forEach(layerId => {\n      this._toggleLayer(layerId, false);\n    });\n  }\n\n  removeLayer(layerIds: string[]): void {\n    if (this.map) {\n      const _map = this.map;\n      layerIds.forEach(layerId => {\n        _map.removeLayer(layerId);\n        const source = _map.getSource(layerId);\n        if (source) {\n          _map.removeSource(layerId);\n        }\n      });\n    }\n  }\n\n  setLayerOrder(\n    layerIds: string[],\n    order: number,\n    layers: { [x: string]: TLayerAdapter }\n  ): void {\n    if (this._sortTimerId) {\n      window.clearTimeout(this._sortTimerId);\n    }\n    this._sortTimerId = window.setTimeout(() => this._setLayerOrder(layers));\n  }\n\n  setLayerOpacity(layerIds: string[], opacity: number): void {\n    const _map = this.map;\n    if (_map) {\n      layerIds.forEach(layerId => {\n        this._onMapLoad().then(() => {\n          const layer = _map.getLayer(layerId);\n          if (layer) {\n            if (layer.type === 'symbol') {\n              _map.setPaintProperty(layerId, 'text-opacity', opacity);\n              _map.setPaintProperty(layerId, 'icon-opacity', opacity);\n            } else {\n              _map.setPaintProperty(layerId, layer.type + '-opacity', opacity);\n            }\n          }\n        });\n      });\n    }\n  }\n\n  createControl(control: MapControl, options?: CreateControlOptions): IControl {\n    return createControl(control, options);\n  }\n\n  createButtonControl(options: ButtonControlOptions): IControl {\n    return createButtonControl(options);\n  }\n\n  addControl(\n    control: IControl,\n    position: ControlPositions\n  ): IControl | undefined {\n    if (this.map) {\n      this.map.addControl(control, position);\n      return control;\n    }\n  }\n\n  removeControl(control: IControl): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  onMapClick(evt: MapEventType['click'] & EventData): void {\n    const latLng = evt.lngLat;\n    const { x, y } = evt.point;\n\n    this.emitter.emit('click', { latLng, pixel: { top: y, left: x } });\n  }\n\n  private _onMapLoad(cb?: () => any): Promise<Map> {\n    return new Promise<Map>(resolve => {\n      const _resolve = () => {\n        if (cb) {\n          cb();\n        }\n        if (this.map) {\n          resolve(this.map);\n        }\n      };\n      if (this.isLoaded) {\n        // map.loaded()\n        _resolve();\n      } else if (this.map) {\n        this.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  private _setLayerOrder(layers: { [x: string]: TLayerAdapter }): void {\n    const _map = this.map;\n    if (_map) {\n      const baseLayers: TLayerAdapter[] = [];\n      let orderedLayers: TLayerAdapter[] = [];\n      for (const l in layers) {\n        const layer = layers[l];\n        if (layer.options.baseLayer) {\n          baseLayers.push(layer);\n        } else {\n          orderedLayers.push(layer);\n        }\n      }\n\n      orderedLayers = orderedLayers.sort((a, b) => {\n        return a.options.order !== undefined && b.options.order !== undefined\n          ? a.options.order - b.options.order\n          : 0;\n      });\n\n      for (let fry = 0; fry < orderedLayers.length; fry++) {\n        const nextLayer = orderedLayers[fry + 1];\n        const nextLayerId = nextLayer && nextLayer.layer && nextLayer.layer[0];\n        const mem = orderedLayers[fry];\n        const _layers = this._getLayerIds(mem);\n        _layers.forEach(x => {\n          _map.moveLayer(x, nextLayerId);\n        });\n      }\n      const firstRealLayer = orderedLayers.find(x => Array.isArray(x.layer));\n      if (firstRealLayer) {\n        const firstLayerId = this._getLayerIds(firstRealLayer)[0];\n        // normalize layer ordering\n        baseLayers.forEach(x => {\n          if (x.layer) {\n            x.layer.forEach(y => {\n              _map.moveLayer(y, firstLayerId);\n            });\n          }\n        });\n      }\n    }\n  }\n\n  private _getLayerIds(mem: TLayerAdapter): string[] {\n    let _layers: TLayer = [];\n    if (mem) {\n      if (Array.isArray(mem.layer)) {\n        _layers = mem.layer;\n      } else if (mem.getDependLayers) {\n        const dependLayers = mem.getDependLayers();\n        dependLayers.forEach(x => {\n          // @ts-ignore Update x interface\n          const layer: TLayer = (x.layer && x.layer.layer) || x;\n          if (Array.isArray(layer)) {\n            layer.forEach(y => {\n              _layers.push(y);\n            });\n          }\n        });\n      }\n    }\n    return _layers;\n  }\n\n  private _toggleLayer(layerId: string, status: boolean): void {\n    this._onMapLoad().then(_map => {\n      _map.setLayoutProperty(\n        layerId,\n        'visibility',\n        status ? 'visible' : 'none'\n      );\n    });\n  }\n\n  private _onMapSourceData(data: mapboxgl.MapSourceDataEvent & EventData) {\n    if (data.dataType === 'source') {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-loaded', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onMapError(\n    data: mapboxgl.ErrorEvent & mapboxgl.MapSourceDataEvent & EventData\n  ) {\n    if (this._sourceDataLoading[data.sourceId]) {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-error', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onDataLoad(\n    data: { sourceId: string; tile: any },\n    isLoaded = false,\n    emit: (sourceId: string) => void\n  ) {\n    // if all sources is loaded emmit event for all and clean mem\n    if (isLoaded) {\n      Object.keys(this._sourceDataLoading).forEach(x => {\n        emit(x);\n      });\n      this._sourceDataLoading = {};\n    } else {\n      // check if all tiles in layer is loaded\n      const tiles = this._sourceDataLoading[data.sourceId];\n      if (tiles && data.tile) {\n        const index = tiles.indexOf(data.tile);\n        if (index !== -1) {\n          this._sourceDataLoading[data.sourceId].splice(index, 1);\n        }\n        // if no more loaded tiles in layer emit event and clean mem only for this layer\n        if (!tiles.length) {\n          emit(data.sourceId);\n          delete this._sourceDataLoading[data.sourceId];\n        }\n      }\n    }\n  }\n\n  private _transformRequest(\n    url: string,\n    resourceType: ResourceType\n  ): RequestParameters | undefined {\n    // @ts-ignore\n    const transformRequests = this.map.transformRequests;\n    for (const r of transformRequests) {\n      const params = r(url, resourceType) as RequestParameters;\n      if (params) {\n        return params;\n      }\n    }\n    return undefined;\n  }\n\n  private _addEventsListeners(): void {\n    const _map = this.map;\n    if (_map) {\n      // write mem for start loaded layers\n      _map.on('sourcedataloading', data => {\n        this._sourceDataLoading[data.sourceId] =\n          this._sourceDataLoading[data.sourceId] || [];\n        if (data.tile) {\n          this._sourceDataLoading[data.sourceId].push(data.tile);\n        }\n      });\n      // emmit data-loaded for each layer or all sources is loaded\n      _map.on('sourcedata', this._onMapSourceData.bind(this));\n      _map.on('error', this._onMapError.bind(this));\n      _map.on('click', evt => {\n        this.onMapClick(evt);\n      });\n\n      this._universalEvents.forEach(e => {\n        _map.on(e, () => this.emitter.emit(e, this));\n      });\n    }\n  }\n}\n","import { ButtonControlOptions } from '@nextgis/webmap';\nimport { createControl } from './createControl';\n\nexport function createButtonControl(options: ButtonControlOptions) {\n  const link = document.createElement('button');\n  link.className = 'mapboxgl-ctrl-icon';\n\n  link.setAttribute('role', 'button');\n  if (options.title) {\n    link.title = options.title;\n    link.setAttribute('aria-label', options.title);\n  }\n\n  if (options.html) {\n    if (options.html instanceof HTMLElement) {\n      link.appendChild(options.html);\n    } else {\n      link.innerHTML = options.html;\n    }\n    const child = link.firstElementChild as HTMLElement;\n    if (child) {\n      child.style.width = '100%';\n      child.style.height = '100%';\n      child.style.lineHeight = (link.offsetHeight || 30) + 'px';\n    }\n  }\n  if (options.addClass) {\n    options.addClass.split(' ').forEach(x => link.classList.add(x));\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n  if (options.onClick !== undefined) {\n    link.addEventListener('click', onClick);\n  }\n\n  return createControl(\n    {\n      onAdd() {\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      }\n    },\n    { bar: true, addClass: 'mapboxgl-ctrl-group' }\n  );\n}\n","/**\n * @module mapboxgl-map-adapter\n */\n\nimport { MapboxglMapAdapter } from './MapboxglMapAdapter';\nexport * from './MapboxglMapAdapter';\nexport default MapboxglMapAdapter;\n","import WebMap from '@nextgis/webmap';\nimport { NgwMapEvents } from './interfaces';\n\n/**\n * Decorator to run action only after map is created\n */\nexport function onMapLoad() {\n  return WebMap.decorators.onLoad<NgwMapEvents>('build-map');\n}\n","import { NgwResourceDefinition, NgwLayerOptions } from './interfaces';\nimport { NgwLayerOptionsAdditional } from '@nextgis/ngw-kit';\n\nimport { deepmerge } from '@nextgis/utils';\nimport { MapAdapter, StarterKit } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport QmsKit from '@nextgis/qms-kit';\nimport NgwKit from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from './interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: NgwLayerOptionsAdditional,\n  overwriteOptions?: NgwLayerOptionsAdditional\n) {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resourceId: resource\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({ ...defOptions, resourceId, id, ...overwriteOptions });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"http://nextgis.ru\" target=\"_blank\">©NextGIS</a>'\n      ]\n    }\n  },\n  pixelRadius: 10\n};\n\nexport function prepareWebMapOptions(\n  mapAdapter: MapAdapter,\n  options: NgwMapOptions\n) {\n  const kits: StarterKit[] = [new QmsKit()];\n\n  if (!options.connector && options.baseUrl) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl,\n      auth: options.auth\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  const opt: NgwMapOptions = deepmerge(OPTIONS, options);\n  if (opt.connector) {\n    kits.push(\n      new NgwKit({\n        connector: opt.connector,\n        auth: opt.auth,\n        identification: opt.identification\n      })\n    );\n  }\n  return {\n    mapAdapter,\n    starterKits: kits,\n    runtimeParams: options.runtimeParams\n  };\n}\n","/**\n * @module ngw-map\n */\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport { fixUrlStr, deepmerge } from '@nextgis/utils';\nimport WebMap, {\n  MapAdapter,\n  ControlPositions,\n  MapControls,\n  WebMapEvents,\n  LayerDef,\n  MapClickEvent,\n  LayerAdapter,\n  PropertiesFilter,\n  FilterOptions,\n  OnLayerClickOptions\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  ResourceItem,\n  CancelablePromise,\n  FeatureLayersIdentify,\n  FeatureItem,\n  FeatureLayersIdentifyItems,\n  LayerFeature\n} from '@nextgis/ngw-connector';\nimport { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport NgwKit, {\n  NgwLayerOptions,\n  ResourceAdapter,\n  WebMapLayerItem,\n  AddNgwLayerOptions,\n  NgwLayerOptionsAdditional,\n  NgwIdentify\n} from '@nextgis/ngw-kit';\nimport { getIcon } from '@nextgis/icons';\n\nimport { onMapLoad } from './decorators';\nimport { appendNgwResources, prepareWebMapOptions, OPTIONS } from './utils';\n\nimport {\n  NgwMapOptions,\n  ControlOptions,\n  NgwMapEvents,\n  NgwLayers\n} from './interfaces';\nimport { Geometry, Feature, FeatureCollection } from 'geojson';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import NgwMap from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap(new MapAdapter(), {\n *   target: 'map',\n *   qmsId: 487,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<M = any, L = any, C = any, O = {}> extends WebMap<\n  M,\n  L,\n  C,\n  NgwMapEvents\n> {\n  static utils = {\n    ...WebMap.utils,\n    ...NgwKit.utils,\n    fixUrlStr,\n    deepmerge\n  };\n  static decorators = { onMapLoad, ...WebMap.decorators };\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwMapEvents\n  > = new EventEmitter();\n\n  options: NgwMapOptions<C> & O = {} as NgwMapOptions<C> & O;\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private __selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private __selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n\n  /**\n   * @param mapAdapter #noapi\n   * @param options\n   */\n  constructor(mapAdapter: MapAdapter, options: NgwMapOptions<C> & O) {\n    super(prepareWebMapOptions(mapAdapter, options));\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this.options = deepmerge(OPTIONS, options);\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      this._addControls();\n    });\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit() {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param [options] - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  @WebMap.decorators.onLoad<NgwMapEvents>('controls:create')\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPositions,\n    options?: MapControls[K]\n  ) {\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource id.\n   * @param options - set layer identification parameters and render method.\n   * @param [adapterOptions] - parameters for the selected adapter\n   *\n   * @example\n   * ```javascript\n   * var ngwMap = new NgwMap({ baseUrl: 'https://demo.nextgis.com', target: 'map' });\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resourceId: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resourceId: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  @onMapLoad()\n  async addNgwLayer(\n    options: AddNgwLayerOptions\n  ): Promise<ResourceAdapter | undefined> {\n    if (!options.resourceId && !options.keyname) {\n      throw new Error(\n        'resourceId or keyname is required parameter to add NGW layer'\n      );\n    }\n    if (this.options.baseUrl || this.options.baseUrl === '') {\n      try {\n        const adapter = NgwKit.utils.addNgwLayer(\n          options,\n          this,\n          this.options.baseUrl,\n          this.connector\n        );\n\n        const layer = (await this.addLayer(adapter, {\n          visibility: true,\n          // TODO: all options into one object\n          ...options,\n          ...options.adapterOptions\n        })) as ResourceAdapter;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n\n          if (layer.options.baseLayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n\n        return layer;\n      } catch (er) {\n        console.error(\"can't add ngw layer\", er);\n      }\n    }\n  }\n\n  async getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return NgwKit.utils.getNgwLayerItem({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureItem[]> {\n    return NgwKit.utils.getNgwLayerItems({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeature<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return NgwKit.utils.getNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return NgwKit.utils.getNgwLayerFeatures({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false\n  ): CancelablePromise<Feature | undefined> {\n    return NgwKit.utils.getIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple\n    });\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some(x => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as WebMapLayerItem[];\n        const dependFit = dependLayers.find(x => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   * @param layerDef\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.zoomToLayer(ngwLayer);\n   * ngwMap.zoomToLayer('ngw_layer_name');\n   * ```\n   */\n  async zoomToLayer(layerDef: string | ResourceAdapter) {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent);\n        }\n      } else {\n        let item: ResourceItem;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.get('resource.item', null, {\n            id: resourceId\n          });\n        }\n\n        NgwKit.utils.getNgwResourceExtent(item, this.connector).then(extent => {\n          if (extent) {\n            this.fitBounds(extent);\n          }\n        });\n      }\n    }\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection() {\n    if (!this.__selectFromNgwRaster) {\n      this.__selectFromNgwRaster = (ev: MapClickEvent) =>\n        this._selectFromNgwRaster(ev);\n      this.__selectFromNgwVector = (ev: OnLayerClickOptions) =>\n        this._selectFromNgwVector(ev);\n      this.emitter.on('click', this.__selectFromNgwRaster);\n      this.emitter.on('layer:click', this.__selectFromNgwVector);\n    }\n  }\n\n  disableSelection() {\n    if (this.__selectFromNgwRaster) {\n      this.emitter.off('click', this.__selectFromNgwRaster);\n      this.emitter.off('click', this._selectFromNgwVector);\n      this.__selectFromNgwRaster = undefined;\n      this.__selectFromNgwVector = undefined;\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create({ ...this.options });\n    if (this.options.qmsId) {\n      let qmsId: number;\n      let qmsLayerName: string | undefined;\n      if (Array.isArray(this.options.qmsId)) {\n        qmsId = this.options.qmsId[0];\n        qmsLayerName = this.options.qmsId[1];\n      } else {\n        qmsId = Number(this.options.qmsId);\n      }\n      const qmsLayerOptions: QmsAdapterOptions = {\n        qmsId\n      };\n      if (qmsLayerName) {\n        qmsLayerOptions.id = qmsLayerName;\n      }\n\n      await this.addBaseLayer('QMS', qmsLayerOptions).then(layer => {\n        this.showLayer(layer);\n      });\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach(x => {\n        const overwriteOptions = {} as NgwLayerOptionsAdditional;\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n\n    for (const r of resources) {\n      await this.addNgwLayer(r);\n    }\n\n    this._emitStatusEvent('ngw-map:create', this);\n\n    this.enableSelection();\n  }\n\n  private _addControls() {\n    if (this.options.controls) {\n      this.options.controls.forEach(x => {\n        let controlAdapterName = x;\n        let controlOptions: ControlOptions = {};\n        if (typeof x === 'string' && this.options.controlsOptions) {\n          if (this.options.controlsOptions[x]) {\n            controlOptions = this.options.controlsOptions[x];\n            if (controlOptions.control !== undefined) {\n              controlAdapterName = controlOptions.control;\n            }\n          }\n        }\n        const { position, ...options } = controlOptions;\n        this.addControl(controlAdapterName, position || 'top-left', options);\n      });\n    }\n    this._emitStatusEvent('controls:create');\n  }\n\n  private async _selectFromNgwVector(\n    ev: OnLayerClickOptions\n  ): Promise<FeatureLayersIdentify | undefined> {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties,\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature]\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items\n        };\n        this._emitStatusEvent('ngw:select', {\n          ...identify,\n          resources: [id],\n          sourceType: 'vector'\n        });\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    for (const nl in this._ngwLayers) {\n      const layer = this._ngwLayers[nl].layer;\n      if (layer.getIdentificationIds && layer.options.selectable) {\n        promises.push(layer.getIdentificationIds());\n      }\n    }\n    const getIds = await Promise.all(promises);\n    const ids: number[] = [];\n    getIds.forEach(x => {\n      if (x) {\n        x.forEach(y => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    const zoom = this.getZoom();\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const metresPerPixel =\n      (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n      Math.pow(2, zoom + 8);\n    // FIXME: understand the circle creation function\n    const radius = pixelRadius * metresPerPixel * 0.0005;\n    return NgwKit.utils\n      .sendIdentifyRequest(ev, {\n        layers: ids,\n        connector: this.connector,\n        radius\n      })\n      .then(resp => {\n        this._emitStatusEvent('ngw:select', {\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev\n        });\n        return resp;\n      });\n  }\n}\n","/**\n * @module ngw-map\n */\n\nimport { NgwMap } from './NgwMap';\n\nexport * from '@nextgis/webmap';\nexport * from './interfaces';\n\nexport { NgwMap };\nexport default NgwMap;\n","/**\n * @module ngw-connector\n */\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nexport class CancelablePromise<T> implements Promise<T> {\n  readonly [Symbol.toStringTag]: string;\n\n  private _canceled = false;\n\n  private _promise?: Promise<T>;\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void\n    ) => void,\n    private onCancel?: (...args: any[]) => void\n  ) {\n    this._promise = new Promise(executor);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise(resolve => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values)\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise(\n      (resolve, reject) => {\n        if (this._promise) {\n          this._promise.then(\n            r => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onfulfilled && !this._canceled) {\n                handleCallback(resolve, reject, onfulfilled, r);\n              } else {\n                resolve(r);\n              }\n            },\n            r => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onrejected && !this._canceled) {\n                handleCallback(resolve, reject, onrejected, r);\n              } else {\n                reject(r);\n              }\n            }\n          );\n        }\n      },\n      () => {\n        this.cancel();\n      }\n    );\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null\n  ): CancelablePromise<T | TResult> {\n    return this.then(undefined, onrejected);\n  }\n\n  cancel(errorCallback?: (...args: any[]) => void) {\n    this._canceled = true;\n    if (errorCallback && this._promise) {\n      this._promise.catch(errorCallback);\n    }\n    if (this.onCancel) {\n      this.onCancel();\n    }\n    this._destroy();\n    return this;\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  private _destroy() {\n    this.onCancel = undefined;\n    this._promise = undefined;\n  }\n}\n","// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\nimport { RequestOptions } from './interfaces';\n\nexport function loadJSON(\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions = {},\n  error: (reason?: any) => void,\n  onCancel: Array<() => void>\n) {\n  options.method = options.method || 'GET';\n\n  const xhr = new XMLHttpRequest();\n  xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n  if (options.responseType === 'blob') {\n    xhr.responseType = options.responseType;\n  }\n\n  const processingResponce = (forError = false) => {\n    const cb = forError ? error : callback;\n    if (options.responseType === 'blob') {\n      cb(xhr.response);\n    } else {\n      if (xhr.responseText) {\n        try {\n          cb(JSON.parse(xhr.responseText));\n        } catch (er) {\n          cb(xhr.responseText);\n        }\n      } else {\n        error({ message: '' });\n      }\n    }\n  };\n\n  xhr.onreadystatechange = () => {\n    if (\n      (xhr.readyState === 4 && xhr.status === 200) ||\n      (xhr.readyState === 3 && xhr.status === 201)\n    ) {\n      processingResponce();\n    } else if (xhr.readyState === 3 && xhr.status === 400) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 500) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 401) {\n      error(xhr.statusText);\n    } else if (xhr.readyState === 4) {\n      error('request error');\n    }\n  };\n\n  xhr.onerror = er => {\n    error(er);\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      const percentComplete = (e.loaded / e.total) * 100;\n      if (options.onProgress) {\n        options.onProgress(percentComplete);\n      }\n      // console.log(percentComplete + '% uploaded');\n    }\n  };\n\n  const headers = options.headers;\n  if (headers) {\n    for (const h in headers) {\n      const header = headers[h];\n      if (typeof header === 'string') {\n        xhr.setRequestHeader(h, header);\n      }\n    }\n  }\n  if (options.withCredentials !== undefined) {\n    xhr.withCredentials = options.withCredentials;\n  }\n\n  let data: FormData | any;\n  if (options.file) {\n    data = new FormData();\n    data.append('file', options.file);\n    if (options.data) {\n      for (const d in data) {\n        data.append(d, data[d]);\n      }\n    }\n  } else {\n    data = options.data\n      ? typeof options.data === 'string'\n        ? options.data\n        : JSON.stringify(options.data)\n      : null;\n  }\n  if (onCancel) {\n    onCancel.push(() => {\n      xhr.abort();\n    });\n  }\n  xhr.send(data);\n}\n\n// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }) {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","/**\n * @module ngw-connector\n */\nimport { CancelablePromise } from './CancelablePromise';\n\nimport { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport {\n  NgwConnectorOptions,\n  Router,\n  GetRequestItemsResponseMap,\n  RequestOptions,\n  Params,\n  LoadingQueue,\n  UserInfo,\n  Credentials,\n  PyramidRoute,\n  RequestHeaders,\n  PostRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  RequestItemKeys,\n  DeleteRequestItemsResponseMap,\n  PutRequestItemsResponseMap\n} from './interfaces';\nimport { loadJSON, template } from './utils';\nimport { EventEmitter } from 'events';\nimport { ResourceItem } from './types/ResourceItem';\n\nexport class NgwConnector {\n  emitter = new EventEmitter();\n  user?: UserInfo;\n  private routeStr = '/api/component/pyramid/route';\n  private route?: PyramidRoute;\n  private _loadingQueue: { [name: string]: LoadingQueue } = {};\n  private _loadingStatus: { [url: string]: boolean } = {};\n  private _keynames: Record<string, ResourceItem> = {};\n\n  constructor(public options: NgwConnectorOptions) {\n    if (this.options.route) {\n      this.routeStr = this.options.route;\n    }\n  }\n\n  setNextGisWeb(url: string) {\n    this.logout();\n    this.options.baseUrl = url;\n  }\n\n  async connect(): CancelablePromise<Router> {\n    if (this.route) {\n      return Promise.resolve(this.route);\n    } else {\n      if (this.options.auth) {\n        const { login, password } = this.options.auth;\n        if (login && password) {\n          await this.getUserInfo({ login, password });\n        }\n      }\n\n      return await this.makeQuery(this.routeStr, {}, {}).then(\n        (route: PyramidRoute) => {\n          this.route = route;\n          return route;\n        }\n      );\n    }\n  }\n\n  async login(credentials: Credentials) {\n    this.logout();\n    return this.getUserInfo(credentials);\n  }\n\n  logout() {\n    this._rejectLoadingQueue();\n    this._loadingStatus = {};\n    this.options.auth = undefined;\n    this.route = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n  }\n\n  getUserInfo(credentials: Credentials): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials)\n      // withCredentials: true\n    };\n\n    // Do not use request('auth.current_user') to avoid circular-references\n    return this.makeQuery('/api/component/auth/current_user', {}, options)\n      .then((data: UserInfo) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch(er => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  getAuthorizationHeaders(\n    credentials?: Credentials\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials) {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      return window.btoa(unescape(encodeURIComponent(`${login}:${password}`)));\n    }\n  }\n\n  async getResourceByKeyname(keyname: string) {\n    let resource: ResourceItem = this._keynames['keyname'];\n    if (!resource) {\n      const resources = await this.get('resource.search', null, { keyname });\n      resource = resources[0];\n      if (resource) {\n        this._keynames[keyname] = resource;\n      }\n    }\n    return resource;\n  }\n\n  async getResourceChildren(opt: {\n    keyname?: string;\n    resourceId?: number;\n  }): Promise<ResourceItem[]> {\n    let parent = opt.resourceId;\n    if (!opt.keyname && !opt.resourceId) {\n      throw new Error('No keyname or resourceId is set');\n    }\n    if (opt.keyname) {\n      const item = await this.getResourceByKeyname(opt.keyname);\n      parent = item.resource.id;\n    }\n    return await this.get('resource.collection', null, {\n      parent\n    });\n  }\n\n  async request<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys\n  >(\n    name: K,\n    params: (RequestItemsParamsMap[K] | {}) & { [name: string]: any } = {},\n    options?: RequestOptions\n  ): CancelablePromise<P[K]> {\n    const apiItems = await this.connect();\n    let apiItem = apiItems && apiItems[name];\n    if (apiItem) {\n      apiItem = [...apiItem];\n      let url = apiItem.shift();\n      if (apiItem.length) {\n        const replaceParams: {\n          [num: number]: string;\n        } = {};\n        for (let fry = 0; fry < apiItem.length; fry++) {\n          const arg = apiItem[fry];\n          replaceParams[fry] = '{' + arg + '}';\n          if (params[arg] === undefined) {\n            throw new Error(\n              '`' + arg + '`' + ' url api argument is not specified'\n            );\n          }\n        }\n        if (url) {\n          url = template(url, replaceParams);\n        }\n      }\n      // Transfer part of the parameters from `params` to the URL string\n      if (params) {\n        const paramArray = [];\n        for (const p in params) {\n          if (apiItem.indexOf(p) === -1) {\n            paramArray.push(`${p}=${params[p]}`);\n          }\n        }\n        if (paramArray.length) {\n          url = url + '?' + paramArray.join('&');\n        }\n      }\n      if (url) {\n        return this.makeQuery(url, params, options);\n      } else {\n        throw new Error('request url is not set');\n      }\n    }\n    return CancelablePromise.resolve({} as P[K]);\n  }\n\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    options.nocache = true;\n    return this.request<K, PostRequestItemsResponseMap>(name, params, options);\n  }\n\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    options.nocache = true;\n    return this.request<K, GetRequestItemsResponseMap>(name, params, options);\n  }\n\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    options.nocache = true;\n    return this.request<K, PatchRequestItemsResponseMap>(name, params, options);\n  }\n\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    options.nocache = true;\n    return this.request<K, PutRequestItemsResponseMap>(name, params, options);\n  }\n\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    options.nocache = true;\n    return this.request<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options\n    );\n  }\n\n  makeQuery(\n    url: string,\n    params?: Params,\n    options: RequestOptions = {}\n  ): CancelablePromise<any> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      // remove double slash\n      url = url.replace(/([^:]\\/)\\/+/g, '$1');\n      if (!this._loadingStatus[url] || options.nocache) {\n        this._loadingStatus[url] = true;\n\n        return this._getJson(url, options)\n          .then(data => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, data);\n            return data;\n          })\n          .catch(er => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, er, true);\n            this.emitter.emit('error', er);\n            throw er;\n          });\n      } else {\n        this._loadingStatus[url] = false;\n        return new CancelablePromise((resolve, reject) => {\n          this._setLoadingQueue(url, resolve, reject);\n        });\n      }\n    } else {\n      throw new Error('No `url` parameter set for option ' + name);\n    }\n  }\n\n  _setLoadingQueue(\n    name: string,\n    resolve: (...args: any[]) => any,\n    reject: (...args: any[]) => any\n  ) {\n    this._loadingQueue[name] = this._loadingQueue[name] || {\n      name,\n      waiting: []\n    };\n    this._loadingQueue[name].waiting.push({\n      resolve,\n      reject,\n      timestamp: new Date()\n    });\n  }\n\n  _rejectLoadingQueue() {\n    for (const q in this._loadingQueue) {\n      const queue = this._loadingQueue[q];\n      queue.waiting.forEach(x => {\n        x.reject();\n      });\n      delete this._loadingQueue[q];\n    }\n  }\n\n  _executeLoadingQueue(name: string, data: any, isError?: boolean) {\n    const queue = this._loadingQueue[name];\n    if (queue) {\n      for (let fry = 0; fry < queue.waiting.length; fry++) {\n        const wait = queue.waiting[fry];\n        if (isError) {\n          if (wait.reject) {\n            wait.reject();\n          }\n        } else {\n          wait.resolve(data);\n        }\n      }\n      queue.waiting = [];\n    }\n  }\n\n  _getJson(url: string, options: RequestOptions): CancelablePromise<any> {\n    const onCancel: Array<() => void> = [];\n    options.responseType = options.responseType || 'json';\n    return new CancelablePromise(\n      (resolve, reject) => {\n        if (this.user) {\n          options = options || {};\n          // options.withCredentials = true;\n          options.headers = {\n            ...this.getAuthorizationHeaders(),\n            ...options.headers\n          };\n        }\n        loadJSON(url, resolve, options, reject, onCancel);\n      },\n      () => {\n        onCancel.forEach(x => x());\n      }\n    );\n  }\n}\n","/**\n * @module ngw-connector\n */\n\nimport { NgwConnector } from './NgwConnector';\n\nexport { CancelablePromise } from './CancelablePromise';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\nexport { NgwConnector };\nexport default NgwConnector;\n","import { Geometry, Feature, FeatureCollection } from 'geojson';\nimport { PropertiesFilter, FilterOptions } from '@nextgis/webmap';\nimport NgwConnector, {\n  CancelablePromise,\n  FeatureItem\n} from '@nextgis/ngw-connector';\n\nexport interface FeatureRequestParams {\n  srs?: number;\n  fields?: string;\n  geom_format?: string;\n  limit?: number;\n  intersects?: string;\n}\n\nconst FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson'\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry\n  };\n  return feature;\n}\n\nexport function getNgwLayerItem<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<FeatureItem> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  return options.connector.get('feature_layer.feature.item', null, {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params\n  });\n}\n\nexport function getNgwLayerFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<Feature<G, P>> {\n  return getNgwLayerItem(options).then(item => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n\nfunction idFilterWorkAround<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(options: { filterById: any; resourceId: number; connector: NgwConnector }) {\n  const value = options.filterById[2];\n  const featureIds: number[] =\n    typeof value === 'number'\n      ? [value]\n      : value.split(',').map((x: string) => Number(x));\n  if (options.filterById[1] !== 'eq' && options.filterById[1] !== 'in') {\n    throw new Error(\n      'Unable to filter by object id. Except `eq` or `in` operator'\n    );\n  }\n  const promises: Promise<FeatureItem>[] = featureIds.map(featureId => {\n    return getNgwLayerItem<G, P>({\n      connector: options.connector,\n      resourceId: options.resourceId,\n      featureId\n    });\n  });\n  return CancelablePromise.all(promises);\n}\n\nexport function getNgwLayerItems<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & FilterOptions\n): CancelablePromise<FeatureItem[]> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  const { connector, filters, limit, fields, intersects, resourceId } = options;\n  if (filters) {\n    const filterById = filters.find(x => x[0] === 'id');\n    if (filterById) {\n      return idFilterWorkAround({ filterById, connector, resourceId });\n    }\n    filters.forEach(([field, operation, value]) => {\n      params[`fld_${field}__${operation}`] = `${value}`;\n    });\n  }\n  if (limit) {\n    params.limit = limit;\n  }\n  if (fields) {\n    params.fields = fields.join();\n  }\n  if (intersects) {\n    params.intersects = intersects;\n  }\n  return connector.get('feature_layer.feature.collection', null, {\n    id: resourceId,\n    ...params\n  });\n}\n\nexport function getNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & FilterOptions\n): CancelablePromise<FeatureCollection<G, P>> {\n  return getNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach(y => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features\n    };\n    return featureCollection;\n  });\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, {\n  VectorLayerAdapter,\n  Type,\n  GeoJsonAdapterOptions,\n  PropertiesFilter,\n  FilterOptions\n} from '@nextgis/webmap';\nimport NgwConnector, { CancelablePromise } from '@nextgis/ngw-connector';\nimport { GeoJsonObject } from 'geojson';\nimport { getNgwLayerFeatures } from './utils/featureLayerUtils';\n\nexport async function createGeoJsonAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector\n) {\n  const adapter = webMap.mapAdapter.layerAdapters.GEOJSON as Type<\n    VectorLayerAdapter\n  >;\n\n  let _dataPromise: CancelablePromise<any> | undefined;\n  const _fullDataLoad = false;\n  let _lastFilterArgs:\n    | { filters?: PropertiesFilter; options?: FilterOptions }\n    | undefined;\n\n  const geoJsonAdapterCb = async (\n    filters?: PropertiesFilter,\n    opt?: FilterOptions\n  ) => {\n    _lastFilterArgs = { filters, options: opt };\n    _dataPromise = getNgwLayerFeatures({\n      resourceId: options.resourceId,\n      filters,\n      connector,\n      ...opt\n    });\n    return await _dataPromise;\n  };\n\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  const onLoad = (data: GeoJsonObject) => {\n    const geoJsonOptions: GeoJsonAdapterOptions = {\n      data\n    };\n    if (options.id) {\n      geoJsonOptions.id = options.id;\n    }\n    return WebMap.utils.updateGeoJsonAdapterOptions(geoJsonOptions);\n  };\n  return class Adapter extends adapter {\n    async addLayer(_opt: GeoJsonAdapterOptions) {\n      let data = {} as GeoJsonObject;\n      if (!_opt.data) {\n        data = await geoJsonAdapterCb(_opt.propertiesFilter, {\n          limit: _opt.limit\n        });\n      }\n      const opt = onLoad(data);\n      const addLayerOptions = { ..._opt, ...opt };\n      if (\n        addLayerOptions.data &&\n        Object.keys(addLayerOptions.data).length === 0\n      ) {\n        addLayerOptions.data = undefined;\n      }\n      return super.addLayer(addLayerOptions);\n    }\n\n    beforeRemove() {\n      abort();\n    }\n\n    async updateLayer() {\n      const { filters, options } = _lastFilterArgs || {};\n      const data = await geoJsonAdapterCb(filters, options);\n      if (this.setData) {\n        this.setData(data);\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter(e => {\n          if (e.feature && e.feature.properties) {\n            return WebMap.utils.propertiesFilter(e.feature.properties, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await geoJsonAdapterCb(filters, opt);\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(function() {\n          return true;\n        });\n      }\n    }\n  };\n}\n","import { NgwLayerOptions, ResourceAdapter } from './interfaces';\nimport WebMap, {\n  BaseLayerAdapter,\n  Type,\n  ImageAdapterOptions,\n  TileAdapterOptions\n} from '@nextgis/webmap';\nimport { getLayerAdapterOptions } from './utils/utils';\nimport { ResourceItem } from '@nextgis/ngw-connector';\n\nexport async function createRasterAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string\n): Promise<Type<BaseLayerAdapter> | undefined> {\n  let adapter = options.adapter || 'IMAGE';\n\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n  if (adapter === 'IMAGE' || adapter === 'TILE' || adapter === 'MVT') {\n    const adapterClass = webMap.mapAdapter.layerAdapters[adapter] as Type<\n      BaseLayerAdapter\n    >;\n\n    return class Adapter extends adapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem;\n      resourceId = options.resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = getLayerAdapterOptions(options, webMap, baseUrl);\n        if (opt) {\n          if (opt.resourceId) {\n            const layerAdapterOptions: ImageAdapterOptions = {\n              ...opt,\n              resourceId: opt.resourceId\n            };\n            this.options = { ...this.options, ...layerAdapterOptions };\n          } else {\n            const tileAdapterOptions: TileAdapterOptions = opt;\n            this.options = { ...this.options, ...tileAdapterOptions };\n          }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (id) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","/**\n * @module item\n */\nexport type SelfFilter<X extends any> = (x: X) => boolean;\nexport type RelationFunction<X extends any> = (x: X) => X | X[] | undefined;\n\nexport function filterIn<F extends any = any>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F) => !!x,\n  relationFunc: RelationFunction<F>,\n  _filtered: F[] = []\n): F[] {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      _filtered.push(item);\n    }\n    const relChild = relationFunc(item);\n    if (relChild) {\n      if (Array.isArray(relChild)) {\n        children = relChild;\n      } else {\n        children.push(relChild);\n      }\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      filterIn(children[fry], filterFunc, relationFunc, _filtered);\n    }\n  }\n\n  return _filtered;\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\nimport { filterIn } from './TreeUtil';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  // region Parents\n  setParent(parent: Item) {\n    this._parent = parent;\n  }\n\n  addChild(child: Item) {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return filterIn(parent, filterFunc, (x: I) => x.tree.getParent() as I);\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n  // endregion\n\n  // region Child\n  find(filterFunc?: (item: Item) => boolean) {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    })[0];\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return this._children as T[];\n  }\n}\n","/**\n * @module item\n */\nimport { Item } from '../Item';\nimport { ItemBasePropertyOptions } from '../interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\n// import StrictEventEmitter from 'strict-event-emitter-types/types/src';\n\n// export interface BasePropertyEvents<V, O> {\n//   'change': {value: V, options: O};\n//   'change-tree': {value: V, options: O, item: Item};\n// }\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>\n> {\n  options: O;\n\n  // emitter: StrictEventEmitter<EventEmitter, BasePropertyEvents<V, O>> = new EventEmitter();\n  emitter = EventEmitter && new EventEmitter();\n  name: string;\n\n  item: Item;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: Item, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty() {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent() {\n    return this.item.tree.getParent();\n  }\n\n  isGroup() {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked() {\n    if (this._blocked === undefined) {\n      const parents = this.item.tree.getParents();\n      if (parents) {\n        const isBlocked = parents.find((x: Item) => {\n          const parentProp = x.properties && x.properties.property(this.name);\n          if (parentProp) {\n            return !parentProp.get();\n          }\n          return false;\n        });\n        this._blocked = !!isBlocked;\n      } else {\n        this._blocked = false;\n      }\n    }\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O) {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O) {\n    this._callOnSet(value, options);\n  }\n\n  getContainer() {\n    return this._container;\n  }\n\n  destroy() {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O) {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O) {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach(x => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', { value, options, item: this.item });\n        }\n      });\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\nimport { ItemOptions } from './interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n  emitter = EventEmitter && new EventEmitter();\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties() {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","/**\n * @module item\n */\nimport { BaseProperty } from './BaseProperty';\nimport { Item } from '../Item';\n\nimport { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle'\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O) {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false })\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue() {\n    return (\n      this.get() &&\n      this.getParents().every(x => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  _prepareValue(value?: any): V | undefined {\n    return value;\n  }\n\n  _turnOff(options?: O) {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChilds(options);\n    }\n  }\n\n  _turnOn(options?: O) {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChilds(options);\n    }\n  }\n\n  block(options?: O) {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  _block(options?: O) {\n    this._turnOff(options);\n  }\n\n  unBlock(options?: O) {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  _unBlock(options?: O) {\n    this._turnOn(options);\n  }\n\n  blockChilds(options?: O) {\n    this.item.tree.getDescendants().forEach(x => this._blockChild(x, options));\n  }\n\n  unblockChilds(options?: O) {\n    this.item.tree.getChildren().forEach(x => this._unBlockChild(x, options));\n  }\n\n  _blockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  _unBlockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  _propagation(value?: V, options?: O) {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false\n            }\n          });\n        }\n      }\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { BaseProperty } from './BaseProperty';\nimport { CheckProperty } from './CheckProperty';\nimport { Item } from '../Item';\n\nimport {\n  ItemBasePropertyOptions,\n  Type,\n  ItemPropertyConfig,\n  ItemPropertyTypes\n} from '../interfaces';\n\nexport class ItemProperties {\n  static handlers: { [name: string]: Type<BaseProperty> } = {\n    CheckProperty\n  };\n\n  options = {};\n\n  private _properties: { [propName: string]: BaseProperty } = {};\n  private _propertiesList: string[];\n\n  constructor(\n    public item: Item,\n    propertiesList?: Array<ItemPropertyConfig<keyof ItemPropertyTypes>>\n  ) {\n    this._propertiesList = []; // ordered list\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    this._setPropertyHandler(propOpt);\n  }\n\n  _setPropertyHandler(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    const handlers = ItemProperties.handlers;\n    let handler = propOpt.handler;\n    if (!handler && propOpt.type) {\n      switch (propOpt.type) {\n        case 'boolean':\n          handler = handlers.CheckProperty;\n          break;\n        case 'string':\n          handler = handlers.BaseProperty;\n          break;\n        default:\n          handler = handlers.BaseProperty;\n      }\n    }\n    if (handler && propOpt.name) {\n      const options = { ...(propOpt || {}) };\n      this._properties[propOpt.name] = new handler(\n        propOpt.name,\n        this.item,\n        options\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  update() {\n    this.list().forEach(x => {\n      x.update();\n    });\n  }\n\n  get(name: string) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.get();\n    }\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>\n  ) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.set(value, options);\n    }\n  }\n\n  property(name: string) {\n    return this._properties[name];\n  }\n\n  list() {\n    return this._propertiesList.map(x => this._properties[x]);\n  }\n\n  destroy() {\n    for (const p in this._properties) {\n      const prop = this.property(p);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\n\nexport * from './interfaces';\nexport * from './properties/BaseProperty';\nexport * from './properties/CheckProperty';\nexport * from './properties/ItemProperties';\n\nexport { Item };\nexport default Item;\n","/**\n * @module ngw-kit\n */\n\nimport Item, { ItemOptions } from '@nextgis/item';\n\nimport WebMap, { LayerAdaptersOptions, LayerAdapter } from '@nextgis/webmap';\nimport { TreeGroup, TreeLayer } from './interfaces';\nimport { setScaleRatio } from './utils/utils';\n\nexport class WebMapLayerItem extends Item<ItemOptions> {\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: WebMapLayerItem) {\n          if (item) {\n            if (item.item.item_type === 'group') {\n              return true;\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            } else if (item.item.item_type === 'root') {\n              return true;\n            }\n          }\n          return false;\n        },\n        onSet(value: boolean, options?: any, item?: WebMapLayerItem) {\n          if (item && item.layer && item.item.item_type === 'layer') {\n            if (value) {\n              item.webMap.showLayer(item.layer);\n            } else {\n              item.webMap.hideLayer(item.layer);\n            }\n            item.item['layer_enabled'] = value;\n          }\n        }\n      }\n    ]\n  };\n\n  item: TreeGroup | TreeLayer;\n  layer?: LayerAdapter;\n\n  _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    parent?: WebMapLayerItem\n  ) {\n    super({ ...WebMapLayerItem.options, ...options });\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n\n    this.initProperties();\n    this._init(item);\n  }\n\n  async initItem(item: TreeGroup | TreeLayer) {\n    let newLayer = item._layer;\n    const i = item;\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        item.children.reverse().forEach(x => {\n          const children = new WebMapLayerItem(\n            this.webMap,\n            x,\n            this.options,\n            this\n          );\n          this.tree.addChild(children);\n        });\n      }\n    } else if (item.item_type === 'layer') {\n      const adapter = (item.adapter ||\n        item.layer_adapter.toUpperCase()) as keyof LayerAdaptersOptions;\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      const options: any = {\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n        ...item,\n        headers: this.options.headers\n      };\n      if (this.options.order && this.options.drawOrderEnabled) {\n        const subOrder = this._rootDescendantsCount - item.draw_order_position;\n        options.order = this.options.order + subOrder * 0.1;\n      }\n      newLayer = await this.webMap.addLayer(adapter, options);\n    }\n    if (newLayer) {\n      i._layer = newLayer;\n      this.layer = newLayer;\n      if (this.properties && item.item_type === 'layer' && item.layer_enabled) {\n        this.properties.property('visibility').set(true);\n      }\n      const transparency =\n        item.item_type === 'layer' && item.layer_transparency;\n      if (typeof transparency === 'number') {\n        const opacity = (100 - transparency) / 100;\n        this.webMap.setLayerOpacity(newLayer, opacity);\n      }\n    } else {\n      // this.properties.get('visibility').set(true);\n    }\n  }\n\n  bringToFront() {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      console.log(this.item);\n    }\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private async _init(item: TreeGroup | TreeLayer) {\n    await this.initItem(item);\n    this.emitter.emit('init');\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import WebMap, { LngLatBoundsArray, MapClickEvent } from '@nextgis/webmap';\nimport { ResourceItem, CancelablePromise } from '@nextgis/ngw-connector';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  getLayerAdapterOptions,\n  updateWmsParams,\n  sendIdentifyRequest,\n  getWebMapExtent\n} from './utils/utils';\nimport { WebMapLayerItem } from './WebMapLayerItem';\nimport { ItemOptions } from '@nextgis/item';\n\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport {\n  TreeGroup,\n  TreeLayer,\n  NgwLayerAdapterType,\n  WebMapAdapterOptions,\n  WebMapLayerAdapterEvents,\n  ResourceAdapter\n} from './interfaces';\n\nexport class WebMapLayerAdapter implements ResourceAdapter {\n  layer?: WebMapLayerItem;\n\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    WebMapLayerAdapterEvents\n  > = new EventEmitter();\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  private $$onMapClick?: (ev: MapClickEvent) => void;\n\n  constructor(public map: any, public options: WebMapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: WebMapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n\n    this.layer = await this._getWebMapLayerItem();\n\n    if (this.options.identification) {\n      const ids = await this._getWebMapIds();\n      if (ids) {\n        this._webmapLayersIds = ids;\n        this.$$onMapClick = (ev: MapClickEvent) => this._onMapClick(ev);\n        this.options.webMap.emitter.on('click', this.$$onMapClick);\n      }\n    }\n    return this.layer;\n  }\n\n  removeLayer() {\n    const mapAdapter = this.options.webMap.mapAdapter;\n    if (this.$$onMapClick) {\n      this.options.webMap.emitter.off('click', this.$$onMapClick);\n    }\n    this.getDependLayers().forEach(x => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    this.$$onMapClick = undefined;\n    delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getWebMapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<WebMapLayerItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  async getIdentificationIds() {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => a.id - b.id);\n      deps.forEach(x => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  private async _getWebMapLayerItem(): Promise<WebMapLayerItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<WebMapLayerItem>(resolve => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.order = this.options.order;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new WebMapLayerItem(\n            this.options.webMap,\n            webmap.root_item,\n            options\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    try {\n      const data = await this.options.connector.get('resource.item', null, {\n        id\n      });\n      this.response = data;\n      const webmap = data.webmap;\n      if (webmap) {\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    } catch (er) {\n      throw er;\n    }\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map(x =>\n            this._updateItemsParams(x, webMap, data)\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.baseUrl + '/api/component/render/image'\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = params => updateWmsParams(params, resourceId);\n        item = {\n          ...item,\n          ...getLayerAdapterOptions(\n            {\n              adapter: item.layer_adapter.toUpperCase() as NgwLayerAdapterType,\n              resourceId\n            },\n            webMap,\n            this.options.baseUrl\n          )\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: WebMapLayerItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector\n            .get('resource.item', {}, { id })\n            .then(y => {\n              if (y) {\n                const parentId = Number(y.resource.parent.id);\n                item.parentId = parentId;\n                return parentId;\n              }\n            });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter(x => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n\n  private _sendIdentifyRequest(ev: MapClickEvent) {\n    if (this._webmapLayersIds) {\n      return sendIdentifyRequest(ev, {\n        layers: this._webmapLayersIds,\n        connector: this.options.connector,\n        radius: this.pixelRadius\n      }).then(resp => {\n        this.emitter.emit('identify', { ev, data: resp });\n        return resp;\n      });\n    }\n  }\n\n  private _onMapClick(ev: MapClickEvent) {\n    this._sendIdentifyRequest(ev);\n  }\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { getNgwResourceExtent } from './utils/utils';\nimport { LngLatBoundsArray } from '@nextgis/webmap';\n\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  private _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await getNgwResourceExtent(\n        this.item,\n        this.connector\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem\n} from '@nextgis/ngw-connector';\nimport WebMap, { LayerAdapter, Type } from '@nextgis/webmap';\nimport QmsKit from '@nextgis/qms-kit';\nimport {\n  NgwLayerOptions,\n  ResourceAdapter,\n  AddNgwLayerOptions\n} from './interfaces';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createWebMapAdapter';\nimport { applyMixins } from './utils/utils';\nimport { NgwResource } from './NgwResource';\n\nconst styles: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'raster_style'\n];\n\nasync function createAdapterFromFirstStyle(\n  parent: number,\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n) {\n  const childrenStyles = await connector.get('resource.collection', null, {\n    parent\n  });\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...options, resourceId: firstStyle.resource.id },\n      webMap,\n      baseUrl,\n      connector\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: AddNgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: Promise<Type<LayerAdapter> | undefined> | undefined;\n  let item: ResourceItem | undefined;\n  try {\n    const adapterType = options.adapter;\n    let resourceId = options.resourceId;\n    if (!resourceId && options.keyname) {\n      const resourceItem = await connector.getResourceByKeyname(\n        options.keyname\n      );\n      resourceId = resourceItem.resource.id;\n    }\n    if (resourceId) {\n      item = await connector.get('resource.item', null, { id: resourceId });\n\n      if (item) {\n        const _options: NgwLayerOptions = { ...options, resourceId };\n        if (item.webmap) {\n          adapter = createWebMapAdapter(_options, webMap, baseUrl, connector);\n        } else if (styles.indexOf(item.resource.cls) !== -1) {\n          if (adapterType === 'GEOJSON') {\n            const parentOptions: NgwLayerOptions = {\n              ...options,\n              resourceId: item.resource.parent.id\n            };\n            adapter = createGeoJsonAdapter(parentOptions, webMap, connector);\n          } else {\n            adapter = createRasterAdapter(_options, webMap, baseUrl);\n          }\n        } else if (item.resource.cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(_options, webMap, baseUrl);\n            } else {\n              return createAdapterFromFirstStyle(\n                item.resource.id,\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            }\n          } else {\n            adapter = createGeoJsonAdapter(_options, webMap, connector);\n          }\n        } else if (item.resource.cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(\n            item.resource.id,\n            _options,\n            webMap,\n            baseUrl,\n            connector\n          );\n        } else if (item.basemap_layer && item.basemap_layer.qms) {\n          adapter = Promise.resolve(QmsKit.utils.createQmsAdapter(webMap));\n          adapter.then(x => {\n            if (x && item && item.basemap_layer && item.basemap_layer.qms) {\n              const qms = JSON.parse(item.basemap_layer.qms);\n              x.prototype.qms = qms;\n              x.prototype.baseLayer = true;\n            }\n          });\n        }\n      } else {\n        throw new Error(\n          \"Can't add NGW layer because Resource item is not found\"\n        );\n      }\n    }\n  } catch (er) {\n    // if (options.adapter === 'GEOJSON') {\n    //   adapter = createGeoJsonAdapter(options, webMap, connector);\n    // } else {\n    //   adapter = createRasterAdapter(options, webMap, baseUrl);\n    // }\n  }\n  if (adapter) {\n    return adapter.then(x => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        resourceAdapter.prototype.item = item;\n        resourceAdapter.prototype.connector = connector;\n\n        applyMixins(resourceAdapter, [NgwResource]);\n\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, { Type } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\n\nexport async function createWebMapAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<WebMapLayerAdapter>> {\n  return class Adapter extends WebMapLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        webMap,\n        resourceId: options.resourceId,\n        baseUrl,\n        connector\n      });\n    }\n  };\n}\n","import WebMap, {\n  Type,\n  LngLatBoundsArray,\n  MapClickEvent\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  WebmapResource,\n  ResourceItem,\n  FeatureLayersIdentify\n} from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../createAsyncAdapter';\nimport {\n  NgwLayerOptions,\n  WebMapAdapterOptions,\n  IdentifyRequestOptions,\n  ResourceAdapter,\n  AddNgwLayerOptions\n} from '../interfaces';\nimport { WebMapLayerAdapter } from '../WebMapLayerAdapter';\n\nexport function updateWmsParams(params: any, resourceId: number) {\n  const { bbox, width, height } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now()\n  };\n}\n\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string\n) {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n  if (adapter === 'IMAGE') {\n    if (isImageAllowed) {\n      url = baseUrl + '/api/component/render/image';\n      return {\n        url,\n        resourceId: options.resourceId,\n        headers: options.headers,\n        updateWmsParams: (params: any) =>\n          updateWmsParams(params, options.resourceId)\n      };\n    } else {\n      adapter = 'TILE';\n    }\n  }\n  if (adapter === 'MVT') {\n    url =\n      baseUrl +\n      '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n      'resource=' +\n      options.resourceId +\n      '&simplification=' +\n      (options.simplification || 0);\n    // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n    return {\n      url\n    };\n  }\n  if (adapter === 'TILE') {\n    url =\n      baseUrl +\n      '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n      options.resourceId;\n    return { url, adapter };\n  }\n}\n\nexport function addNgwLayer(\n  options: AddNgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, baseUrl, connector);\n}\n\nexport function getWebMapExtent(\n  webmap: WebmapResource\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function getNgwLayerExtent(\n  id: number,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  return connector.get('layer.extent', name, { id }).then(resp => {\n    if (resp) {\n      const { maxLat, maxLon, minLat, minLon } = resp.extent;\n      const extenrArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n      return extenrArray;\n    }\n  });\n}\n\nexport async function getNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return getWebMapExtent(item.webmap);\n  } else {\n    const resource = item.resource;\n    if (resource.cls.indexOf('style') !== -1) {\n      return connector\n        .get('resource.item', null, {\n          id: resource.parent.id\n        })\n        .then(res => {\n          return getNgwLayerExtent(res.resource.id, connector);\n        });\n    } else {\n      return getNgwLayerExtent(resource.id, connector);\n    }\n  }\n}\n\ninterface FeatureIdentifyRequestOptions {\n  /**\n   * WKT Polygon geometry\n   */\n  geom: string;\n  srs: 3857;\n  layers: number[];\n}\n\nconst d2r = Math.PI / 180; // degrees to radians\nconst r2d = 180 / Math.PI; // radians to degrees\nconst earthsradius = 3963; // 3963 is the radius of the earth in miles\n\nexport function getCirclePoly(\n  lng: number,\n  lat: number,\n  radius = 10,\n  points = 6\n) {\n  // find the radius in lat/lon\n  const rlat = (radius / earthsradius) * r2d;\n  const rlng = rlat / Math.cos(lat * d2r);\n\n  const extp = [];\n  for (let i = 0; i < points + 1; i++) {\n    // one extra here makes sure we connect the\n\n    const theta = Math.PI * (i / (points / 2));\n    const ex = lng + rlng * Math.cos(theta); // center a + radius x * cos(theta)\n    const ey = lat + rlat * Math.sin(theta); // center b + radius y * sin(theta)\n    extp.push([ex, ey]);\n  }\n\n  // add the circle to the map\n  return extp;\n}\n\nexport function degrees2meters(lng: number, lat: number): [number, number] {\n  const x = (lng * 20037508.34) / 180;\n  let y = Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);\n  y = (y * 20037508.34) / 180;\n  return [x, y];\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions\n  // webMap: WebMap\n): Promise<FeatureLayersIdentify> {\n  // webMap.emitter.emit('start-identify', { ev });\n  const geom = getCirclePoly(ev.latLng.lng, ev.latLng.lat, options.radius);\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  // webMap.addLayer('GEOJSON', {\n  //   visibility: true,\n  //   data: {\n  //     type: 'Feature',\n  //     geometry: {\n  //       type: 'Polygon',\n  //       coordinates: [geom]\n  //     }\n  //   }\n  // })\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\ninterface ExtendWebMapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendWebMapLayerAdapter(\n  opt: ExtendWebMapLayerAdapterOptions\n): Type<WebMapLayerAdapter> {\n  class A extends WebMapLayerAdapter {\n    constructor(map: any, options: WebMapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth() {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        baseCtor.prototype,\n        name\n      );\n      if (descriptor) {\n        Object.defineProperty(derivedCtor.prototype, name, descriptor);\n      }\n    });\n  });\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number) {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 104) {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n  if (lat) {\n    const centerLat = lat;\n    const crsScale =\n      (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n    const zoom = getZoomFromScale(crsScale);\n    return zoom;\n  }\n  return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import { LayerFeature } from '@nextgis/ngw-connector';\nimport { getNgwLayerFeature, createGeoJsonFeature } from './featureLayerUtils';\nimport { GetIdentifyGeoJsonOptions, NgwIdentify } from '../interfaces';\nimport { Geometry } from 'geojson';\n\nexport function getIdentifyGeoJsonParams(\n  identify: NgwIdentify,\n  multiple = false\n) {\n  let params: { resourceId: number; featureId: number } | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort(function(a, b) {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const layerFeatures = identify[l].features;\n    const resourceId = Number(l);\n    const f: LayerFeature | undefined = layerFeatures[0];\n    if (f) {\n      params = {\n        featureId: f.id,\n        resourceId\n      };\n      paramsList.push(params);\n      if (!multiple) {\n        break;\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function getIdentifyGeoJson(options: GetIdentifyGeoJsonOptions) {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      const withGeom = item.features.find(x => x.geom);\n\n      if (withGeom && withGeom.geom) {\n        const geom = withGeom.geom as Geometry;\n        return createGeoJsonFeature({\n          ...withGeom,\n          geom\n        });\n      }\n    }\n  }\n\n  const params = getIdentifyGeoJsonParams(identify);\n  if (params) {\n    return getNgwLayerFeature({ connector, ...params[0] });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport WebMap, { StarterKit, Type } from '@nextgis/webmap';\nimport {\n  getNgwResourceExtent,\n  sendIdentifyRequest,\n  pixelsInMeterWidth,\n  updateWmsParams,\n  getLayerAdapterOptions,\n  addNgwLayer,\n  extendWebMapLayerAdapter,\n  setScaleRatio\n} from './utils/utils';\n\nimport {\n  getIdentifyGeoJson,\n  getIdentifyGeoJsonParams\n} from './utils/identifyUtils';\n\nimport {\n  getNgwLayerItems,\n  getNgwLayerItem,\n  getNgwLayerFeatures,\n  getNgwLayerFeature,\n  createGeoJsonFeature\n} from './utils/featureLayerUtils';\n\nimport { NgwKitOptions, WebMapAdapterOptions } from './interfaces';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\n\nexport class NgwKit implements StarterKit {\n  static utils = {\n    addNgwLayer,\n    getNgwResourceExtent,\n    sendIdentifyRequest,\n    pixelsInMeterWidth,\n    getNgwLayerFeature,\n    getNgwLayerFeatures,\n    getNgwLayerItems,\n    getNgwLayerItem,\n    getIdentifyGeoJson,\n    getIdentifyGeoJsonParams,\n    createGeoJsonFeature,\n    setScaleRatio\n  };\n\n  static updateWmsParams = updateWmsParams;\n\n  static getLayerAdapterOptions = getLayerAdapterOptions;\n\n  static addNgwLayer = addNgwLayer;\n\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl;\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth\n      });\n    }\n  }\n\n  async onLoadSync(webMap: WebMap) {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: WebMapAdapterOptions = {\n            resourceId: r,\n            connector: this.connector,\n            baseUrl: this.url,\n            webMap\n          };\n          const layer = (await webMap.addLayer(WebMapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            identification: this.options.identification,\n            pixelRadius: this.options.pixelRadius,\n            ...options\n          })) as WebMapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap))\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<WebMapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendWebMapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl\n    });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport { NgwKit } from './NgwKit';\n\nexport * from './interfaces';\nexport * from './WebMapLayerAdapter';\nexport * from './WebMapLayerItem';\n\nexport { NgwKit };\nexport default NgwKit;\n","/**\n * @module utils\n */\nexport function create(\n  tagName: string,\n  className?: string,\n  container?: HTMLElement\n): HTMLElement {\n  const el = window.document.createElement(tagName);\n  if (className !== undefined) el.className = className;\n  if (container) container.appendChild(el);\n  return el;\n}\n","export class Clipboard {\n  constructor(text: string) {\n    if (text) {\n      this.copy(text);\n    }\n  }\n\n  static copy = (text: string) => {\n    return new Clipboard(text);\n  };\n\n  copy(text: string) {\n    try {\n      if ((navigator as any).clipboard) {\n        (navigator as any).clipboard.writeText(text);\n      } else if ((window as any).clipboardData) {\n        (window as any).clipboardData.setData('text', text);\n      } else {\n        this.copyToClipboard(text);\n      }\n      console.log('Copied to Clipboard');\n    } catch (e) {\n      console.log('Please copy coupon manually');\n    }\n  }\n\n  private copyToClipboard(text: string) {\n    const input = document.createElement('input') as HTMLInputElement;\n    input.value = text;\n    try {\n      document.body.appendChild(input);\n      this.copyNodeContentsToClipboard(input);\n    } finally {\n      document.body.removeChild(input);\n    }\n  }\n\n  private copyNodeContentsToClipboard(input: HTMLInputElement) {\n    input.select();\n    input.setSelectionRange(0, 99999); /*For mobile devices*/\n    document.execCommand('copy');\n  }\n}\n","import { EventEmitter } from 'events';\n\nexport class Events<E = any> {\n  private readonly _eventsStatus: { [key in keyof E]?: boolean } = {};\n\n  constructor(private emitter: EventEmitter) {}\n\n  setEventStatus(event: keyof E, status: boolean) {\n    this._eventsStatus[event] = status;\n  }\n\n  onLoad(event: keyof E | Array<keyof E>): Promise<this> {\n    const events: Array<keyof E> = Array.isArray(event) ? event : [event];\n    const promises = events.map(\n      x =>\n        new Promise(res => {\n          if (this.getEventStatus(x)) {\n            res(this);\n          } else {\n            const e = x as string | symbol;\n            this.emitter.once(e, () => {\n              this.setEventStatus(x, true);\n              res(this);\n            });\n          }\n        })\n    );\n    return Promise.all(promises).then(() => this);\n  }\n\n  getEventStatus(event: keyof E): boolean {\n    // ugly hack to disable type checking error\n    const _eventName = event as keyof E;\n    const status = this._eventsStatus[_eventName];\n    return status !== undefined ? !!status : false;\n  }\n}\n","/**\n * @module utils\n */\n\nimport * as Dom from './dom';\nexport const dom = Dom;\nexport * from './clipboard';\nexport * from './events';\n/**\n * Given an array of member function names as strings, replace all of them\n * with bound versions that will always refer to `context` as `this`. This\n * is useful for classes where otherwise event bindings would reassign\n * `this` to the evented object or some other value: this lets you ensure\n * the `this` value always.\n * Taken from: https://github.com/mapbox/mapbox-gl-js/blob/v1.0.0/src/util/util.js#L243\n */\nexport function bindAll(\n  fns: string[],\n  context: { [method: string]: (...args: any[]) => any }\n): void {\n  fns.forEach(fn => {\n    if (!context[fn]) {\n      return;\n    }\n    context[fn] = context[fn].bind(context);\n  });\n}\n\nexport function fixUrlStr(url: string): string {\n  // remove double slash\n  return url.replace(/([^:]\\/)\\/+/g, '$1');\n}\n\nexport function deepmerge(target: any, src: any, mergeArray = false): any {\n  const array = Array.isArray(src);\n  let dst: any = (array && []) || {};\n\n  if (array) {\n    if (mergeArray) {\n      target = target || [];\n      dst = dst.concat(target);\n      src.forEach(function(e: any, i: any) {\n        if (typeof dst[i] === 'undefined') {\n          dst[i] = e;\n        } else if (typeof e === 'object') {\n          dst[i] = deepmerge(target[i], e, mergeArray);\n        } else {\n          if (target.indexOf(e) === -1) {\n            dst.push(e);\n          }\n        }\n      });\n    } else {\n      // Replace array. Do not merge by default\n      dst = src;\n    }\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(function(key) {\n        dst[key] = target[key];\n      });\n    }\n    Object.keys(src).forEach(function(key) {\n      if (typeof src[key] !== 'object' || !src[key]) {\n        dst[key] = src[key];\n      } else {\n        if (typeof target[key] === 'object' && typeof src[key] === 'object') {\n          dst[key] = deepmerge(target[key], src[key], mergeArray);\n        } else {\n          dst[key] = src[key];\n        }\n      }\n    });\n  }\n  return dst;\n}\n"],"sourceRoot":""}