{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/dom/src/dom.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/image_icons.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/geom_type.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/VectorAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/MvtAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/TileAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/ZoomControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/CompassControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/AttributionControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/WmsAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/MapboxglMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createButtonControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/index.ts","webpack:///./nextgisweb_frontend/packages/icons/src/index.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeUtil.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeHelper.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/BaseProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/Item.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/CheckProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/ItemProperties.ts","webpack:///./nextgisweb_frontend/packages/item/src/index.ts","webpack:///./nextgisweb_frontend/packages/cancelable-promise/src/CancelablePromise.ts","webpack:///./nextgisweb_frontend/packages/cancelable-promise/src/index.ts"],"names":["create","tagName","className","container","el","window","document","createElement","appendChild","canvg","er","getImageData","img","opt","canvas","context","getContext","Error","setAttribute","String","width","height","HTMLImageElement","drawImage","Canvg","fromString","start","ID","map","options","this","_layerId","allowedByType","circle","line","fill","icon","concat","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","typeAliasForFilter","backAliases","a","layerType","backAlias","push","findMostFrequentGeomType","arr","counts","fry","length","maxName","c","maxCount","geometryFilter","geometry","type","backType","indexOf","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","like","ilike","reversOperations","PAINT","color","opacity","radius","selected","featureIdName","_types","_selectedFeatureIds","_sourceId","source","_selectionName","$onLayerClick","_onLayerClick","bind","addLayer","layer","types","paint","_onAddLayer","t","geomType","_detectPaintType","_getLayerNameFromType","geomFilter","undefined","_addLayer","_getNativeFilter","selectedPaint","selectionLayer","_getSelectionLayerNameFromType","selectedLayout","_addEventsListeners","propertiesFilter","filters","_filterProperties","_updatePropertiesFilter","removeFilter","_updateFilter","select","properties","_selectProperties","unselect","removeLayer","forEach","layerId","_updateWithNativeFilter","filter","nativeFilter","name","layout","minZoom","maxZoom","mType","layerOpt","id","visibility","_getAdditionalLayerOptions","minzoom","maxzoom","x","setFilter","sourceId","_updateLayerPaint","layerName","layers","selName","_paint","nativePaint","_createPaintForType","p","setLayoutProperty","setPaintProperty","mapboxPaint","html","_registerImage","allowed","allowedType","find","Array","isArray","paramName","duration","_getFeatureFilterId","feature","_featureFilterId","hasImage","iconSize","svgStr","Promise","resolve","Image","crossOrigin","src","btoa","onload","imageData","image","addImage","_selectFeature","_unselectFeature","selLayerName","selectProperties","filterProperties","propertyFilters","_convertToMapboxFilter","reverse","_operationsAliases","field","operation","value","operationAlias","isFeatureSelected","filterId","e","preventDefault","reduce","b","features_","queryRenderedFeatures","point","isSelected","unselectOnSecondClick","onLayerClick","falsePaint","selectable","on","getCanvas","style","cursor","BaseAdapter","MvtAdapter","sources","includes","url","addSource","tiles","sourceLayer","subdomains","split","replace","headers","transformRequests","resourceType","staticUrl","sourceOptions","tileSize","attribution","layerOptions","before","OPTIONS","Object","assign","TileAdapter","showCompass","_createButton","ariaLabel","fn","element","alias","label","title","showZoom","_features","_sources","data","addData","getSource","removeSource","clearLayer","cb","features","setData","detectedType","geojson","f","geometries","g","detectType","filterGeometries","fid","_filterFun","_filter","getLayers","filtered","_filteredFeatureIds","_getFeatures","visible","fun","getSelected","_getPaintFromCallback","selectedFeatureIds","multiselect","index","splice","selectionArray","filteredArray","filter_","_data","ok","newFeatures","geomCollection","toSave","createControl","control","getDefaultPosition","onAdd","content","classList","add","bar","addClass","_container","onRemove","parentNode","removeChild","remove","params","bbox","format","service","version","request","srs","transparent","paramsStr","keys","join","fitBoundsOptions","emitter","layerAdapters","MapboxglMapAdapter","controlAdapters","isLoaded","_universalEvents","_sourceDataLoading","__setLayerOrder","_setLayerOrder","reject","accessToken","target","mapOpt","attributionControl","bounds","fitOptions","transformRequest","transformed","_transformRequest","center","zoom","once","emit","destroy","getContainer","setView","jumpTo","setCenter","latLng","getCenter","lng","lat","setZoom","getZoom","getBounds","ar","toArray","fitBounds","fitBoundOptions","linear","setRotation","angle","showLayer","layerIds","_toggleLayer","hideLayer","_map","setLayerOrder","order","setLayerOpacity","_onMapLoad","then","getLayer","createButtonControl","link","HTMLElement","innerHTML","child","firstElementChild","lineHeight","offsetHeight","onClick","stopPropagation","addEventListener","parent","removeEventListener","addControl","position","removeControl","onMapClick","evt","lngLat","y","pixel","top","left","_resolve","baseLayers","orderedLayers","l","baseLayer","moveLayer","sort","mem","_getLayerIds","_layers","getDependLayers","status","_onMapSourceData","dataType","isSourceLoaded","_onDataLoad","_onMapError","tile","r","TILE","WMS","WmsAdapter","MVT","OSM","OsmAdapter","GEOJSON","ZOOM","ZoomControl","COMPASS","CompassControl","ATTRIBUTION","AttributionControl","svgPath","brill","rect","marker","cross","star","triangle","plus","minus","asterisk","getIcon","shape","strokeColor","size","anchor","stroke","scale","pathAlias","svg","s","DOMParser","parseFromString","documentElement","insertSvg","fistChild","firstChild","transform","iconAnchor","XMLSerializer","serializeToString","filterIn","item","filterFunc","relationFunc","_filtered","children","relChild","events","_children","setParent","_parent","addChild","getParent","getParents","tree","getRoot","toReturn","getChildren","all","getDescendants","EventEmitter","_blocked","_value","getProperty","call","isGroup","isBlocked","parents","parentProp","property","get","set","_prepareValue","update","_fireChangeEvent","getValue","_callOnSet","_removeEventsListener","onSet","prop","CheckProperty","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","getHierarchyValue","every","turnOff","hierarchy","blockChilds","turnOn","unblockChilds","block","_block","_unBlock","_blockChild","_unBlockChild","BaseProperty","propertiesList","_properties","_propertiesList","_setPropertyHandler","propOpt","handlers","ItemProperties","handler","list","initProperties","handleCallback","callback","executor","onCancel","_canceled","_promise","CancelablePromise","values","catch","onfulfilled","onrejected","cancel","errorCallback","_destroy","finally","onfinally"],"mappings":"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","file":"main~f075b844-3559708.js","sourcesContent":["/**\n * @module utils\n */\nexport function create<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  className?: string | null,\n  container?: HTMLElement\n): HTMLElementTagNameMap[K] {\n  const el = window.document.createElement(tagName);\n  if (className !== undefined && className !== null) {\n    el.className = className;\n  }\n  if (container) {\n    container.appendChild(el);\n  }\n  return el;\n}\n\nexport type ElementDef = HTMLElement | string;\n\n/**\n * Helper function for determining the HTML element through the transmitted parameters\n *\n * @example\n * ```javascript\n * let el = getElement(HTMLElement || 'element-id');\n * el = getElement('#element-id .sub-class');\n * el = getElement('.element-class');\n * ```\n */\nexport function getElement(el: HTMLElement | string): HTMLElement | undefined {\n  if (typeof el === 'string') {\n    let el_ = document.getElementById(el);\n    if (!el_) {\n      try {\n        el_ = document.querySelector(el);\n      } catch {\n        // ignore\n      }\n    }\n    return el_ || undefined;\n  }\n  return el;\n}\n\nexport function remove(element: ElementDef) {\n  const el = getElement(element);\n  if (el) {\n    const parent = el.parentElement;\n    if (parent) {\n      parent.removeChild(el);\n    }\n  }\n}\n","let canvg: any;\ntry {\n  canvg = require('canvg');\n} catch (er) {\n  // ignore\n}\ninterface GetImgOpt {\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  sdf?: string;\n  pixelRatio?: number;\n}\n\n// const defAddImgOpt = {\n//   width: 12,\n//   height: 12,\n//   x: 0,\n//   y: 0,\n//   sdf: undefined,\n//   pixelRatio: 2\n// };\n\n// // from /mapbox-gl/src/util/browser.js\nexport function getImageData(\n  img: string | HTMLImageElement,\n  opt: GetImgOpt\n): ImageData {\n  const canvas = window.document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('failed to create canvas 2d context');\n  }\n  canvas.setAttribute('width', String(opt.width));\n  canvas.setAttribute('height', String(opt.height));\n  if (!canvg && img instanceof HTMLImageElement) {\n    context.drawImage(img, 0, 0, opt.width, opt.height);\n  } else if (typeof img === 'string') {\n    if (canvg.Canvg) {\n      // for canvg v.3.x.x\n      const v = canvg.Canvg.fromString(context, img);\n      v.start();\n    } else {\n      // for canvg v.2.x.x\n      canvg(canvas, img);\n    }\n  }\n  return context.getImageData(0, 0, opt.width, opt.height);\n}\n\nexport function getImage(svgStr: string, opt: GetImgOpt): Promise<ImageData> {\n  return new Promise((resolve) => {\n    if (canvg) {\n      resolve(getImageData(svgStr, opt));\n    } else {\n      const svgImage = new Image();\n      svgImage.crossOrigin = 'Anonymous';\n      svgImage.src = 'data:image/svg+xml;base64,' + btoa(svgStr);\n\n      svgImage.onload = () => {\n        const imageData = getImageData(svgImage, opt);\n        resolve(imageData);\n      };\n    }\n  });\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map } from 'mapbox-gl';\nimport { BaseLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\nexport abstract class BaseAdapter<O extends AdapterOptions = AdapterOptions>\n  implements BaseLayerAdapter<Map, TLayer, O> {\n  layer?: TLayer;\n  protected readonly _layerId: string;\n\n  constructor(public map: Map, public options: O) {\n    this._layerId = `layer-${ID++}`;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  abstract addLayer(options: O): TLayer | Promise<TLayer> | undefined;\n}\n","import {\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  FeatureCollection,\n  Feature,\n  GeometryCollection,\n} from 'geojson';\nimport { VectorAdapterLayerType } from '@nextgis/webmap';\n\nexport const allowedParams: ([string, string] | string)[] = [\n  'color',\n  'opacity',\n];\nexport const allowedByType = {\n  circle: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity'],\n    ['strokeColor', 'stroke-color'],\n    ['strokeOpacity', 'stroke-opacity'],\n    ['weight', 'stroke-width'],\n    'radius',\n  ],\n  line: [\n    ['strokeColor', 'color'],\n    ['strokeOpacity', 'opacity'],\n    ['weight', 'width'],\n  ],\n  fill: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity'],\n  ],\n  icon: allowedParams.concat([]),\n};\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'circle',\n  LineString: 'line',\n  MultiPoint: 'circle',\n  Polygon: 'fill',\n  MultiLineString: 'line',\n  MultiPolygon: 'fill',\n  GeometryCollection: 'fill',\n};\n\nexport const typeAliasForFilter: {\n  [key in VectorAdapterLayerType]: GeoJsonGeometryTypes;\n} = {\n  circle: 'Point',\n  line: 'LineString',\n  fill: 'Polygon',\n  icon: 'Point',\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {\n  icon: ['Point'],\n};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[]\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      (f) => f.geometry.type\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      (g) => g.type\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n\n// Static functions\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType\n): boolean {\n  const backType = backAliases[type];\n  if (backType) {\n    return backType.indexOf(geometry) !== -1;\n  }\n  return false;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  VectorAdapterLayerType,\n  VectorLayerAdapter,\n  VectorAdapterOptions,\n  PropertiesFilter,\n  Operations,\n  DataLayerFilter,\n  PropertyFilter,\n  FilterOptions,\n} from '@nextgis/webmap';\n\nimport { Paint, IconOptions, isPaint, isIcon } from '@nextgis/paint';\n\nimport { checkIfPropertyFilter } from '@nextgis/properties-filter';\nimport {\n  Feature as F,\n  GeometryObject,\n  Geometry,\n  GeoJsonProperties,\n} from 'geojson';\nimport {\n  Map,\n  MapLayerMouseEvent,\n  AnySourceData,\n  AnyLayout,\n  Layer,\n  MapboxGeoJSONFeature,\n} from 'mapbox-gl';\n\nimport { getImage } from '../util/image_icons';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { BaseAdapter } from './BaseAdapter';\nimport { typeAliasForFilter, allowedByType } from '../util/geom_type';\n\nexport const operationsAliases: { [key in Operations]: string } = {\n  gt: '>',\n  lt: '<',\n  ge: '>=',\n  le: '<=',\n  eq: '==',\n  ne: '!=',\n  in: 'in',\n  notin: '!in',\n  // NOT SUPPORTED\n  like: '==',\n  // NOT SUPPORTED\n  ilike: '==',\n};\n\nconst reversOperations: { [key in Operations]: string } = {\n  gt: operationsAliases.le,\n  lt: operationsAliases.ge,\n  ge: operationsAliases.lt,\n  le: operationsAliases.gt,\n  eq: operationsAliases.ne,\n  ne: operationsAliases.eq,\n  in: operationsAliases.notin,\n  notin: operationsAliases.in,\n  like: operationsAliases.ne,\n  ilike: operationsAliases.ne,\n};\n\nexport interface Feature<\n  G extends GeometryObject | null = Geometry,\n  P = GeoJsonProperties\n> extends F<G, P> {\n  _featureFilterId?: string;\n}\n\nconst PAINT = {\n  color: 'blue',\n  opacity: 1,\n  radius: 10,\n};\n\ntype MapboxLayerType = 'fill' | 'line' | 'symbol' | 'circle';\n\nexport abstract class VectorAdapter<\n  O extends VectorAdapterOptions = VectorAdapterOptions\n> extends BaseAdapter<O>\n  implements VectorLayerAdapter<Map, TLayer, O, Feature> {\n  selected = false;\n\n  protected featureIdName = 'id';\n  protected _types: VectorAdapterLayerType[] = ['fill', 'circle', 'line'];\n  protected readonly _sourceId: string;\n  protected readonly _selectionName: string;\n  protected _selectedFeatureIds: (number | string)[] | false = [];\n\n  protected _selectProperties?: PropertiesFilter;\n  protected _filterProperties?: PropertiesFilter;\n\n  private $onLayerClick?: (e: MapLayerMouseEvent) => void;\n\n  constructor(public map: Map, public options: O) {\n    super(map, options);\n    this._sourceId = this.options.source\n      ? (this.options.source as string)\n      : `source-${this._layerId}`;\n\n    if (this.options.featureIdName) {\n      this.featureIdName = this.options.featureIdName;\n    } else if (this.options.source) {\n      this.featureIdName = '$id';\n    } else {\n      this.featureIdName = '_fid';\n    }\n\n    this._selectionName = this._layerId + '-highlighted';\n    this.$onLayerClick = this._onLayerClick.bind(this);\n  }\n\n  async addLayer(options: O): Promise<TLayer> {\n    options = this.options = { ...this.options, ...(options || {}) };\n\n    this.layer = [];\n    const types = (this._types = options.type ? [options.type] : this._types);\n    if (options.paint) {\n      this._onAddLayer(this._sourceId);\n      // const types = this._types;\n      for (const t of types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          let type = t;\n          if (t === 'circle') {\n            const paintType = this._detectPaintType(options.paint);\n            if (paintType === 'icon') {\n              type = 'icon';\n            }\n          }\n          const layer = this._getLayerNameFromType(t);\n          const geomFilter =\n            types.length > 1 ? ['==', '$type', geomType] : undefined;\n\n          await this._addLayer(layer, type, [\n            geomFilter,\n            this._getNativeFilter(),\n          ]);\n          this.layer.push(layer);\n          if (options.selectedPaint) {\n            const selectionLayer = this._getSelectionLayerNameFromType(t);\n            await this._addLayer(\n              selectionLayer,\n              type,\n              [geomFilter, ['in', this.featureIdName, '']],\n              this.options.selectedLayout\n            );\n            this.layer.push(selectionLayer);\n          }\n        }\n      }\n    }\n\n    this._addEventsListeners();\n\n    return this.layer;\n  }\n\n  propertiesFilter(filters: PropertiesFilter, options?: FilterOptions) {\n    this._filterProperties = filters;\n    this._updatePropertiesFilter();\n  }\n\n  removeFilter() {\n    this._filterProperties = undefined;\n    this._updateFilter();\n  }\n\n  select(properties?: DataLayerFilter<F, TLayer> | PropertiesFilter) {\n    if (typeof properties !== 'function') {\n      this._selectProperties = properties;\n      this._updateFilter();\n    }\n    this.selected = true;\n  }\n\n  unselect() {\n    this._selectProperties = undefined;\n    this._updateFilter();\n    this.selected = false;\n  }\n\n  removeLayer() {\n    const map = this.map;\n    if (this.layer) {\n      this.layer.forEach((layerId) => {\n        map.removeLayer(layerId);\n      });\n    }\n  }\n\n  protected _updateWithNativeFilter(filter: any[]) {\n    const nativeFilter = this._getNativeFilter();\n    if (nativeFilter.length) {\n      filter.push(nativeFilter);\n    }\n    return filter;\n  }\n\n  protected _getNativeFilter() {\n    return (this.options.nativeFilter\n      ? this.options.nativeFilter\n      : []) as PropertyFilter;\n  }\n\n  protected async _addLayer(\n    name: string,\n    type: VectorAdapterLayerType,\n    filter?: any[],\n    layout?: AnyLayout\n  ) {\n    const { minZoom, maxZoom } = this.options;\n    let mType: MapboxLayerType;\n    if (type === 'icon') {\n      mType = 'symbol';\n    } else {\n      mType = type;\n    }\n    layout = (layout || this.options.layout || {}) as AnyLayout;\n    const layerOpt: Layer = {\n      id: name,\n      type: mType,\n      source: this._sourceId,\n      layout: {\n        visibility: 'none',\n        ...layout,\n      },\n      ...this._getAdditionalLayerOptions(),\n    };\n    if (minZoom) {\n      layerOpt.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOpt.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(layerOpt);\n\n    const filters = ['all', ...(filter || [])].filter((x) => x);\n    if (filters.length > 1) {\n      this.map.setFilter(layerOpt.id, filters);\n    }\n  }\n\n  protected _onAddLayer(sourceId: string, options?: AnySourceData) {\n    // ignore\n  }\n\n  protected async _updateLayerPaint(type: VectorAdapterLayerType) {\n    const layerName = this._getLayerNameFromType(type);\n\n    if (this.options.paint) {\n      const layers: [string, Paint][] = [[layerName, this.options.paint]];\n      if (this.options.selectedPaint) {\n        const selName = this._getSelectionLayerNameFromType(type);\n        layers.push([selName, this.options.selectedPaint]);\n      }\n\n      for (const [name, paint] of layers) {\n        let _paint: any;\n        if (this.options.nativePaint) {\n          _paint =\n            typeof this.options.nativePaint === 'boolean'\n              ? paint\n              : this.options.nativePaint;\n        } else {\n          _paint = await this._createPaintForType(paint, type, name);\n        }\n\n        if ('icon-image' in _paint) {\n          // If true, the icon will be visible even if it collides with other previously drawn symbols.\n          _paint['icon-allow-overlap'] = true;\n          for (const p in _paint) {\n            this.map.setLayoutProperty(name, p, _paint[p]);\n          }\n        } else {\n          for (const p in _paint) {\n            this.map.setPaintProperty(name, p, _paint[p]);\n          }\n        }\n      }\n    }\n  }\n\n  protected _getLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._layerId;\n  }\n\n  protected _getSelectionLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._selectionName;\n  }\n\n  protected async _createPaintForType(\n    paint: Paint,\n    type: VectorAdapterLayerType,\n    name?: string\n  ): Promise<any> {\n    if (isPaint(paint)) {\n      const mapboxPaint: any = {};\n      const _paint = { ...PAINT, ...(paint || {}) };\n      if (paint.type === 'icon' && paint.html) {\n        await this._registerImage(paint);\n        return {\n          'icon-image': paint.html,\n        };\n      } else {\n        for (const p in _paint) {\n          const allowed = allowedByType[type];\n          if (allowed) {\n            const allowedType = allowed.find((x) => {\n              if (typeof x === 'string') {\n                return x === p;\n              } else if (Array.isArray(x)) {\n                return x[0] === p;\n              }\n              return false;\n            });\n            if (allowedType) {\n              const paramName = Array.isArray(allowedType)\n                ? allowedType[1]\n                : allowedType;\n              // @ts-ignore\n              mapboxPaint[type + '-' + paramName] = _paint[p];\n            }\n          }\n        }\n        mapboxPaint[type + '-opacity-transition'] = { duration: 0 };\n        return mapboxPaint;\n      }\n    }\n  }\n\n  protected _getFeatureFilterId(feature: Feature): string | number | undefined {\n    // @ts-ignore\n    const id = feature._featureFilterId;\n    if (id !== undefined) {\n      return id;\n    } else if (\n      feature.properties &&\n      feature.properties[this.featureIdName] !== undefined\n    ) {\n      return feature.properties[this.featureIdName];\n    }\n    return feature.id;\n  }\n\n  protected async _registerImage(paint: IconOptions) {\n    if (isIcon(paint) && paint.html) {\n      const imageExist = this.map.hasImage(paint.html);\n      if (!imageExist) {\n        let width = 12;\n        let height = 12;\n        if (paint.iconSize) {\n          width = paint.iconSize[0];\n          height = paint.iconSize[1];\n        }\n        const image = await getImage(paint.html, {\n          width,\n          height,\n        });\n\n        this.map.addImage(paint.html, image);\n      }\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _unselectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _getAdditionalLayerOptions() {\n    return {};\n  }\n\n  protected _updateFilter() {\n    this._updatePropertiesFilter();\n  }\n\n  protected _updatePropertiesFilter() {\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach((t) => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          const selectProperties = this._selectProperties;\n          const filterProperties = this._filterProperties;\n          const propertyFilters =\n            filterProperties && this._convertToMapboxFilter(filterProperties);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              let filters: any[] = [];\n              if (selectProperties || this._selectedFeatureIds) {\n                if (selectProperties) {\n                  filters = this._convertToMapboxFilter(selectProperties) || [];\n                } else if (this._selectedFeatureIds) {\n                  filters = [\n                    ['in', this.featureIdName, ...this._selectedFeatureIds],\n                  ];\n                }\n                if (propertyFilters) {\n                  propertyFilters.forEach((x) => filters.push(x));\n                }\n                this.map.setFilter(selLayerName, [\n                  'all',\n                  geomFilter,\n                  ...filters,\n                ]);\n              } else {\n                filters = ['in', '$id', ''];\n                this.map.setFilter(selLayerName, filters);\n              }\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filters_: any[] = ['all', geomFilter];\n            this._updateWithNativeFilter(filters_);\n            if (selectProperties) {\n              const selectFilters = this._convertToMapboxFilter(\n                selectProperties,\n                true\n              );\n              selectFilters.forEach((x) => filters_.push(x));\n            } else if (this._selectedFeatureIds) {\n              filters_.push([\n                '!in',\n                this.featureIdName,\n                ...this._selectedFeatureIds,\n              ]);\n            }\n            if (propertyFilters) {\n              propertyFilters.forEach((x) => filters_.push(x));\n            }\n            this.map.setFilter(layerName, filters_);\n          }\n        }\n      });\n    }\n  }\n\n  protected _convertToMapboxFilter(filters: PropertiesFilter, reverse = false) {\n    const _operationsAliases = reverse ? reversOperations : operationsAliases;\n    const filter = filters.map((x) => {\n      if (typeof x === 'string') {\n        return x;\n      } else if (checkIfPropertyFilter(x)) {\n        const [field, operation, value] = x;\n        const operationAlias = _operationsAliases[operation];\n        if (operation === 'in' || operation === 'notin') {\n          return [operationAlias, field, ...value];\n        }\n        return [operationAlias, field, value];\n      }\n    });\n    return filter;\n  }\n\n  protected isFeatureSelected(feature: Feature) {\n    if (this._selectedFeatureIds) {\n      const filterId = this._getFeatureFilterId(feature);\n      if (filterId) {\n        return this._selectedFeatureIds.indexOf(filterId) !== -1;\n      }\n    }\n    return false;\n  }\n\n  private _onLayerClick(e: MapLayerMouseEvent) {\n    e.preventDefault();\n    // const features = this.map.queryRenderedFeatures(e.point, {\n    //   layers: this.layer\n    // });\n    if (this.layer) {\n      const features = this.layer.reduce((a, b) => {\n        const features_ = this.map.queryRenderedFeatures(e.point, {\n          layers: [b],\n        });\n        const c = a.concat(features_);\n        return c;\n      }, [] as MapboxGeoJSONFeature[]);\n      const feature = features[0] as Feature;\n      if (feature) {\n        let isSelected = this.isFeatureSelected(feature);\n        if (isSelected) {\n          if (this.options && this.options.unselectOnSecondClick) {\n            this._unselectFeature(feature);\n          }\n        } else {\n          this._selectFeature(feature);\n        }\n        isSelected = this.isFeatureSelected(feature);\n        if (this.options.onLayerClick) {\n          this.options.onLayerClick({\n            layer: this,\n            feature,\n            selected: isSelected,\n          });\n        }\n      }\n    }\n  }\n\n  private _detectPaintType(paint: Paint): string | undefined {\n    if ('type' in paint) {\n      return paint.type;\n    } else if (typeof paint === 'function') {\n      try {\n        const falsePaint = paint({\n          type: 'Feature',\n          properties: {},\n          geometry: {} as Geometry,\n        });\n        return this._detectPaintType(falsePaint);\n      } catch (er) {\n        //\n      }\n    }\n  }\n\n  private _addEventsListeners() {\n    if (this.layer && this.options && this.options.selectable) {\n      this.layer.forEach((x) => {\n        if (this.$onLayerClick) {\n          const onLayerClick = this.$onLayerClick;\n          this.map.on('click', x, (e: MapLayerMouseEvent) => {\n            onLayerClick(e);\n          });\n        }\n\n        this.map.on('mousemove', x, () => {\n          this.map.getCanvas().style.cursor = 'pointer';\n        });\n        this.map.on('mouseleave', x, () => {\n          this.map.getCanvas().style.cursor = '';\n        });\n      });\n    }\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { MvtAdapterOptions } from '@nextgis/webmap';\nimport { VectorAdapter } from './VectorAdapter';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nexport class MvtAdapter extends VectorAdapter<MvtAdapterOptions> {\n  static sources: string[] = [];\n\n  source?: string;\n\n  async addLayer(options: MvtAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    this._updateLayerPaint(this.options.type || 'fill');\n\n    return layer;\n  }\n\n  protected _getAdditionalLayerOptions() {\n    const exist = MvtAdapter.sources.includes(this.options.url);\n    if (!exist) {\n      this.map.addSource(this.options.url, {\n        type: 'vector',\n        tiles: [this.options.url],\n      });\n      this.source = this.options.url;\n      MvtAdapter.sources.push(this.options.url);\n    }\n    const mvtLayerOptions: Partial<mapboxgl.Layer> = {\n      source: this.options.url,\n      'source-layer': this.options.sourceLayer,\n    };\n    return mvtLayerOptions;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  BaseLayerAdapter,\n  TileAdapterOptions,\n  RasterAdapterOptions,\n} from '@nextgis/webmap';\nimport { BaseAdapter } from './BaseAdapter';\nimport { RasterSource, ResourceType, Layer } from 'mapbox-gl';\n\nexport class TileAdapter<O extends RasterAdapterOptions = TileAdapterOptions>\n  extends BaseAdapter<O>\n  implements BaseLayerAdapter {\n  addLayer(options: O): string[] {\n    options = { ...this.options, ...(options || {}) };\n    const { minZoom, maxZoom } = options;\n    let tiles: string[];\n    if (options && options.subdomains) {\n      tiles = options.subdomains.split('').map((x) => {\n        const subUrl = options.url.replace('{s}', x);\n        return subUrl;\n      });\n    } else {\n      tiles = [options.url];\n    }\n    if (options.headers) {\n      // @ts-ignore\n      const transformRequests = this.map.transformRequests;\n      transformRequests.push((url: string, resourceType: ResourceType) => {\n        let staticUrl = url;\n        staticUrl = staticUrl.replace(/(z=\\d+)/, 'z={z}');\n        staticUrl = staticUrl.replace(/(x=\\d+)/, 'x={x}');\n        staticUrl = staticUrl.replace(/(y=\\d+)/, 'y={y}');\n        if (staticUrl === options.url) {\n          return {\n            url,\n            headers: options.headers,\n          };\n        }\n      });\n    }\n\n    const sourceOptions: RasterSource = {\n      type: 'raster',\n      // point to our third-party tiles. Note that some examples\n      // show a \"url\" property. This only applies to tilesets with\n      // corresponding TileJSON (such as mapbox tiles).\n      tiles,\n      tileSize: 256, // opt && opt.tileSize ||\n    };\n    if (options.attribution) {\n      sourceOptions.attribution = options.attribution;\n    }\n    const layerOptions: Layer = {\n      id: this._layerId,\n      type: 'raster',\n      layout: {\n        visibility: 'none',\n      },\n      source: sourceOptions,\n      // TODO: clean remove before options from all existing apps\n    };\n\n    if (minZoom) {\n      layerOptions.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOptions.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(\n      layerOptions,\n      // @ts-ignore\n      options.before\n    );\n    const layer = (this.layer = [this._layerId]);\n    return layer;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileAdapter } from './TileAdapter';\n\nconst OPTIONS = {\n  url: 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n  attribution:\n    '&copy; <a href=\"http://osm.org/copyright\" target=\"_blank\">OpenStreetMap</a> contributors',\n  subdomains: 'abc',\n};\n\nexport class OsmAdapter extends TileAdapter implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    return super.addLayer(Object.assign({}, OPTIONS, options));\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\nimport { ZoomControlOptions } from '@nextgis/webmap';\n\nexport class ZoomControl extends NavigationControl {\n  options: ZoomControlOptions & any;\n\n  constructor(options: ZoomControlOptions & any = {}) {\n    options = { ...options, showCompass: false };\n    super(options);\n  }\n\n  _createButton(className: string, ariaLabel: string, fn: () => any) {\n    // @ts-ignore\n    const element = super._createButton(className, ariaLabel, fn);\n    const aliases: any = {\n      'Zoom in': 'zoomInTitle',\n      'Zoom out': 'zoomOutTitle',\n    };\n    const alias = aliases[ariaLabel];\n    const label = alias && this.options[alias];\n    if (label) {\n      element.title = label;\n      element.setAttribute('aria-label', label);\n    }\n\n    return element;\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\n\nexport class CompassControl extends NavigationControl {\n  constructor(options = {}) {\n    options = Object.assign({}, options, { showZoom: false });\n    super(options);\n  }\n}\n","// import { MapControl } from '@nextgis/webmap';\nimport { AttributionControl as AC } from 'mapbox-gl';\n\nexport class AttributionControl extends AC {}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map, GeoJSONSource, GeoJSONSourceRaw } from 'mapbox-gl';\nimport {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n  DataLayerFilter,\n  LayerDefinition,\n  PropertiesFilter,\n} from '@nextgis/webmap';\nimport { VectorAdapterLayerPaint, GetPaintCallback } from '@nextgis/paint';\nimport { featureFilter } from '@nextgis/properties-filter';\nimport {\n  GeoJsonObject,\n  FeatureCollection,\n  GeometryCollection,\n  GeometryObject,\n} from 'geojson';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { VectorAdapter, Feature } from './VectorAdapter';\nimport {\n  detectType,\n  typeAlias,\n  typeAliasForFilter,\n  geometryFilter,\n} from '../util/geom_type';\n\nlet ID = 0;\n\nexport class GeoJsonAdapter extends VectorAdapter<GeoJsonAdapterOptions> {\n  selected = false;\n  source?: string;\n  private _features: Feature[] = [];\n  private _filteredFeatureIds?: (string | number)[] | undefined;\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _sources: Record<string, GeoJSONSource> = {};\n\n  constructor(public map: Map, public options: GeoJsonAdapterOptions) {\n    super(map, options);\n    this.source = this._sourceId;\n  }\n\n  async addLayer(options: GeoJsonAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    if (this.options.data) {\n      this.addData(this.options.data);\n    }\n    return layer;\n  }\n\n  removeLayer() {\n    super.removeLayer();\n    const source = this.map.getSource(this._sourceId);\n    if (source) {\n      this.map.removeSource(this._sourceId);\n    }\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean) {\n    let features: Feature[] = [];\n    const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n    if (cb) {\n      features = this._features = this._features.filter((x) => !cb(x));\n    }\n    source.setData({ type: 'FeatureCollection', features });\n  }\n\n  async addData(data: GeoJsonObject) {\n    let type: VectorAdapterLayerType | undefined;\n    if (this.options.type) {\n      type = this.options.type;\n    }\n    if (!type && data) {\n      const detectedType = detectType(data);\n      type = typeAlias[detectedType];\n    }\n    if (data && type) {\n      const features = this.filterGeometries(data, type);\n      features.forEach((x) => {\n        // to avoid id = 0 is false\n        const fid = '_' + ID++;\n        x._featureFilterId = fid;\n        if (x.properties) {\n          x.properties[this.featureIdName] = fid;\n        }\n      });\n      if (this._filterFun) {\n        this._filter(this._filterFun);\n      }\n      await this._updateLayerPaint(type);\n      const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n      source.setData({ type: 'FeatureCollection', features: this._features });\n    }\n  }\n\n  getLayers() {\n    const filtered = this._filteredFeatureIds;\n    const filterProperties = this._filterProperties;\n    if (filterProperties) {\n      this._updateWithNativeFilter(filterProperties);\n    }\n    return this._getFeatures().map((feature) => {\n      let visible = false;\n      if (filterProperties && feature.properties) {\n        visible = featureFilter(feature, filterProperties);\n      } else if (filtered) {\n        const id = this._getFeatureFilterId(feature);\n        if (id !== undefined) {\n          visible = filtered.indexOf(id) !== -1;\n        }\n      }\n      return {\n        feature,\n        visible,\n      };\n    });\n  }\n\n  filter(fun: DataLayerFilter<Feature, TLayer>) {\n    this._filterFun = fun;\n    this._filter(fun);\n  }\n\n  removeFilter() {\n    this._filterFun = undefined;\n    this._filteredFeatureIds = undefined;\n    this._updateFilter();\n  }\n\n  getSelected() {\n    const features: LayerDefinition<Feature, TLayer>[] = [];\n    this._getFeatures().forEach((x) => {\n      const id = this._getFeatureFilterId(x);\n      if (\n        id &&\n        this._selectedFeatureIds &&\n        this._selectedFeatureIds.indexOf(id) !== -1\n      ) {\n        features.push({ feature: x });\n      }\n    });\n    return features;\n  }\n\n  select(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter((x) =>\n          find({ feature: x })\n        );\n        this._selectFeature(features);\n      } else {\n        this.selected = true;\n        this._selectProperties = find;\n        super._updateFilter();\n      }\n    } else if (!this.selected) {\n      this._selectFeature(this._getFeatures());\n    }\n  }\n\n  unselect(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    this._selectProperties = undefined;\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter((x) =>\n          find({ feature: x })\n        );\n        this._unselectFeature(features);\n        this.selected = Array.isArray(this._selectedFeatureIds) ? true : false;\n      }\n    } else if (this.selected) {\n      this.selected = false;\n      this._unselectFeature();\n    }\n  }\n\n  protected _onAddLayer(sourceId: string) {\n    let source = this.map.getSource(sourceId) as GeoJSONSource;\n    if (!source) {\n      const sourceOpt: GeoJSONSourceRaw = {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features: [],\n        },\n      };\n      const _opts: (keyof GeoJsonAdapterOptions)[] = [\n        'cluster',\n        'clusterMaxZoom',\n        'clusterRadius',\n      ];\n      _opts.forEach((x) => {\n        const opt = this.options[x] as GeoJsonAdapterOptions;\n        if (opt !== undefined) {\n          //@ts-ignore\n          sourceOpt[x] = opt;\n        }\n      });\n      this.map.addSource(sourceId, sourceOpt);\n      source = this.map.getSource(sourceId) as GeoJSONSource;\n    }\n    this._sources[sourceId] = source;\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ): Promise<any> {\n    if (typeof paint === 'function') {\n      return await this._getPaintFromCallback(paint, type, name);\n    } else {\n      return super._createPaintForType(paint, type, name);\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    let selectedFeatureIds = this._selectedFeatureIds || [];\n    if (this.options && !this.options.multiselect) {\n      selectedFeatureIds = [];\n    }\n    let features: Feature[] = [];\n    if (Array.isArray(feature)) {\n      features = feature;\n    } else {\n      features = [feature];\n    }\n    features.forEach((f) => {\n      const id = this._getFeatureFilterId(f);\n      if (id !== undefined) {\n        selectedFeatureIds.push(id);\n      }\n    });\n    this._selectProperties = undefined;\n    this._selectedFeatureIds = selectedFeatureIds;\n    this._updateFilter();\n  }\n\n  protected _unselectFeature(feature?: Feature | Feature[]) {\n    if (feature) {\n      let features: Feature[] = [];\n      if (Array.isArray(feature)) {\n        features = feature;\n      } else {\n        features = [feature];\n      }\n      if (features.length) {\n        features.forEach((f) => {\n          const id = this._getFeatureFilterId(f);\n          const selected = this._selectedFeatureIds;\n          if (selected && id !== undefined) {\n            const index = selected.indexOf(id);\n            if (index !== -1) {\n              selected.splice(index, 1);\n            }\n          }\n        });\n      }\n    } else {\n      this._selectedFeatureIds = false;\n    }\n    this._updateFilter();\n  }\n\n  protected _updateFilter() {\n    // it is not yet possible to use callbacks and properties filters together\n    if (this._filterProperties || this._selectProperties) {\n      return super._updateFilter();\n    }\n    const selected = this._selectedFeatureIds;\n    let selectionArray: (string | number)[] = [];\n    const filteredArray: (string | number)[] = [];\n    const filtered = this._filteredFeatureIds;\n    if (filtered) {\n      this._getFeatures().forEach((x) => {\n        const id = this._getFeatureFilterId(x);\n        if (id !== undefined && filtered.indexOf(id) !== -1) {\n          if (selected && selected.indexOf(id) !== -1) {\n            selectionArray.push(id);\n          } else {\n            filteredArray.push(id);\n          }\n        }\n      });\n    } else if (selected) {\n      selectionArray = selected;\n    }\n    this.selected = !!selected;\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach((t) => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              this.map.setFilter(selLayerName, [\n                'all',\n                geomFilter,\n                ['in', this.featureIdName, ...selectionArray],\n              ]);\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filter_: any[] = ['all', geomFilter];\n            if (filtered) {\n              filter_.push(['in', this.featureIdName, ...filteredArray]);\n            } else {\n              filter_.push(['!in', this.featureIdName, ...selectionArray]);\n              this._updateWithNativeFilter(filter_);\n            }\n            this.map.setFilter(layerName, filter_);\n          }\n        }\n      });\n    }\n  }\n\n  private _getFeatures(): Feature[] {\n    if (this.source) {\n      // const features = this.map.querySourceFeatures(this.source);\n      // return features;\n\n      const source = this.map.getSource(this.source);\n      if (source) {\n        // @ts-ignore\n        return source._data?.features || [];\n      }\n    }\n    return this._features;\n  }\n\n  private _filter(fun: DataLayerFilter<Feature, TLayer>) {\n    const filtered: (string | number)[] = [];\n    this._getFeatures().forEach((feature) => {\n      const ok = fun({ feature });\n      const id = this._getFeatureFilterId(feature);\n      if (ok && id) {\n        filtered.push(id);\n      }\n    });\n    this._filteredFeatureIds = filtered;\n    this._updateFilter();\n  }\n\n  private filterGeometries(\n    data: GeoJsonObject,\n    type: VectorAdapterLayerType\n  ): Feature[] {\n    let newFeatures: Feature[] = [];\n    if (data.type === 'FeatureCollection') {\n      const features = (data as FeatureCollection).features.filter((f) =>\n        geometryFilter(f.geometry.type, type)\n      ) as Feature[];\n      (data as FeatureCollection).features = features;\n      newFeatures = features;\n    } else if (data.type === 'Feature') {\n      const allow = geometryFilter((data as Feature).geometry.type, type);\n      if (!allow) {\n        return [];\n      }\n      newFeatures.push(data as Feature);\n    } else if (data.type === 'GeometryCollection') {\n      const geomCollection = data as GeometryCollection;\n      geomCollection.geometries = geomCollection.geometries.filter((g) =>\n        geometryFilter(g.type, type)\n      );\n      newFeatures = geomCollection.geometries.map((x) => {\n        const f: Feature = {\n          type: 'Feature',\n          geometry: x as GeometryObject,\n          properties: {},\n        };\n        return f;\n      });\n    } else if (typeAlias[data.type]) {\n      const obj: Feature = {\n        type: 'Feature',\n        geometry: data as GeometryObject,\n        properties: {},\n      };\n      newFeatures = [obj];\n    }\n    this._features = this._features.concat(newFeatures);\n    return newFeatures;\n  }\n\n  private async _getPaintFromCallback(\n    paint: GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ) {\n    const style: any = {};\n    for (const feature of this._features) {\n      const _paint = paint(feature);\n      if (_paint.type === 'icon') {\n        await this._registerImage(_paint);\n        if (feature.properties) {\n          feature.properties['_icon-image-' + name] = _paint.html;\n        }\n        style['icon-image'] = `{_icon-image-${name}}`;\n      } else {\n        for (const p in _paint) {\n          // @ts-ignore\n          const toSave = _paint[p];\n          if (feature.properties) {\n            feature.properties[`_paint_${p}_${name}`] = toSave;\n          }\n          style[p] = ['get', `_paint_${p}_${name}`];\n        }\n      }\n    }\n    if ('icon-image' in style) {\n      return style;\n    }\n    const styleFromCb = this._createPaintForType(style, type, name);\n    return styleFromCb;\n  }\n}\n","import { MapControl, CreateControlOptions } from '@nextgis/webmap';\nimport { IControl } from 'mapbox-gl';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {}\n): IControl {\n  class Control implements IControl {\n    private _container?: HTMLElement;\n\n    getDefaultPosition() {\n      return 'top-left';\n    }\n\n    onAdd() {\n      const element = document.createElement('div');\n      const content = control.onAdd();\n      element.classList.add('mapboxgl-ctrl');\n      if (options.bar) {\n        // add custom css for boarder style\n        element.classList.add('mapboxgl-bar');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      if (content) {\n        element.appendChild(content);\n      }\n      this._container = element;\n      return this._container;\n    }\n\n    onRemove() {\n      if (this._container) {\n        const parent = this._container.parentNode;\n        if (parent) {\n          parent.removeChild(this._container);\n        }\n      }\n      return control.onRemove();\n    }\n\n    remove() {\n      this.onRemove();\n    }\n  }\n\n  return new Control();\n  // return control;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, WmsAdapterOptions } from '@nextgis/webmap';\n\nimport { TileAdapter } from './TileAdapter';\n\nexport class WmsAdapter extends TileAdapter<WmsAdapterOptions>\n  implements BaseLayerAdapter {\n  addLayer(options: WmsAdapterOptions): string[] {\n    const params: Record<string, string | number> = {\n      bbox: '{bbox-epsg-3857}',\n      format: options.format || 'image/png',\n      service: 'WMS',\n      version: '1.1.1',\n      request: 'GetMap',\n      srs: 'EPSG:3857',\n      transparent: 'true',\n      width: options.tileSize || '256',\n      height: options.tileSize || '256',\n      layers: options.layers || '',\n    };\n    const paramsStr = Object.keys(params)\n      .map((x) => `${x}=${params[x]}`)\n      .join('&');\n    options.url = options.url + '?' + paramsStr;\n    return super.addLayer(options);\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  MapAdapter,\n  FitOptions,\n  MapControl,\n  ControlPositions,\n  ButtonControlOptions,\n  LngLatArray,\n  MapOptions,\n  LayerAdapter,\n  LngLatBoundsArray,\n  WebMapEvents,\n  CreateControlOptions,\n} from '@nextgis/webmap';\nimport { sleep, debounce } from '@nextgis/utils';\nimport { MvtAdapter } from './layer-adapters/MvtAdapter';\nimport mapboxgl, {\n  Map,\n  IControl,\n  MapEventType,\n  EventData,\n  MapboxOptions,\n  RequestParameters,\n  ResourceType,\n  FitBoundsOptions,\n} from 'mapbox-gl';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter';\nimport { EventEmitter } from 'events';\nimport { ZoomControl } from './controls/ZoomControl';\nimport { CompassControl } from './controls/CompassControl';\nimport { AttributionControl } from './controls/AttributionControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { createControl } from './controls/createControl';\nimport { createButtonControl } from './controls/createButtonControl';\nimport { WmsAdapter } from './layer-adapters/WmsAdapter';\n\nexport type TLayer = string[];\ntype TLayerAdapter = LayerAdapter<Map, TLayer>;\n\nconst fitBoundsOptions: FitOptions = {\n  // padding: 100\n};\n\nexport interface MapboxglMapAdapterOptions extends MapOptions {\n  style?: Partial<mapboxgl.Style> | string;\n  accessToken?: string;\n}\n\nexport class MapboxglMapAdapter implements MapAdapter<Map, TLayer, IControl> {\n  static layerAdapters = {\n    TILE: TileAdapter,\n    WMS: WmsAdapter,\n    // IMAGE: TileAdapter,\n    MVT: MvtAdapter,\n    OSM: OsmAdapter,\n    GEOJSON: GeoJsonAdapter,\n  };\n\n  static controlAdapters: { [name: string]: any } = {\n    ZOOM: ZoomControl,\n    COMPASS: CompassControl,\n    ATTRIBUTION: AttributionControl,\n  };\n\n  options: MapboxglMapAdapterOptions = {};\n  map!: Map;\n\n  emitter = new EventEmitter();\n\n  layerAdapters = MapboxglMapAdapter.layerAdapters;\n  controlAdapters = MapboxglMapAdapter.controlAdapters;\n  isLoaded = false;\n\n  private _universalEvents: (keyof WebMapEvents)[] = [\n    'zoomstart',\n    'zoom',\n    'zoomend',\n    'movestart',\n    'move',\n    'moveend',\n  ];\n\n  private _sourceDataLoading: { [name: string]: any[] } = {};\n  private _sortTimerId?: number;\n  private __setLayerOrder: (layers: { [x: string]: TLayerAdapter }) => void;\n\n  constructor() {\n    this.__setLayerOrder = debounce((layers) => this._setLayerOrder(layers));\n  }\n\n  // create(options: MapOptions = {target: 'map'}) {\n  create(options: MapboxglMapAdapterOptions) {\n    return new Promise((resolve, reject) => {\n      if (!this.map) {\n        this.options = options;\n        if (options.accessToken) {\n          mapboxgl.accessToken = options.accessToken;\n        }\n        if (options.target) {\n          const mapOpt: MapboxOptions = {\n            container: options.target,\n            attributionControl: false,\n            // @ts-ignore\n            bounds: options.bounds,\n            fitBoundsOptions: { ...options.fitOptions, ...fitBoundsOptions },\n            transformRequest: (url: string, resourceType: ResourceType) => {\n              const transformed = this._transformRequest(url, resourceType);\n              if (transformed) {\n                return transformed;\n              } else {\n                return {\n                  url,\n                };\n              }\n            },\n          };\n          if (typeof options.style === 'string') {\n            mapOpt.style = options.style;\n          } else {\n            mapOpt.style = {\n              ...{\n                version: 8,\n                name: 'Empty style',\n                sources: {},\n                layers: [],\n              },\n              ...options.style,\n            };\n          }\n          if (options.center !== undefined) {\n            mapOpt.center = options.center;\n          }\n          if (options.zoom !== undefined) {\n            mapOpt.zoom = options.zoom - 1;\n          }\n          if (options.maxZoom) {\n            mapOpt.maxZoom = options.maxZoom - 1;\n          }\n          if (options.minZoom) {\n            mapOpt.minZoom = options.minZoom - 1;\n          }\n          this.map = new Map(mapOpt);\n          this.map.once('load', () => {\n            // @ts-ignore\n            this.map.transformRequests = [];\n            this.isLoaded = true;\n            this.emitter.emit('create', this);\n            resolve(this);\n          });\n          this._addEventsListeners();\n        }\n      }\n    });\n  }\n\n  destroy() {\n    if (this.map) {\n      this.map.remove();\n    }\n  }\n\n  getContainer() {\n    return this.map && this.map.getContainer();\n  }\n\n  setView(center: LngLatArray, zoom?: number) {\n    if (this.map) {\n      const options: mapboxgl.CameraOptions = { center };\n      if (zoom) {\n        options.zoom = zoom - 1;\n      }\n      this.map.jumpTo(options);\n    }\n  }\n\n  setCenter(latLng: LngLatArray): void {\n    if (this.map) {\n      this.map.setCenter(latLng);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    if (this.map) {\n      const center = this.map.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom - 1);\n    }\n  }\n\n  getZoom(): number | undefined {\n    if (this.map) {\n      const zoom = this.map.getZoom();\n      if (zoom < 1) {\n        return undefined;\n      }\n      return zoom ? zoom + 1 : undefined;\n    }\n  }\n\n  getBounds() {\n    if (this.map) {\n      const bounds = this.map.getBounds();\n      const ar = bounds.toArray();\n      return [ar[0][0], ar[0][1], ar[1][0], ar[1][1]];\n    }\n  }\n\n  // [extent_left, extent_bottom, extent_right, extent_top];\n  async fitBounds(\n    e: LngLatBoundsArray,\n    options: FitOptions = {}\n  ): Promise<void> {\n    if (this.map) {\n      const fitBoundOptions: FitBoundsOptions = {\n        linear: true,\n        duration: 0,\n        ...options,\n        ...fitBoundsOptions,\n      };\n      this.map.fitBounds(\n        [\n          [e[0], e[1]],\n          [e[2], e[3]],\n        ],\n        fitBoundOptions\n      );\n      sleep(fitBoundOptions.duration);\n    }\n  }\n\n  setRotation(angle: number): void {\n    // ignore\n  }\n\n  showLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach((layerId) => {\n        this._toggleLayer(layerId, true);\n      });\n  }\n\n  hideLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach((layerId) => {\n        this._toggleLayer(layerId, false);\n      });\n  }\n\n  removeLayer(layerIds: string[]): void {\n    const _map = this.map;\n    if (_map && layerIds && Array.isArray(layerIds)) {\n      layerIds.forEach((layerId) => {\n        _map.removeLayer(layerId);\n        const source = _map.getSource(layerId);\n        if (source) {\n          _map.removeSource(layerId);\n        }\n      });\n    }\n  }\n\n  setLayerOrder(\n    layerIds: string[],\n    order: number,\n    layers: { [x: string]: TLayerAdapter }\n  ): void {\n    this.__setLayerOrder(layers);\n  }\n\n  setLayerOpacity(layerIds: string[], opacity: number): void {\n    const _map = this.map;\n    if (_map) {\n      layerIds.forEach((layerId) => {\n        this._onMapLoad().then(() => {\n          const layer = _map.getLayer(layerId);\n          if (layer) {\n            if (layer.type === 'symbol') {\n              _map.setPaintProperty(layerId, 'text-opacity', opacity);\n              _map.setPaintProperty(layerId, 'icon-opacity', opacity);\n            } else {\n              _map.setPaintProperty(layerId, layer.type + '-opacity', opacity);\n            }\n          }\n        });\n      });\n    }\n  }\n\n  createControl(control: MapControl, options?: CreateControlOptions): IControl {\n    return createControl(control, options);\n  }\n\n  createButtonControl(options: ButtonControlOptions): IControl {\n    return createButtonControl(options);\n  }\n\n  addControl(\n    control: IControl,\n    position: ControlPositions\n  ): IControl | undefined {\n    if (this.map) {\n      this.map.addControl(control, position);\n      return control;\n    }\n  }\n\n  removeControl(control: IControl): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  onMapClick(evt: MapEventType['click'] & EventData): void {\n    const latLng = evt.lngLat;\n    const { x, y } = evt.point;\n\n    this.emitter.emit('click', { latLng, pixel: { top: y, left: x } });\n  }\n\n  private _onMapLoad(cb?: () => any): Promise<Map> {\n    return new Promise<Map>((resolve) => {\n      const _resolve = () => {\n        if (cb) {\n          cb();\n        }\n        if (this.map) {\n          resolve(this.map);\n        }\n      };\n      if (this.isLoaded) {\n        // map.loaded()\n        _resolve();\n      } else if (this.map) {\n        this.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  private _setLayerOrder(layers: { [x: string]: TLayerAdapter }): void {\n    const _map = this.map;\n    if (_map) {\n      const baseLayers: TLayerAdapter[] = [];\n      let orderedLayers: TLayerAdapter[] = [];\n      for (const l in layers) {\n        const layer = layers[l];\n        if (layer.options.baseLayer) {\n          baseLayers.push(layer);\n        } else {\n          orderedLayers.push(layer);\n        }\n      }\n\n      // normalize layer ordering\n      baseLayers.forEach((x) => {\n        if (x.layer) {\n          x.layer.forEach((y) => {\n            _map.moveLayer(y);\n          });\n        }\n      });\n\n      orderedLayers = orderedLayers.sort((a, b) => {\n        return a.options.order !== undefined && b.options.order !== undefined\n          ? a.options.order - b.options.order\n          : 0;\n      });\n\n      for (let fry = 0; fry < orderedLayers.length; fry++) {\n        const mem = orderedLayers[fry];\n        const _layers = this._getLayerIds(mem);\n        _layers.forEach((x) => {\n          _map.moveLayer(x);\n        });\n      }\n    }\n  }\n\n  private _getLayerIds(mem: TLayerAdapter): string[] {\n    let _layers: TLayer = [];\n    if (mem) {\n      if (Array.isArray(mem.layer)) {\n        _layers = mem.layer;\n      } else if (mem.getDependLayers) {\n        const dependLayers = mem.getDependLayers();\n        dependLayers.forEach((x) => {\n          // @ts-ignore Update x interface\n          const layer: TLayer = (x.layer && x.layer.layer) || x;\n          if (Array.isArray(layer)) {\n            layer.forEach((y) => {\n              _layers.push(y);\n            });\n          }\n        });\n      }\n    }\n    return _layers;\n  }\n\n  private _toggleLayer(layerId: string, status: boolean): void {\n    this._onMapLoad().then((_map) => {\n      _map.setLayoutProperty(\n        layerId,\n        'visibility',\n        status ? 'visible' : 'none'\n      );\n    });\n  }\n\n  private _onMapSourceData(data: mapboxgl.MapSourceDataEvent & EventData) {\n    if (data.dataType === 'source') {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-loaded', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onMapError(\n    data: mapboxgl.ErrorEvent & mapboxgl.MapSourceDataEvent & EventData\n  ) {\n    if (this._sourceDataLoading[data.sourceId]) {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-error', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onDataLoad(\n    data: { sourceId: string; tile: any },\n    isLoaded = false,\n    emit: (sourceId: string) => void\n  ) {\n    // if all sources is loaded emmit event for all and clean mem\n    if (isLoaded) {\n      Object.keys(this._sourceDataLoading).forEach((x) => {\n        emit(x);\n      });\n      this._sourceDataLoading = {};\n    } else {\n      // check if all tiles in layer is loaded\n      const tiles = this._sourceDataLoading[data.sourceId];\n      if (tiles && data.tile) {\n        const index = tiles.indexOf(data.tile);\n        if (index !== -1) {\n          this._sourceDataLoading[data.sourceId].splice(index, 1);\n        }\n        // if no more loaded tiles in layer emit event and clean mem only for this layer\n        if (!tiles.length) {\n          emit(data.sourceId);\n          delete this._sourceDataLoading[data.sourceId];\n        }\n      }\n    }\n  }\n\n  private _transformRequest(\n    url: string,\n    resourceType: ResourceType\n  ): RequestParameters | undefined {\n    // @ts-ignore\n    const transformRequests = this.map && this.map.transformRequests;\n    if (transformRequests) {\n      for (const r of transformRequests) {\n        const params = r(url, resourceType) as RequestParameters;\n        if (params) {\n          return params;\n        }\n      }\n      return undefined;\n    }\n  }\n\n  private _addEventsListeners(): void {\n    const _map = this.map;\n    if (_map) {\n      // write mem for start loaded layers\n      _map.on('sourcedataloading', (data) => {\n        this._sourceDataLoading[data.sourceId] =\n          this._sourceDataLoading[data.sourceId] || [];\n        if (data.tile) {\n          this._sourceDataLoading[data.sourceId].push(data.tile);\n        }\n      });\n      // emmit data-loaded for each layer or all sources is loaded\n      _map.on('sourcedata', this._onMapSourceData.bind(this));\n      _map.on('error', this._onMapError.bind(this));\n      _map.on('click', (evt) => {\n        this.onMapClick(evt);\n      });\n\n      this._universalEvents.forEach((e) => {\n        _map.on(e, () => this.emitter.emit(e, this));\n      });\n    }\n  }\n}\n","import { ButtonControlOptions } from '@nextgis/webmap';\nimport { createControl } from './createControl';\n\nexport function createButtonControl(options: ButtonControlOptions) {\n  const link = document.createElement('button');\n  link.className = 'mapboxgl-ctrl-icon';\n\n  link.setAttribute('role', 'button');\n  if (options.title) {\n    link.title = options.title;\n    link.setAttribute('aria-label', options.title);\n  }\n\n  if (options.html) {\n    if (options.html instanceof HTMLElement) {\n      link.appendChild(options.html);\n    } else {\n      link.innerHTML = options.html;\n    }\n    const child = link.firstElementChild as HTMLElement;\n    if (child) {\n      child.style.width = '100%';\n      child.style.height = '100%';\n      child.style.lineHeight = (link.offsetHeight || 30) + 'px';\n    }\n  }\n  if (options.addClass) {\n    options.addClass.split(' ').forEach((x) => link.classList.add(x));\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n  if (options.onClick !== undefined) {\n    link.addEventListener('click', onClick);\n  }\n\n  return createControl(\n    {\n      onAdd() {\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      },\n    },\n    { bar: true, addClass: 'mapboxgl-ctrl-group' }\n  );\n}\n","/**\n * @module mapboxgl-map-adapter\n */\n\nimport { MapboxglMapAdapter } from './MapboxglMapAdapter';\nexport * from './MapboxglMapAdapter';\nexport default MapboxglMapAdapter;\n","/**\n * @module icons\n */\n\n// tslint:disable:max-line-length\nimport { IconOptions as WebmapIcoOptions } from '@nextgis/paint';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star:\n    '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>',\n};\n\nexport interface IconOptions {\n  shape?:\n    | 'circle'\n    | 'brill'\n    | 'rect'\n    | 'marker'\n    | 'star'\n    | 'asterisk'\n    | 'triangle'\n    | 'plus'\n    | 'minus';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n}\n\nconst STROKE = 0.8;\n\nfunction insertSvg(\n  width: number,\n  height: number,\n  stroke = 0,\n  content?: string\n) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${width + stroke} ${height + stroke}\"\n  >${content}</svg>`;\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\nexport function getIcon(opt: IconOptions = {}): WebmapIcoOptions {\n  // default values\n  const shape = opt.shape || 'circle';\n  const color = opt.color || 'blue';\n  const strokeColor = opt.strokeColor || 'white';\n  const size = opt.size || 12;\n\n  const anchor = size / 2;\n  const defSize = 12;\n  const stroke = typeof opt.stroke === 'number' ? opt.stroke : STROKE;\n  const scale = size / defSize;\n\n  const pathAlias = svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(size, size, stroke * scale, path);\n  const fistChild = svg.firstChild as SVGElement;\n\n  const transform = `scale(${scale})`;\n\n  fistChild.setAttribute('fill', color);\n  if (stroke) {\n    fistChild.setAttribute('stroke', strokeColor);\n    fistChild.setAttribute('stroke-width', String(stroke));\n  }\n  fistChild.setAttribute('transform', transform);\n  const s = new XMLSerializer();\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: [anchor, anchor],\n    html: s.serializeToString(svg),\n    svg,\n  };\n}\n","/**\n * @module item\n */\nexport type SelfFilter<X extends any> = (x: X) => boolean;\nexport type RelationFunction<X extends any> = (x: X) => X | X[] | undefined;\n\nexport function filterIn<F extends any = any>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F) => !!x,\n  relationFunc: RelationFunction<F>,\n  _filtered: F[] = []\n): F[] {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      _filtered.push(item);\n    }\n    const relChild = relationFunc(item);\n    if (relChild) {\n      if (Array.isArray(relChild)) {\n        children = relChild;\n      } else {\n        children.push(relChild);\n      }\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      filterIn(children[fry], filterFunc, relationFunc, _filtered);\n    }\n  }\n\n  return _filtered;\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\nimport { filterIn } from './TreeUtil';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  // region Parents\n  setParent(parent: Item) {\n    this._parent = parent;\n  }\n\n  addChild(child: Item) {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return filterIn(parent, filterFunc, (x: I) => x.tree.getParent() as I);\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n  // endregion\n\n  // region Child\n  find(filterFunc?: (item: Item) => boolean) {\n    return filterIn(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    })[0];\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return filterIn(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return this._children as T[];\n  }\n}\n","/**\n * @module item\n */\nimport { Item } from '../Item';\nimport { ItemBasePropertyOptions } from '../interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\n// import StrictEventEmitter from 'strict-event-emitter-types/types/src';\n\n// export interface BasePropertyEvents<V, O> {\n//   'change': {value: V, options: O};\n//   'change-tree': {value: V, options: O, item: Item};\n// }\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>\n> {\n  options: O;\n\n  // emitter: StrictEventEmitter<EventEmitter, BasePropertyEvents<V, O>> = new EventEmitter();\n  emitter = EventEmitter && new EventEmitter();\n  name: string;\n\n  item: Item;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: Item, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty() {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent() {\n    return this.item.tree.getParent();\n  }\n\n  isGroup() {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked() {\n    if (this._blocked === undefined) {\n      const parents = this.item.tree.getParents();\n      if (parents) {\n        const isBlocked = parents.find((x: Item) => {\n          const parentProp = x.properties && x.properties.property(this.name);\n          if (parentProp) {\n            return !parentProp.get();\n          }\n          return false;\n        });\n        this._blocked = !!isBlocked;\n      } else {\n        this._blocked = false;\n      }\n    }\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O) {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O) {\n    this._callOnSet(value, options);\n  }\n\n  getContainer() {\n    return this._container;\n  }\n\n  destroy() {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O) {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O) {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach((x) => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', { value, options, item: this.item });\n        }\n      });\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\nimport { ItemOptions } from './interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n  emitter = EventEmitter && new EventEmitter();\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties() {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","/**\n * @module item\n */\nimport { BaseProperty } from './BaseProperty';\nimport { Item } from '../Item';\n\nimport { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle',\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O) {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false })\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue() {\n    return (\n      this.get() &&\n      this.getParents().every((x) => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  _prepareValue(value?: any): V | undefined {\n    return value;\n  }\n\n  _turnOff(options?: O) {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChilds(options);\n    }\n  }\n\n  _turnOn(options?: O) {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChilds(options);\n    }\n  }\n\n  block(options?: O) {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  _block(options?: O) {\n    this._turnOff(options);\n  }\n\n  unBlock(options?: O) {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  _unBlock(options?: O) {\n    this._turnOn(options);\n  }\n\n  blockChilds(options?: O) {\n    this.item.tree\n      .getDescendants()\n      .forEach((x) => this._blockChild(x, options));\n  }\n\n  unblockChilds(options?: O) {\n    this.item.tree.getChildren().forEach((x) => this._unBlockChild(x, options));\n  }\n\n  _blockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  _unBlockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  _propagation(value?: V, options?: O) {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false,\n            },\n          });\n        }\n      }\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { BaseProperty } from './BaseProperty';\nimport { CheckProperty } from './CheckProperty';\nimport { Item } from '../Item';\n\nimport {\n  ItemBasePropertyOptions,\n  Type,\n  ItemPropertyConfig,\n  ItemPropertyTypes,\n} from '../interfaces';\n\nexport class ItemProperties {\n  static handlers: { [name: string]: Type<BaseProperty> } = {\n    CheckProperty,\n  };\n\n  options = {};\n\n  private _properties: { [propName: string]: BaseProperty } = {};\n  private _propertiesList: string[];\n\n  constructor(\n    public item: Item,\n    propertiesList?: ItemPropertyConfig<keyof ItemPropertyTypes>[]\n  ) {\n    this._propertiesList = []; // ordered list\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    this._setPropertyHandler(propOpt);\n  }\n\n  _setPropertyHandler(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    const handlers = ItemProperties.handlers;\n    let handler = propOpt.handler;\n    if (!handler && propOpt.type) {\n      switch (propOpt.type) {\n        case 'boolean':\n          handler = handlers.CheckProperty;\n          break;\n        case 'string':\n          handler = handlers.BaseProperty;\n          break;\n        default:\n          handler = handlers.BaseProperty;\n      }\n    }\n    if (handler && propOpt.name) {\n      const options = { ...(propOpt || {}) };\n      this._properties[propOpt.name] = new handler(\n        propOpt.name,\n        this.item,\n        options\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  update() {\n    this.list().forEach((x) => {\n      x.update();\n    });\n  }\n\n  get(name: string) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.get();\n    }\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>\n  ) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.set(value, options);\n    }\n  }\n\n  property(name: string) {\n    return this._properties[name];\n  }\n\n  list() {\n    return this._propertiesList.map((x) => this._properties[x]);\n  }\n\n  destroy() {\n    for (const p in this._properties) {\n      const prop = this.property(p);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\n\nexport * from './interfaces';\nexport * from './properties/BaseProperty';\nexport * from './properties/CheckProperty';\nexport * from './properties/ItemProperties';\n\nexport { Item };\nexport default Item;\n","/**\n * @module cancelable-promise\n */\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nexport class CancelablePromise<T> implements Promise<T> {\n  readonly [Symbol.toStringTag]: string;\n\n  private _canceled = false;\n\n  private _promise?: Promise<T>;\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void\n    ) => void,\n    private onCancel?: (...args: any[]) => void\n  ) {\n    this._promise = new Promise(executor);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve) => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values).then(resolve).catch(reject);\n    });\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise(\n      (resolve, reject) => {\n        if (this._promise) {\n          this._promise.then(\n            (r) => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onfulfilled && !this._canceled) {\n                handleCallback(resolve, reject, onfulfilled, r);\n              } else {\n                resolve(r);\n              }\n            },\n            (r) => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onrejected && !this._canceled) {\n                handleCallback(resolve, reject, onrejected, r);\n              } else {\n                reject(r);\n              }\n            }\n          );\n        }\n      },\n      () => {\n        this.cancel();\n      }\n    );\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null\n  ): CancelablePromise<T | TResult> {\n    return this.then(undefined, onrejected);\n  }\n\n  cancel(errorCallback?: (...args: any[]) => void) {\n    this._canceled = true;\n    if (errorCallback && this._promise) {\n      this._promise.catch(errorCallback);\n    }\n    if (this.onCancel) {\n      this.onCancel();\n    }\n    this._destroy();\n    return this;\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  private _destroy() {\n    this.onCancel = undefined;\n    this._promise = undefined;\n  }\n}\n","/**\n * @module cancelable-promise\n */\nimport { CancelablePromise } from './CancelablePromise';\n\nexport { CancelablePromise };\n\nexport default CancelablePromise;\n"],"sourceRoot":""}