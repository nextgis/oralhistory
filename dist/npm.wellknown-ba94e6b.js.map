{"version":3,"sources":["webpack:///./node_modules/wellknown/index.js"],"names":["module","exports","parse","stringify","gj","type","geometry","pairWKT","c","join","ringWKT","r","map","ringsWKT","wrapParens","s","coordinates","geometries","Error","numberRegexp","tuples","RegExp","source","input","obj","parts","split","_","pop","srid","shift","i","$","re","match","substring","length","white","multicoords","elem","depth","rings","stack","pointer","push","some","isNaN","Array","prototype","apply","parseFloat","coords","item","pt","list","root","point","linestring","polygon","newCoordsFormat","indexOf","replace","multipoint","multilinestring","multipolygon","geometrycollection","crs","properties","name"],"mappings":"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","file":"npm.wellknown-ba94e6b.js","sourcesContent":["/*eslint-disable no-cond-assign */\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n\nvar numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;\n// Matches sequences like '100 100' or '100 100 100'.\nvar tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\n\n/*\n * Parse WKT and return GeoJSON.\n *\n * @param {string} _ A WKT geometry\n * @return {?Object} A GeoJSON geometry object\n */\nfunction parse (input) {\n  var parts = input.split(';');\n  var _ = parts.pop();\n  var srid = (parts.shift() || '').split('=').pop();\n\n  var i = 0;\n\n  function $ (re) {\n    var match = _.substring(i).match(re);\n    if (!match) return null;\n    else {\n      i += match[0].length;\n      return match[0];\n    }\n  }\n\n  function crs (obj) {\n    if (obj && srid.match(/\\d+/)) {\n      obj.crs = {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:EPSG::' + srid\n        }\n      };\n    }\n\n    return obj;\n  }\n\n  function white () { $(/^\\s*/); }\n\n  function multicoords () {\n    white();\n    var depth = 0;\n    var rings = [];\n    var stack = [rings];\n    var pointer = rings;\n    var elem;\n\n    while (elem =\n           $(/^(\\()/) ||\n             $(/^(\\))/) ||\n               $(/^(,)/) ||\n                 $(tuples)) {\n      if (elem === '(') {\n        stack.push(pointer);\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n        depth++;\n      } else if (elem === ')') {\n        // For the case: Polygon(), ...\n        if (pointer.length === 0) return null;\n\n        pointer = stack.pop();\n        // the stack was empty, input was malformed\n        if (!pointer) return null;\n        depth--;\n        if (depth === 0) break;\n      } else if (elem === ',') {\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n      } else if (!elem.split(/\\s/g).some(isNaN)) {\n        Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n      } else {\n        return null;\n      }\n      white();\n    }\n\n    if (depth !== 0) return null;\n\n    return rings;\n  }\n\n  function coords () {\n    var list = [];\n    var item;\n    var pt;\n    while (pt =\n           $(tuples) ||\n             $(/^(,)/)) {\n      if (pt === ',') {\n        list.push(item);\n        item = [];\n      } else if (!pt.split(/\\s/g).some(isNaN)) {\n        if (!item) item = [];\n        Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n      }\n      white();\n    }\n\n    if (item) list.push(item);\n    else return null;\n\n    return list.length ? list : null;\n  }\n\n  function point () {\n    if (!$(/^(point(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    white();\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'Point',\n      coordinates: c[0]\n    };\n  }\n\n  function multipoint () {\n    if (!$(/^(multipoint)/i)) return null;\n    white();\n    var newCoordsFormat = _\n      .substring(_.indexOf('(') + 1, _.length - 1)\n      .replace(/\\(/g, '')\n      .replace(/\\)/g, '');\n    _ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiPoint',\n      coordinates: c\n    };\n  }\n\n  function multilinestring () {\n    if (!$(/^(multilinestring)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiLineString',\n      coordinates: c\n    };\n  }\n\n  function linestring () {\n    if (!$(/^(linestring(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'LineString',\n      coordinates: c\n    };\n  }\n\n  function polygon () {\n    if (!$(/^(polygon(\\sz)?)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'Polygon',\n      coordinates: c\n    };\n  }\n\n  function multipolygon () {\n    if (!$(/^(multipolygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'MultiPolygon',\n      coordinates: c\n    };\n  }\n\n  function geometrycollection () {\n    var geometries = [];\n    var geometry;\n\n    if (!$(/^(geometrycollection)/i)) return null;\n    white();\n\n    if (!$(/^(\\()/)) return null;\n    while (geometry = root()) {\n      geometries.push(geometry);\n      white();\n      $(/^(,)/);\n      white();\n    }\n    if (!$(/^(\\))/)) return null;\n\n    return {\n      type: 'GeometryCollection',\n      geometries: geometries\n    };\n  }\n\n  function root () {\n    return point() ||\n      linestring() ||\n      polygon() ||\n      multipoint() ||\n      multilinestring() ||\n      multipolygon() ||\n      geometrycollection();\n  }\n\n  return crs(root());\n}\n\n/**\n * Stringifies a GeoJSON object into WKT\n */\nfunction stringify (gj) {\n  if (gj.type === 'Feature') {\n    gj = gj.geometry;\n  }\n\n  function pairWKT (c) {\n    return c.join(' ');\n  }\n\n  function ringWKT (r) {\n    return r.map(pairWKT).join(', ');\n  }\n\n  function ringsWKT (r) {\n    return r.map(ringWKT).map(wrapParens).join(', ');\n  }\n\n  function multiRingsWKT (r) {\n    return r.map(ringsWKT).map(wrapParens).join(', ');\n  }\n\n  function wrapParens (s) { return '(' + s + ')'; }\n\n  switch (gj.type) {\n    case 'Point':\n      return 'POINT (' + pairWKT(gj.coordinates) + ')';\n    case 'LineString':\n      return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';\n    case 'Polygon':\n      return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';\n    case 'MultiPoint':\n      return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';\n    case 'MultiPolygon':\n      return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';\n    case 'MultiLineString':\n      return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';\n    case 'GeometryCollection':\n      return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';\n    default:\n      throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');\n  }\n}\n"],"sourceRoot":""}