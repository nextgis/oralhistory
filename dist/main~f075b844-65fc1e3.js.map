{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/image_icons.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/geom_type.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/VectorAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/MvtAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/TileAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/ZoomControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/CompassControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/AttributionControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/MapboxglMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createButtonControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/index.ts","webpack:///./nextgisweb_frontend/packages/icons/src/index.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeUtil.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeHelper.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/BaseProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/Item.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/CheckProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/ItemProperties.ts","webpack:///./nextgisweb_frontend/packages/item/src/index.ts"],"names":["canvg","er","getImageData","img","opt","canvas","window","document","createElement","context","getContext","Error","setAttribute","String","width","height","HTMLImageElement","drawImage","Canvg","fromString","start","ID","map","options","this","_layerId","allowedByType","circle","line","fill","icon","concat","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","typeAliasForFilter","backAliases","a","layerType","backAlias","push","findMostFrequentGeomType","arr","counts","fry","length","maxName","c","maxCount","geometryFilter","geometry","type","backType","indexOf","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","like","ilike","reversOperations","PAINT","color","opacity","radius","selected","featureIdName","_types","_selectedFeatureIds","_sourceId","source","_selectionName","$onLayerClick","_onLayerClick","bind","addLayer","layer","types","paint","_onAddLayer","t","geomType","_detectPaintType","_getLayerNameFromType","geomFilter","undefined","_addLayer","_getNativeFilter","selectedPaint","selectionLayer","_getSelectionLayerNameFromType","selectedLayout","_addEventsListeners","propertiesFilter","filters","_filterProperties","_updatePropertiesFilter","removeFilter","_updateFilter","select","properties","_selectProperties","unselect","removeLayer","forEach","layerId","_updateWithNativeFilter","filter","nativeFilter","name","layout","minZoom","maxZoom","mType","layerOpt","id","visibility","_getAdditionalLayerOptions","minzoom","maxzoom","x","setFilter","sourceId","_updateLayerPaint","layerName","layers","selName","_paint","nativePaint","_createPaintForType","p","setLayoutProperty","setPaintProperty","mapboxPaint","html","_registerImage","allowed","allowedType","find","Array","isArray","paramName","duration","_getFeatureFilterId","feature","_featureFilterId","hasImage","iconSize","svgStr","Promise","resolve","Image","crossOrigin","src","btoa","onload","imageData","image","addImage","_selectFeature","_unselectFeature","selLayerName","selectProperties","filterProperties","propertyFilters","_convertToMapboxFilter","reverse","_operationsAliases","field","operation","value","operationAlias","isFeatureSelected","filterId","e","preventDefault","reduce","b","features_","queryRenderedFeatures","point","isSelected","unselectOnSecondClick","onLayerClick","falsePaint","selectable","on","getCanvas","style","cursor","BaseAdapter","MvtAdapter","sources","includes","url","addSource","tiles","sourceLayer","subdomains","split","replace","headers","transformRequests","resourceType","staticUrl","sourceOptions","tileSize","attribution","layerOptions","before","OPTIONS","Object","assign","TileAdapter","showCompass","_createButton","className","ariaLabel","fn","element","alias","label","title","showZoom","_features","_sources","data","addData","getSource","removeSource","clearLayer","cb","features","setData","detectedType","geojson","f","geometries","g","detectType","filterGeometries","fid","_filterFun","_filter","getLayers","filtered","_filteredFeatureIds","_getFeatures","visible","fun","getSelected","_getPaintFromCallback","selectedFeatureIds","multiselect","index","splice","selectionArray","filteredArray","filter_","_data","ok","newFeatures","geomCollection","toSave","createControl","control","getDefaultPosition","onAdd","content","classList","add","bar","addClass","appendChild","_container","onRemove","parentNode","removeChild","remove","fitBoundsOptions","emitter","layerAdapters","MapboxglMapAdapter","controlAdapters","isLoaded","_universalEvents","_sourceDataLoading","__setLayerOrder","_setLayerOrder","create","reject","accessToken","target","mapOpt","container","attributionControl","bounds","fitOptions","transformRequest","transformed","_transformRequest","version","center","zoom","once","emit","destroy","getContainer","setView","jumpTo","setCenter","latLng","getCenter","lng","lat","setZoom","getZoom","fitBounds","fitBoundOptions","linear","setRotation","angle","showLayer","layerIds","_toggleLayer","hideLayer","_map","setLayerOrder","order","setLayerOpacity","_onMapLoad","then","getLayer","createButtonControl","link","HTMLElement","innerHTML","child","firstElementChild","lineHeight","offsetHeight","onClick","stopPropagation","addEventListener","parent","removeEventListener","addControl","position","removeControl","onMapClick","evt","lngLat","y","pixel","top","left","_resolve","baseLayers","orderedLayers","l","baseLayer","moveLayer","sort","mem","_getLayerIds","_layers","getDependLayers","status","_onMapSourceData","dataType","isSourceLoaded","_onDataLoad","_onMapError","keys","tile","params","r","TILE","MVT","OSM","OsmAdapter","GEOJSON","ZOOM","ZoomControl","COMPASS","CompassControl","ATTRIBUTION","AttributionControl","svgPath","brill","rect","marker","cross","star","triangle","plus","minus","asterisk","getIcon","shape","strokeColor","size","anchor","stroke","scale","pathAlias","svg","s","DOMParser","parseFromString","documentElement","insertSvg","fistChild","firstChild","transform","iconAnchor","XMLSerializer","serializeToString","filterIn","item","filterFunc","relationFunc","_filtered","children","relChild","events","_children","setParent","_parent","addChild","getParent","getParents","tree","getRoot","toReturn","getChildren","all","getDescendants","EventEmitter","_blocked","_value","getProperty","call","isGroup","isBlocked","parents","parentProp","property","get","set","_prepareValue","update","_fireChangeEvent","getValue","_callOnSet","_removeEventsListener","onSet","prop","CheckProperty","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","getHierarchyValue","every","turnOff","hierarchy","blockChilds","turnOn","unblockChilds","block","_block","_unBlock","_blockChild","_unBlockChild","BaseProperty","propertiesList","_properties","_propertiesList","_setPropertyHandler","propOpt","handlers","ItemProperties","handler","list","initProperties"],"mappings":"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","file":"main~f075b844-65fc1e3.js","sourcesContent":["let canvg: any;\ntry {\n  canvg = require('canvg');\n} catch (er) {\n  // ignore\n}\ninterface GetImgOpt {\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  sdf?: string;\n  pixelRatio?: number;\n}\n\n// const defAddImgOpt = {\n//   width: 12,\n//   height: 12,\n//   x: 0,\n//   y: 0,\n//   sdf: undefined,\n//   pixelRatio: 2\n// };\n\n// // from /mapbox-gl/src/util/browser.js\nexport function getImageData(\n  img: string | HTMLImageElement,\n  opt: GetImgOpt\n): ImageData {\n  const canvas = window.document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('failed to create canvas 2d context');\n  }\n  canvas.setAttribute('width', String(opt.width));\n  canvas.setAttribute('height', String(opt.height));\n  if (!canvg && img instanceof HTMLImageElement) {\n    context.drawImage(img, 0, 0, opt.width, opt.height);\n  } else if (typeof img === 'string') {\n    if (canvg.Canvg) {\n      // for canvg v.3.x.x\n      const v = canvg.Canvg.fromString(context, img);\n      v.start();\n    } else {\n      // for canvg v.2.x.x\n      canvg(canvas, img);\n    }\n  }\n  return context.getImageData(0, 0, opt.width, opt.height);\n}\n\nexport function getImage(svgStr: string, opt: GetImgOpt): Promise<ImageData> {\n  return new Promise(resolve => {\n    if (canvg) {\n      resolve(getImageData(svgStr, opt));\n    } else {\n      const svgImage = new Image();\n      svgImage.crossOrigin = 'Anonymous';\n      svgImage.src = 'data:image/svg+xml;base64,' + btoa(svgStr);\n\n      svgImage.onload = () => {\n        const imageData = getImageData(svgImage, opt);\n        resolve(imageData);\n      };\n    }\n  });\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map } from 'mapbox-gl';\nimport { BaseLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\nexport abstract class BaseAdapter<O extends AdapterOptions = AdapterOptions>\n  implements BaseLayerAdapter<Map, TLayer, O> {\n  layer?: TLayer;\n  protected readonly _layerId: string;\n\n  constructor(public map: Map, public options: O) {\n    this._layerId = `layer-${ID++}`;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  abstract addLayer(options: O): TLayer | Promise<TLayer> | undefined;\n}\n","import {\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  FeatureCollection,\n  Feature,\n  GeometryCollection\n} from 'geojson';\nimport { VectorAdapterLayerType } from '@nextgis/webmap';\n\nexport const allowedParams: ([string, string] | string)[] = [\n  'color',\n  'opacity'\n];\nexport const allowedByType = {\n  circle: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity'],\n    ['strokeColor', 'stroke-color'],\n    ['strokeOpacity', 'stroke-opacity'],\n    ['weight', 'stroke-width'],\n    'radius'\n  ],\n  line: [\n    ['strokeColor', 'color'],\n    ['strokeOpacity', 'opacity'],\n    ['weight', 'width']\n  ],\n  fill: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity']\n  ],\n  icon: allowedParams.concat([])\n};\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'circle',\n  LineString: 'line',\n  MultiPoint: 'circle',\n  Polygon: 'fill',\n  MultiLineString: 'line',\n  MultiPolygon: 'fill',\n  GeometryCollection: 'fill'\n};\n\nexport const typeAliasForFilter: {\n  [key in VectorAdapterLayerType]: GeoJsonGeometryTypes;\n} = {\n  circle: 'Point',\n  line: 'LineString',\n  fill: 'Polygon',\n  icon: 'Point'\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {\n  icon: ['Point']\n};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[]\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      f => f.geometry.type\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      g => g.type\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n\n// Static functions\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType\n): boolean {\n  const backType = backAliases[type];\n  if (backType) {\n    return backType.indexOf(geometry) !== -1;\n  }\n  return false;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  IconOptions,\n  VectorLayerAdapter,\n  VectorAdapterOptions,\n  PropertiesFilter,\n  Operations,\n  DataLayerFilter,\n  PropertyFilter,\n  FilterOptions,\n  checkIfPropertyFilter\n} from '@nextgis/webmap';\nimport {\n  Feature as F,\n  GeometryObject,\n  Geometry,\n  GeoJsonProperties\n} from 'geojson';\nimport {\n  Map,\n  MapLayerMouseEvent,\n  AnySourceData,\n  AnyLayout,\n  Layer,\n  MapboxGeoJSONFeature\n  // BackgroundPaint, FillPaint, FillExtrusionPaint, LinePaint, SymbolPaint,\n  // RasterPaint, CirclePaint, HeatmapPaint, HillshadePaint,\n} from 'mapbox-gl';\n\n// type MapboxPaint = BackgroundPaint | FillPaint | FillExtrusionPaint | LinePaint | SymbolPaint |\n//   RasterPaint | CirclePaint | HeatmapPaint | HillshadePaint;\n\nimport { getImage } from '../util/image_icons';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { BaseAdapter } from './BaseAdapter';\nimport { typeAliasForFilter, allowedByType } from '../util/geom_type';\n\nexport const operationsAliases: { [key in Operations]: string } = {\n  gt: '>',\n  lt: '<',\n  ge: '>=',\n  le: '<=',\n  eq: '==',\n  ne: '!=',\n  in: 'in',\n  notin: '!in',\n  // NOT SUPPORTED\n  like: '==',\n  // NOT SUPPORTED\n  ilike: '=='\n};\n\nconst reversOperations: { [key in Operations]: string } = {\n  gt: operationsAliases.le,\n  lt: operationsAliases.ge,\n  ge: operationsAliases.lt,\n  le: operationsAliases.gt,\n  eq: operationsAliases.ne,\n  ne: operationsAliases.eq,\n  in: operationsAliases.notin,\n  notin: operationsAliases.in,\n  like: operationsAliases.ne,\n  ilike: operationsAliases.ne\n};\n\nexport interface Feature<\n  G extends GeometryObject | null = Geometry,\n  P = GeoJsonProperties\n> extends F<G, P> {\n  _featureFilterId?: string;\n}\n\nconst PAINT = {\n  color: 'blue',\n  opacity: 1,\n  radius: 10\n};\n\ntype MapboxLayerType = 'fill' | 'line' | 'symbol' | 'circle';\n\nexport abstract class VectorAdapter<\n  O extends VectorAdapterOptions = VectorAdapterOptions\n> extends BaseAdapter<O>\n  implements VectorLayerAdapter<Map, TLayer, O, Feature> {\n  selected = false;\n\n  protected featureIdName = 'id';\n  protected _types: VectorAdapterLayerType[] = ['fill', 'circle', 'line'];\n  protected readonly _sourceId: string;\n  protected readonly _selectionName: string;\n  protected _selectedFeatureIds: (number | string)[] | false = [];\n\n  protected _selectProperties?: PropertiesFilter;\n  protected _filterProperties?: PropertiesFilter;\n\n  private $onLayerClick?: (e: MapLayerMouseEvent) => void;\n\n  constructor(public map: Map, public options: O) {\n    super(map, options);\n    this._sourceId = this.options.source\n      ? (this.options.source as string)\n      : `source-${this._layerId}`;\n\n    if (this.options.featureIdName) {\n      this.featureIdName = this.options.featureIdName;\n    } else if (this.options.source) {\n      this.featureIdName = '$id';\n    } else {\n      this.featureIdName = '_fid';\n    }\n\n    this._selectionName = this._layerId + '-highlighted';\n    this.$onLayerClick = this._onLayerClick.bind(this);\n  }\n\n  async addLayer(options: O): Promise<TLayer> {\n    options = this.options = { ...this.options, ...(options || {}) };\n\n    this.layer = [];\n    const types = (this._types = options.type ? [options.type] : this._types);\n    if (options.paint) {\n      this._onAddLayer(this._sourceId);\n      // const types = this._types;\n      for (const t of types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          let type = t;\n          if (t === 'circle') {\n            const paintType = this._detectPaintType(options.paint);\n            if (paintType === 'icon') {\n              type = 'icon';\n            }\n          }\n          const layer = this._getLayerNameFromType(t);\n          const geomFilter =\n            types.length > 1 ? ['==', '$type', geomType] : undefined;\n\n          await this._addLayer(layer, type, [\n            geomFilter,\n            this._getNativeFilter()\n          ]);\n          this.layer.push(layer);\n          if (options.selectedPaint) {\n            const selectionLayer = this._getSelectionLayerNameFromType(t);\n            await this._addLayer(\n              selectionLayer,\n              type,\n              [geomFilter, ['in', this.featureIdName, '']],\n              this.options.selectedLayout\n            );\n            this.layer.push(selectionLayer);\n          }\n        }\n      }\n    }\n\n    this._addEventsListeners();\n\n    return this.layer;\n  }\n\n  propertiesFilter(filters: PropertiesFilter, options?: FilterOptions) {\n    this._filterProperties = filters;\n    this._updatePropertiesFilter();\n  }\n\n  removeFilter() {\n    this._filterProperties = undefined;\n    this._updateFilter();\n  }\n\n  select(properties?: DataLayerFilter<F, TLayer> | PropertiesFilter) {\n    if (typeof properties !== 'function') {\n      this._selectProperties = properties;\n      this._updateFilter();\n    }\n    this.selected = true;\n  }\n\n  unselect() {\n    this._selectProperties = undefined;\n    this._updateFilter();\n    this.selected = false;\n  }\n\n  removeLayer() {\n    const map = this.map;\n    if (this.layer) {\n      this.layer.forEach(layerId => {\n        map.removeLayer(layerId);\n      });\n    }\n  }\n\n  protected _updateWithNativeFilter(filter: any[]) {\n    const nativeFilter = this._getNativeFilter();\n    if (nativeFilter.length) {\n      filter.push(nativeFilter);\n    }\n    return filter;\n  }\n\n  protected _getNativeFilter() {\n    return (this.options.nativeFilter\n      ? this.options.nativeFilter\n      : []) as PropertyFilter;\n  }\n\n  protected async _addLayer(\n    name: string,\n    type: VectorAdapterLayerType,\n    filter?: any[],\n    layout?: AnyLayout\n  ) {\n    const { minZoom, maxZoom } = this.options;\n    let mType: MapboxLayerType;\n    if (type === 'icon') {\n      mType = 'symbol';\n    } else {\n      mType = type;\n    }\n    layout = (layout || this.options.layout || {}) as AnyLayout;\n    const layerOpt: Layer = {\n      id: name,\n      type: mType,\n      source: this._sourceId,\n      layout: {\n        visibility: 'none',\n        ...layout\n      },\n      ...this._getAdditionalLayerOptions()\n    };\n    if (minZoom) {\n      layerOpt.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOpt.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(layerOpt);\n\n    const filters = ['all', ...(filter || [])].filter(x => x);\n    if (filters.length > 1) {\n      this.map.setFilter(layerOpt.id, filters);\n    }\n  }\n\n  protected _onAddLayer(sourceId: string, options?: AnySourceData) {\n    // ignore\n  }\n\n  protected async _updateLayerPaint(type: VectorAdapterLayerType) {\n    const layerName = this._getLayerNameFromType(type);\n\n    if (this.options.paint) {\n      const layers: [string, VectorAdapterLayerPaint | GetPaintCallback][] = [\n        [layerName, this.options.paint]\n      ];\n      if (this.options.selectedPaint) {\n        const selName = this._getSelectionLayerNameFromType(type);\n        layers.push([selName, this.options.selectedPaint]);\n      }\n\n      for (const [name, paint] of layers) {\n        let _paint: any;\n        if (this.options.nativePaint) {\n          _paint =\n            typeof this.options.nativePaint === 'boolean'\n              ? paint\n              : this.options.nativePaint;\n        } else {\n          _paint = await this._createPaintForType(paint, type, name);\n        }\n\n        if ('icon-image' in _paint) {\n          // If true, the icon will be visible even if it collides with other previously drawn symbols.\n          _paint['icon-allow-overlap'] = true;\n          for (const p in _paint) {\n            this.map.setLayoutProperty(name, p, _paint[p]);\n          }\n        } else {\n          for (const p in _paint) {\n            this.map.setPaintProperty(name, p, _paint[p]);\n          }\n        }\n      }\n    }\n  }\n\n  protected _getLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._layerId;\n  }\n\n  protected _getSelectionLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._selectionName;\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name?: string\n  ): Promise<any> {\n    if (typeof paint !== 'function') {\n      const mapboxPaint: any = {};\n      const _paint = { ...PAINT, ...(paint || {}) };\n      if (paint.type === 'icon' && paint.html) {\n        await this._registerImage(paint);\n        return {\n          'icon-image': paint.html\n        };\n      } else {\n        for (const p in _paint) {\n          const allowed = allowedByType[type];\n          if (allowed) {\n            const allowedType = allowed.find(x => {\n              if (typeof x === 'string') {\n                return x === p;\n              } else if (Array.isArray(x)) {\n                return x[0] === p;\n              }\n              return false;\n            });\n            if (allowedType) {\n              const paramName = Array.isArray(allowedType)\n                ? allowedType[1]\n                : allowedType;\n              // @ts-ignore\n              mapboxPaint[type + '-' + paramName] = _paint[p];\n            }\n          }\n        }\n        mapboxPaint[type + '-opacity-transition'] = { duration: 0 };\n        return mapboxPaint;\n      }\n    }\n  }\n\n  protected _getFeatureFilterId(feature: Feature): string | number | undefined {\n    // @ts-ignore\n    const id = feature._featureFilterId;\n    if (id !== undefined) {\n      return id;\n    } else if (\n      feature.properties &&\n      feature.properties[this.featureIdName] !== undefined\n    ) {\n      return feature.properties[this.featureIdName];\n    }\n    return feature.id;\n  }\n\n  protected async _registerImage(paint: IconOptions) {\n    if (paint.html) {\n      const imageExist = this.map.hasImage(paint.html);\n      if (!imageExist) {\n        let width = 12;\n        let height = 12;\n        if (paint.iconSize) {\n          width = paint.iconSize[0];\n          height = paint.iconSize[1];\n        }\n        const image = await getImage(paint.html, {\n          width,\n          height\n        });\n\n        this.map.addImage(paint.html, image);\n      }\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _unselectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _getAdditionalLayerOptions() {\n    return {};\n  }\n\n  protected _updateFilter() {\n    this._updatePropertiesFilter();\n  }\n\n  protected _updatePropertiesFilter() {\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          const selectProperties = this._selectProperties;\n          const filterProperties = this._filterProperties;\n          const propertyFilters =\n            filterProperties && this._convertToMapboxFilter(filterProperties);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              let filters: any[] = [];\n              if (selectProperties || this._selectedFeatureIds) {\n                if (selectProperties) {\n                  filters = this._convertToMapboxFilter(selectProperties) || [];\n                } else if (this._selectedFeatureIds) {\n                  filters = [\n                    ['in', this.featureIdName, ...this._selectedFeatureIds]\n                  ];\n                }\n                if (propertyFilters) {\n                  propertyFilters.forEach(x => filters.push(x));\n                }\n                this.map.setFilter(selLayerName, [\n                  'all',\n                  geomFilter,\n                  ...filters\n                ]);\n              } else {\n                filters = ['in', '$id', ''];\n                this.map.setFilter(selLayerName, filters);\n              }\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filters_: any[] = ['all', geomFilter];\n            this._updateWithNativeFilter(filters_);\n            if (selectProperties) {\n              const selectFilters = this._convertToMapboxFilter(\n                selectProperties,\n                true\n              );\n              selectFilters.forEach(x => filters_.push(x));\n            } else if (this._selectedFeatureIds) {\n              filters_.push([\n                '!in',\n                this.featureIdName,\n                ...this._selectedFeatureIds\n              ]);\n            }\n            if (propertyFilters) {\n              propertyFilters.forEach(x => filters_.push(x));\n            }\n            this.map.setFilter(layerName, filters_);\n          }\n        }\n      });\n    }\n  }\n\n  protected _convertToMapboxFilter(filters: PropertiesFilter, reverse = false) {\n    const _operationsAliases = reverse ? reversOperations : operationsAliases;\n    const filter = filters.map(x => {\n      if (typeof x === 'string') {\n        return x;\n      } else if (checkIfPropertyFilter(x)) {\n        const [field, operation, value] = x;\n        const operationAlias = _operationsAliases[operation];\n        if (operation === 'in' || operation === 'notin') {\n          return [operationAlias, field, ...value];\n        }\n        return [operationAlias, field, value];\n      }\n    });\n    return filter;\n  }\n\n  protected isFeatureSelected(feature: Feature) {\n    if (this._selectedFeatureIds) {\n      const filterId = this._getFeatureFilterId(feature);\n      if (filterId) {\n        return this._selectedFeatureIds.indexOf(filterId) !== -1;\n      }\n    }\n    return false;\n  }\n\n  private _onLayerClick(e: MapLayerMouseEvent) {\n    e.preventDefault();\n    // const features = this.map.queryRenderedFeatures(e.point, {\n    //   layers: this.layer\n    // });\n    if (this.layer) {\n      const features = this.layer.reduce((a, b) => {\n        const features_ = this.map.queryRenderedFeatures(e.point, {\n          layers: [b]\n        });\n        const c = a.concat(features_);\n        return c;\n      }, [] as MapboxGeoJSONFeature[]);\n      const feature = features[0] as Feature;\n      if (feature) {\n        let isSelected = this.isFeatureSelected(feature);\n        if (isSelected) {\n          if (this.options && this.options.unselectOnSecondClick) {\n            this._unselectFeature(feature);\n          }\n        } else {\n          this._selectFeature(feature);\n        }\n        isSelected = this.isFeatureSelected(feature);\n        if (this.options.onLayerClick) {\n          this.options.onLayerClick({\n            layer: this,\n            feature,\n            selected: isSelected\n          });\n        }\n      }\n    }\n  }\n\n  private _detectPaintType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback\n  ): string | undefined {\n    if ('type' in paint) {\n      return paint.type;\n    } else if (typeof paint === 'function') {\n      try {\n        const falsePaint = paint({\n          type: 'Feature',\n          properties: {},\n          geometry: {} as Geometry\n        });\n        return this._detectPaintType(falsePaint);\n      } catch (er) {\n        //\n      }\n    }\n  }\n\n  private _addEventsListeners() {\n    if (this.layer && this.options && this.options.selectable) {\n      this.layer.forEach(x => {\n        if (this.$onLayerClick) {\n          const onLayerClick = this.$onLayerClick;\n          this.map.on('click', x, (e: MapLayerMouseEvent) => {\n            onLayerClick(e);\n          });\n        }\n\n        this.map.on('mousemove', x, () => {\n          this.map.getCanvas().style.cursor = 'pointer';\n        });\n        this.map.on('mouseleave', x, () => {\n          this.map.getCanvas().style.cursor = '';\n        });\n      });\n    }\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { MvtAdapterOptions } from '@nextgis/webmap';\nimport { VectorAdapter } from './VectorAdapter';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nexport class MvtAdapter extends VectorAdapter<MvtAdapterOptions> {\n  static sources: string[] = [];\n\n  source?: string;\n\n  async addLayer(options: MvtAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    this._updateLayerPaint(this.options.type || 'fill');\n\n    return layer;\n  }\n\n  protected _getAdditionalLayerOptions() {\n    const exist = MvtAdapter.sources.includes(this.options.url);\n    if (!exist) {\n      this.map.addSource(this.options.url, {\n        type: 'vector',\n        tiles: [this.options.url]\n      });\n      this.source = this.options.url;\n      MvtAdapter.sources.push(this.options.url);\n    }\n    const mvtLayerOptions: Partial<mapboxgl.Layer> = {\n      source: this.options.url,\n      'source-layer': this.options.sourceLayer\n    };\n    return mvtLayerOptions;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { BaseAdapter } from './BaseAdapter';\nimport { RasterSource, ResourceType, Layer } from 'mapbox-gl';\n\nexport class TileAdapter extends BaseAdapter<TileAdapterOptions>\n  implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    options = { ...this.options, ...(options || {}) };\n    const { minZoom, maxZoom } = options;\n    let tiles: string[];\n    if (options && options.subdomains) {\n      tiles = options.subdomains.split('').map(x => {\n        const subUrl = options.url.replace('{s}', x);\n        return subUrl;\n      });\n    } else {\n      tiles = [options.url];\n    }\n    if (options.headers) {\n      // @ts-ignore\n      const transformRequests = this.map.transformRequests;\n      transformRequests.push((url: string, resourceType: ResourceType) => {\n        let staticUrl = url;\n        staticUrl = staticUrl.replace(/(z=\\d+)/, 'z={z}');\n        staticUrl = staticUrl.replace(/(x=\\d+)/, 'x={x}');\n        staticUrl = staticUrl.replace(/(y=\\d+)/, 'y={y}');\n        if (staticUrl === options.url) {\n          return {\n            url,\n            headers: options.headers\n          };\n        }\n      });\n    }\n\n    const sourceOptions: RasterSource = {\n      type: 'raster',\n      // point to our third-party tiles. Note that some examples\n      // show a \"url\" property. This only applies to tilesets with\n      // corresponding TileJSON (such as mapbox tiles).\n      tiles,\n      tileSize: 256 // opt && opt.tileSize ||\n    };\n    if (options.attribution) {\n      sourceOptions.attribution = options.attribution;\n    }\n    const layerOptions: Layer = {\n      id: this._layerId,\n      type: 'raster',\n      layout: {\n        visibility: 'none'\n      },\n      source: sourceOptions\n      // TODO: clean remove before options from all existing apps\n    };\n\n    if (minZoom) {\n      layerOptions.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOptions.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(\n      layerOptions,\n      // @ts-ignore\n      options.before\n    );\n    const layer = (this.layer = [this._layerId]);\n    return layer;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileAdapter } from './TileAdapter';\n\nconst OPTIONS = {\n  url: 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n  attribution:\n    '&copy; <a href=\"http://osm.org/copyright\" target=\"_blank\">OpenStreetMap</a> contributors',\n  subdomains: 'abc'\n};\n\nexport class OsmAdapter extends TileAdapter implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    return super.addLayer(Object.assign({}, OPTIONS, options));\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\nimport { ZoomControlOptions } from '@nextgis/webmap';\n\nexport class ZoomControl extends NavigationControl {\n  options: ZoomControlOptions & any;\n\n  constructor(options: ZoomControlOptions & any = {}) {\n    options = { ...options, showCompass: false };\n    super(options);\n  }\n\n  _createButton(className: string, ariaLabel: string, fn: () => any) {\n    // @ts-ignore\n    const element = super._createButton(className, ariaLabel, fn);\n    const aliases: any = {\n      'Zoom in': 'zoomInTitle',\n      'Zoom out': 'zoomOutTitle'\n    };\n    const alias = aliases[ariaLabel];\n    const label = alias && this.options[alias];\n    if (label) {\n      element.title = label;\n      element.setAttribute('aria-label', label);\n    }\n\n    return element;\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\n\nexport class CompassControl extends NavigationControl {\n  constructor(options = {}) {\n    options = Object.assign({}, options, { showZoom: false });\n    super(options);\n  }\n}\n","// import { MapControl } from '@nextgis/webmap';\nimport { AttributionControl as AC } from 'mapbox-gl';\n\nexport class AttributionControl extends AC {}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map, GeoJSONSource, GeoJSONSourceRaw } from 'mapbox-gl';\nimport {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  DataLayerFilter,\n  LayerDefinition,\n  PropertiesFilter\n} from '@nextgis/webmap';\nimport { featureFilter } from '@nextgis/utils';\nimport {\n  GeoJsonObject,\n  FeatureCollection,\n  GeometryCollection,\n  GeometryObject\n} from 'geojson';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { VectorAdapter, Feature } from './VectorAdapter';\nimport {\n  detectType,\n  typeAlias,\n  typeAliasForFilter,\n  geometryFilter\n} from '../util/geom_type';\n\nlet ID = 0;\n\nexport class GeoJsonAdapter extends VectorAdapter<GeoJsonAdapterOptions> {\n  selected = false;\n  source?: string;\n  private _features: Feature[] = [];\n  private _filteredFeatureIds?: (string | number)[] | undefined;\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _sources: Record<string, GeoJSONSource> = {};\n\n  constructor(public map: Map, public options: GeoJsonAdapterOptions) {\n    super(map, options);\n    this.source = this._sourceId;\n  }\n\n  async addLayer(options: GeoJsonAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    if (this.options.data) {\n      this.addData(this.options.data);\n    }\n    return layer;\n  }\n\n  removeLayer() {\n    super.removeLayer();\n    const source = this.map.getSource(this._sourceId);\n    if (source) {\n      this.map.removeSource(this._sourceId);\n    }\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean) {\n    let features: Feature[] = [];\n    const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n    if (cb) {\n      features = this._features = this._features.filter(x => !cb(x));\n    }\n    source.setData({ type: 'FeatureCollection', features });\n  }\n\n  async addData(data: GeoJsonObject) {\n    let type: VectorAdapterLayerType | undefined;\n    if (this.options.type) {\n      type = this.options.type;\n    }\n    if (!type && data) {\n      const detectedType = detectType(data);\n      type = typeAlias[detectedType];\n    }\n    if (data && type) {\n      const features = this.filterGeometries(data, type);\n      features.forEach(x => {\n        // to avoid id = 0 is false\n        const fid = '_' + ID++;\n        x._featureFilterId = fid;\n        if (x.properties) {\n          x.properties[this.featureIdName] = fid;\n        }\n      });\n      if (this._filterFun) {\n        this._filter(this._filterFun);\n      }\n      await this._updateLayerPaint(type);\n      const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n      source.setData({ type: 'FeatureCollection', features: this._features });\n    }\n  }\n\n  getLayers() {\n    const filtered = this._filteredFeatureIds;\n    const filterProperties = this._filterProperties;\n    if (filterProperties) {\n      this._updateWithNativeFilter(filterProperties);\n    }\n    return this._getFeatures().map(feature => {\n      let visible = false;\n      if (filterProperties && feature.properties) {\n        visible = featureFilter(feature, filterProperties);\n      } else if (filtered) {\n        const id = this._getFeatureFilterId(feature);\n        if (id !== undefined) {\n          visible = filtered.indexOf(id) !== -1;\n        }\n      }\n      return {\n        feature,\n        visible\n      };\n    });\n  }\n\n  filter(fun: DataLayerFilter<Feature, TLayer>) {\n    this._filterFun = fun;\n    this._filter(fun);\n  }\n\n  removeFilter() {\n    this._filterFun = undefined;\n    this._filteredFeatureIds = undefined;\n    this._updateFilter();\n  }\n\n  getSelected() {\n    const features: LayerDefinition<Feature, TLayer>[] = [];\n    this._getFeatures().forEach(x => {\n      const id = this._getFeatureFilterId(x);\n      if (\n        id &&\n        this._selectedFeatureIds &&\n        this._selectedFeatureIds.indexOf(id) !== -1\n      ) {\n        features.push({ feature: x });\n      }\n    });\n    return features;\n  }\n\n  select(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter(x => find({ feature: x }));\n        this._selectFeature(features);\n      } else {\n        this.selected = true;\n        this._selectProperties = find;\n        super._updateFilter();\n      }\n    } else if (!this.selected) {\n      this._selectFeature(this._getFeatures());\n    }\n  }\n\n  unselect(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    this._selectProperties = undefined;\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter(x => find({ feature: x }));\n        this._unselectFeature(features);\n        this.selected = Array.isArray(this._selectedFeatureIds) ? true : false;\n      }\n    } else if (this.selected) {\n      this.selected = false;\n      this._unselectFeature();\n    }\n  }\n\n  protected _onAddLayer(sourceId: string) {\n    let source = this.map.getSource(sourceId) as GeoJSONSource;\n    if (!source) {\n      const sourceOpt: GeoJSONSourceRaw = {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features: []\n        }\n      };\n      const _opts: (keyof GeoJsonAdapterOptions)[] = [\n        'cluster',\n        'clusterMaxZoom',\n        'clusterRadius'\n      ];\n      _opts.forEach(x => {\n        const opt = this.options[x] as GeoJsonAdapterOptions;\n        if (opt !== undefined) {\n          //@ts-ignore\n          sourceOpt[x] = opt;\n        }\n      });\n      this.map.addSource(sourceId, sourceOpt);\n      source = this.map.getSource(sourceId) as GeoJSONSource;\n    }\n    this._sources[sourceId] = source;\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ): Promise<any> {\n    if (typeof paint === 'function') {\n      return await this._getPaintFromCallback(paint, type, name);\n    } else {\n      return super._createPaintForType(paint, type, name);\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    let selectedFeatureIds = this._selectedFeatureIds || [];\n    if (this.options && !this.options.multiselect) {\n      selectedFeatureIds = [];\n    }\n    let features: Feature[] = [];\n    if (Array.isArray(feature)) {\n      features = feature;\n    } else {\n      features = [feature];\n    }\n    features.forEach(f => {\n      const id = this._getFeatureFilterId(f);\n      if (id !== undefined) {\n        selectedFeatureIds.push(id);\n      }\n    });\n    this._selectedFeatureIds = selectedFeatureIds;\n    this._updateFilter();\n  }\n\n  protected _unselectFeature(feature?: Feature | Feature[]) {\n    if (feature) {\n      let features: Feature[] = [];\n      if (Array.isArray(feature)) {\n        features = feature;\n      } else {\n        features = [feature];\n      }\n      if (features.length) {\n        features.forEach(f => {\n          const id = this._getFeatureFilterId(f);\n          const selected = this._selectedFeatureIds;\n          if (selected && id !== undefined) {\n            const index = selected.indexOf(id);\n            if (index !== -1) {\n              selected.splice(index, 1);\n            }\n          }\n        });\n      }\n    } else {\n      this._selectedFeatureIds = false;\n    }\n    this._updateFilter();\n  }\n\n  protected _updateFilter() {\n    // it is not yet possible to use callbacks and properties filters together\n    if (this._filterProperties || this._selectProperties) {\n      return super._updateFilter();\n    }\n    const selected = this._selectedFeatureIds;\n    let selectionArray: (string | number)[] = [];\n    const filteredArray: (string | number)[] = [];\n    const filtered = this._filteredFeatureIds;\n    if (filtered) {\n      this._getFeatures().forEach(x => {\n        const id = this._getFeatureFilterId(x);\n        if (id !== undefined && filtered.indexOf(id) !== -1) {\n          if (selected && selected.indexOf(id) !== -1) {\n            selectionArray.push(id);\n          } else {\n            filteredArray.push(id);\n          }\n        }\n      });\n    } else if (selected) {\n      selectionArray = selected;\n    }\n    this.selected = !!selected;\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              this.map.setFilter(selLayerName, [\n                'all',\n                geomFilter,\n                ['in', this.featureIdName, ...selectionArray]\n              ]);\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filter_: any[] = ['all', geomFilter];\n            if (filtered) {\n              filter_.push(['in', this.featureIdName, ...filteredArray]);\n            } else {\n              filter_.push(['!in', this.featureIdName, ...selectionArray]);\n              this._updateWithNativeFilter(filter_);\n            }\n            this.map.setFilter(layerName, filter_);\n          }\n        }\n      });\n    }\n  }\n\n  private _getFeatures(): Feature[] {\n    if (this.source) {\n      // const features = this.map.querySourceFeatures(this.source);\n      // return features;\n\n      const source = this.map.getSource(this.source);\n      if (source) {\n        // @ts-ignore\n        return source._data?.features || [];\n      }\n    }\n    return this._features;\n  }\n\n  private _filter(fun: DataLayerFilter<Feature, TLayer>) {\n    const filtered: (string | number)[] = [];\n    this._getFeatures().forEach(feature => {\n      const ok = fun({ feature });\n      const id = this._getFeatureFilterId(feature);\n      if (ok && id) {\n        filtered.push(id);\n      }\n    });\n    this._filteredFeatureIds = filtered;\n    this._updateFilter();\n  }\n\n  private filterGeometries(\n    data: GeoJsonObject,\n    type: VectorAdapterLayerType\n  ): Feature[] {\n    let newFeatures: Feature[] = [];\n    if (data.type === 'FeatureCollection') {\n      const features = (data as FeatureCollection).features.filter(f =>\n        geometryFilter(f.geometry.type, type)\n      ) as Feature[];\n      (data as FeatureCollection).features = features;\n      newFeatures = features;\n    } else if (data.type === 'Feature') {\n      const allow = geometryFilter((data as Feature).geometry.type, type);\n      if (!allow) {\n        return [];\n      }\n      newFeatures.push(data as Feature);\n    } else if (data.type === 'GeometryCollection') {\n      const geomCollection = data as GeometryCollection;\n      geomCollection.geometries = geomCollection.geometries.filter(g =>\n        geometryFilter(g.type, type)\n      );\n      newFeatures = geomCollection.geometries.map(x => {\n        const f: Feature = {\n          type: 'Feature',\n          geometry: x as GeometryObject,\n          properties: {}\n        };\n        return f;\n      });\n    } else if (typeAlias[data.type]) {\n      const obj: Feature = {\n        type: 'Feature',\n        geometry: data as GeometryObject,\n        properties: {}\n      };\n      newFeatures = [obj];\n    }\n    this._features = this._features.concat(newFeatures);\n    return newFeatures;\n  }\n\n  private async _getPaintFromCallback(\n    paint: GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ) {\n    const style: any = {};\n    for (const feature of this._features) {\n      const _paint = paint(feature);\n      if (_paint.type === 'icon') {\n        await this._registerImage(_paint);\n        if (feature.properties) {\n          feature.properties['_icon-image-' + name] = _paint.html;\n        }\n        style['icon-image'] = `{_icon-image-${name}}`;\n      } else {\n        for (const p in _paint) {\n          // @ts-ignore\n          const toSave = _paint[p];\n          if (feature.properties) {\n            feature.properties[`_paint_${p}_${name}`] = toSave;\n          }\n          style[p] = ['get', `_paint_${p}_${name}`];\n        }\n      }\n    }\n    if ('icon-image' in style) {\n      return style;\n    }\n    const styleFromCb = this._createPaintForType(style, type, name);\n    return styleFromCb;\n  }\n}\n","import { MapControl, CreateControlOptions } from '@nextgis/webmap';\nimport { IControl } from 'mapbox-gl';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {}\n): IControl {\n  class Control implements IControl {\n    private _container?: HTMLElement;\n\n    getDefaultPosition() {\n      return 'top-left';\n    }\n\n    onAdd() {\n      const element = document.createElement('div');\n      const content: HTMLElement = control.onAdd();\n      element.classList.add('mapboxgl-ctrl');\n      if (options.bar) {\n        // add custom css for boarder style\n        element.classList.add('mapboxgl-bar');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      element.appendChild(content);\n      this._container = element;\n      return this._container;\n    }\n\n    onRemove() {\n      if (this._container) {\n        const parent = this._container.parentNode;\n        if (parent) {\n          parent.removeChild(this._container);\n        }\n      }\n      return control.onRemove();\n    }\n\n    remove() {\n      this.onRemove();\n    }\n  }\n\n  return new Control();\n  // return control;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  MapAdapter,\n  FitOptions,\n  MapControl,\n  ControlPositions,\n  ButtonControlOptions,\n  LngLatArray,\n  MapOptions,\n  LayerAdapter,\n  LngLatBoundsArray,\n  WebMapEvents,\n  CreateControlOptions\n} from '@nextgis/webmap';\nimport { sleep, debounce } from '@nextgis/utils';\nimport { MvtAdapter } from './layer-adapters/MvtAdapter';\nimport mapboxgl, {\n  Map,\n  IControl,\n  MapEventType,\n  EventData,\n  MapboxOptions,\n  RequestParameters,\n  ResourceType,\n  FitBoundsOptions\n} from 'mapbox-gl';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter';\nimport { EventEmitter } from 'events';\nimport { ZoomControl } from './controls/ZoomControl';\nimport { CompassControl } from './controls/CompassControl';\nimport { AttributionControl } from './controls/AttributionControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { createControl } from './controls/createControl';\nimport { createButtonControl } from './controls/createButtonControl';\n\nexport type TLayer = string[];\ntype TLayerAdapter = LayerAdapter<Map, TLayer>;\n\nconst fitBoundsOptions: FitOptions = {\n  // padding: 100\n};\n\nexport interface MapboxglMapAdapterOptions extends MapOptions {\n  style?: Partial<mapboxgl.Style> | string;\n  accessToken?: string;\n}\n\nexport class MapboxglMapAdapter implements MapAdapter<Map, TLayer, IControl> {\n  static layerAdapters = {\n    TILE: TileAdapter,\n    // IMAGE: TileAdapter,\n    MVT: MvtAdapter,\n    OSM: OsmAdapter,\n    GEOJSON: GeoJsonAdapter\n  };\n\n  static controlAdapters: { [name: string]: any } = {\n    ZOOM: ZoomControl,\n    COMPASS: CompassControl,\n    ATTRIBUTION: AttributionControl\n  };\n\n  options: MapboxglMapAdapterOptions = {};\n  map!: Map;\n\n  emitter = new EventEmitter();\n\n  layerAdapters = MapboxglMapAdapter.layerAdapters;\n  controlAdapters = MapboxglMapAdapter.controlAdapters;\n  isLoaded = false;\n\n  private _universalEvents: (keyof WebMapEvents)[] = [\n    'zoomstart',\n    'zoom',\n    'zoomend',\n    'movestart',\n    'move',\n    'moveend'\n  ];\n\n  private _sourceDataLoading: { [name: string]: any[] } = {};\n  private _sortTimerId?: number;\n  private __setLayerOrder: (layers: { [x: string]: TLayerAdapter }) => void;\n\n  constructor() {\n    this.__setLayerOrder = debounce(layers => this._setLayerOrder(layers));\n  }\n\n  // create(options: MapOptions = {target: 'map'}) {\n  create(options: MapboxglMapAdapterOptions) {\n    return new Promise((resolve, reject) => {\n      if (!this.map) {\n        this.options = options;\n        if (options.accessToken) {\n          mapboxgl.accessToken = options.accessToken;\n        }\n        if (options.target) {\n          const mapOpt: MapboxOptions = {\n            container: options.target,\n            attributionControl: false,\n            // @ts-ignore\n            bounds: options.bounds,\n            fitBoundsOptions: { ...options.fitOptions, ...fitBoundsOptions },\n            transformRequest: (url: string, resourceType: ResourceType) => {\n              const transformed = this._transformRequest(url, resourceType);\n              if (transformed) {\n                return transformed;\n              } else {\n                return {\n                  url\n                };\n              }\n            }\n          };\n          if (typeof options.style === 'string') {\n            mapOpt.style = options.style;\n          } else {\n            mapOpt.style = {\n              ...{\n                version: 8,\n                name: 'Empty style',\n                sources: {},\n                layers: []\n              },\n              ...options.style\n            };\n          }\n          if (options.center !== undefined) {\n            mapOpt.center = options.center;\n          }\n          if (options.zoom !== undefined) {\n            mapOpt.zoom = options.zoom - 1;\n          }\n          if (options.maxZoom) {\n            mapOpt.maxZoom = options.maxZoom - 1;\n          }\n          if (options.minZoom) {\n            mapOpt.minZoom = options.minZoom - 1;\n          }\n          this.map = new Map(mapOpt);\n          this.map.once('load', () => {\n            // @ts-ignore\n            this.map.transformRequests = [];\n            this.isLoaded = true;\n            this.emitter.emit('create', this);\n            resolve(this);\n          });\n          this._addEventsListeners();\n        }\n      }\n    });\n  }\n\n  destroy() {\n    if (this.map) {\n      this.map.remove();\n    }\n  }\n\n  getContainer() {\n    return this.map && this.map.getContainer();\n  }\n\n  setView(center: LngLatArray, zoom?: number) {\n    if (this.map) {\n      const options: mapboxgl.CameraOptions = { center };\n      if (zoom) {\n        options.zoom = zoom - 1;\n      }\n      this.map.jumpTo(options);\n    }\n  }\n\n  setCenter(latLng: LngLatArray): void {\n    if (this.map) {\n      this.map.setCenter(latLng);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    if (this.map) {\n      const center = this.map.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom - 1);\n    }\n  }\n\n  getZoom(): number | undefined {\n    if (this.map) {\n      const zoom = this.map.getZoom();\n      if (zoom < 1) {\n        return undefined;\n      }\n      return zoom ? zoom + 1 : undefined;\n    }\n  }\n\n  // [extent_left, extent_bottom, extent_right, extent_top];\n  async fitBounds(\n    e: LngLatBoundsArray,\n    options: FitOptions = {}\n  ): Promise<void> {\n    if (this.map) {\n      const fitBoundOptions: FitBoundsOptions = {\n        linear: true,\n        duration: 0,\n        ...options,\n        ...fitBoundsOptions\n      };\n      this.map.fitBounds(\n        [\n          [e[0], e[1]],\n          [e[2], e[3]]\n        ],\n        fitBoundOptions\n      );\n      sleep(fitBoundOptions.duration);\n    }\n  }\n\n  setRotation(angle: number): void {\n    // ignore\n  }\n\n  showLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach(layerId => {\n        this._toggleLayer(layerId, true);\n      });\n  }\n\n  hideLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach(layerId => {\n        this._toggleLayer(layerId, false);\n      });\n  }\n\n  removeLayer(layerIds: string[]): void {\n    const _map = this.map;\n    if (_map && layerIds && Array.isArray(layerIds)) {\n      layerIds.forEach(layerId => {\n        _map.removeLayer(layerId);\n        const source = _map.getSource(layerId);\n        if (source) {\n          _map.removeSource(layerId);\n        }\n      });\n    }\n  }\n\n  setLayerOrder(\n    layerIds: string[],\n    order: number,\n    layers: { [x: string]: TLayerAdapter }\n  ): void {\n    this.__setLayerOrder(layers);\n  }\n\n  setLayerOpacity(layerIds: string[], opacity: number): void {\n    const _map = this.map;\n    if (_map) {\n      layerIds.forEach(layerId => {\n        this._onMapLoad().then(() => {\n          const layer = _map.getLayer(layerId);\n          if (layer) {\n            if (layer.type === 'symbol') {\n              _map.setPaintProperty(layerId, 'text-opacity', opacity);\n              _map.setPaintProperty(layerId, 'icon-opacity', opacity);\n            } else {\n              _map.setPaintProperty(layerId, layer.type + '-opacity', opacity);\n            }\n          }\n        });\n      });\n    }\n  }\n\n  createControl(control: MapControl, options?: CreateControlOptions): IControl {\n    return createControl(control, options);\n  }\n\n  createButtonControl(options: ButtonControlOptions): IControl {\n    return createButtonControl(options);\n  }\n\n  addControl(\n    control: IControl,\n    position: ControlPositions\n  ): IControl | undefined {\n    if (this.map) {\n      this.map.addControl(control, position);\n      return control;\n    }\n  }\n\n  removeControl(control: IControl): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  onMapClick(evt: MapEventType['click'] & EventData): void {\n    const latLng = evt.lngLat;\n    const { x, y } = evt.point;\n\n    this.emitter.emit('click', { latLng, pixel: { top: y, left: x } });\n  }\n\n  private _onMapLoad(cb?: () => any): Promise<Map> {\n    return new Promise<Map>(resolve => {\n      const _resolve = () => {\n        if (cb) {\n          cb();\n        }\n        if (this.map) {\n          resolve(this.map);\n        }\n      };\n      if (this.isLoaded) {\n        // map.loaded()\n        _resolve();\n      } else if (this.map) {\n        this.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  private _setLayerOrder(layers: { [x: string]: TLayerAdapter }): void {\n    const _map = this.map;\n    if (_map) {\n      const baseLayers: TLayerAdapter[] = [];\n      let orderedLayers: TLayerAdapter[] = [];\n      for (const l in layers) {\n        const layer = layers[l];\n        if (layer.options.baseLayer) {\n          baseLayers.push(layer);\n        } else {\n          orderedLayers.push(layer);\n        }\n      }\n\n      // normalize layer ordering\n      baseLayers.forEach(x => {\n        if (x.layer) {\n          x.layer.forEach(y => {\n            _map.moveLayer(y);\n          });\n        }\n      });\n\n      orderedLayers = orderedLayers.sort((a, b) => {\n        return a.options.order !== undefined && b.options.order !== undefined\n          ? a.options.order - b.options.order\n          : 0;\n      });\n\n      for (let fry = 0; fry < orderedLayers.length; fry++) {\n        const mem = orderedLayers[fry];\n        const _layers = this._getLayerIds(mem);\n        _layers.forEach(x => {\n          _map.moveLayer(x);\n        });\n      }\n    }\n  }\n\n  private _getLayerIds(mem: TLayerAdapter): string[] {\n    let _layers: TLayer = [];\n    if (mem) {\n      if (Array.isArray(mem.layer)) {\n        _layers = mem.layer;\n      } else if (mem.getDependLayers) {\n        const dependLayers = mem.getDependLayers();\n        dependLayers.forEach(x => {\n          // @ts-ignore Update x interface\n          const layer: TLayer = (x.layer && x.layer.layer) || x;\n          if (Array.isArray(layer)) {\n            layer.forEach(y => {\n              _layers.push(y);\n            });\n          }\n        });\n      }\n    }\n    return _layers;\n  }\n\n  private _toggleLayer(layerId: string, status: boolean): void {\n    this._onMapLoad().then(_map => {\n      _map.setLayoutProperty(\n        layerId,\n        'visibility',\n        status ? 'visible' : 'none'\n      );\n    });\n  }\n\n  private _onMapSourceData(data: mapboxgl.MapSourceDataEvent & EventData) {\n    if (data.dataType === 'source') {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-loaded', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onMapError(\n    data: mapboxgl.ErrorEvent & mapboxgl.MapSourceDataEvent & EventData\n  ) {\n    if (this._sourceDataLoading[data.sourceId]) {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-error', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onDataLoad(\n    data: { sourceId: string; tile: any },\n    isLoaded = false,\n    emit: (sourceId: string) => void\n  ) {\n    // if all sources is loaded emmit event for all and clean mem\n    if (isLoaded) {\n      Object.keys(this._sourceDataLoading).forEach(x => {\n        emit(x);\n      });\n      this._sourceDataLoading = {};\n    } else {\n      // check if all tiles in layer is loaded\n      const tiles = this._sourceDataLoading[data.sourceId];\n      if (tiles && data.tile) {\n        const index = tiles.indexOf(data.tile);\n        if (index !== -1) {\n          this._sourceDataLoading[data.sourceId].splice(index, 1);\n        }\n        // if no more loaded tiles in layer emit event and clean mem only for this layer\n        if (!tiles.length) {\n          emit(data.sourceId);\n          delete this._sourceDataLoading[data.sourceId];\n        }\n      }\n    }\n  }\n\n  private _transformRequest(\n    url: string,\n    resourceType: ResourceType\n  ): RequestParameters | undefined {\n    // @ts-ignore\n    const transformRequests = this.map && this.map.transformRequests;\n    if (transformRequests) {\n      for (const r of transformRequests) {\n        const params = r(url, resourceType) as RequestParameters;\n        if (params) {\n          return params;\n        }\n      }\n      return undefined;\n    }\n  }\n\n  private _addEventsListeners(): void {\n    const _map = this.map;\n    if (_map) {\n      // write mem for start loaded layers\n      _map.on('sourcedataloading', data => {\n        this._sourceDataLoading[data.sourceId] =\n          this._sourceDataLoading[data.sourceId] || [];\n        if (data.tile) {\n          this._sourceDataLoading[data.sourceId].push(data.tile);\n        }\n      });\n      // emmit data-loaded for each layer or all sources is loaded\n      _map.on('sourcedata', this._onMapSourceData.bind(this));\n      _map.on('error', this._onMapError.bind(this));\n      _map.on('click', evt => {\n        this.onMapClick(evt);\n      });\n\n      this._universalEvents.forEach(e => {\n        _map.on(e, () => this.emitter.emit(e, this));\n      });\n    }\n  }\n}\n","import { ButtonControlOptions } from '@nextgis/webmap';\nimport { createControl } from './createControl';\n\nexport function createButtonControl(options: ButtonControlOptions) {\n  const link = document.createElement('button');\n  link.className = 'mapboxgl-ctrl-icon';\n\n  link.setAttribute('role', 'button');\n  if (options.title) {\n    link.title = options.title;\n    link.setAttribute('aria-label', options.title);\n  }\n\n  if (options.html) {\n    if (options.html instanceof HTMLElement) {\n      link.appendChild(options.html);\n    } else {\n      link.innerHTML = options.html;\n    }\n    const child = link.firstElementChild as HTMLElement;\n    if (child) {\n      child.style.width = '100%';\n      child.style.height = '100%';\n      child.style.lineHeight = (link.offsetHeight || 30) + 'px';\n    }\n  }\n  if (options.addClass) {\n    options.addClass.split(' ').forEach(x => link.classList.add(x));\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n  if (options.onClick !== undefined) {\n    link.addEventListener('click', onClick);\n  }\n\n  return createControl(\n    {\n      onAdd() {\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      }\n    },\n    { bar: true, addClass: 'mapboxgl-ctrl-group' }\n  );\n}\n","/**\n * @module mapboxgl-map-adapter\n */\n\nimport { MapboxglMapAdapter } from './MapboxglMapAdapter';\nexport * from './MapboxglMapAdapter';\nexport default MapboxglMapAdapter;\n","/**\n * @module icons\n */\n\n// tslint:disable:max-line-length\nimport { IconOptions as WebmapIcoOptions } from '@nextgis/webmap';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star:\n    '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>'\n};\n\nexport interface IconOptions {\n  shape?:\n    | 'circle'\n    | 'brill'\n    | 'rect'\n    | 'marker'\n    | 'star'\n    | 'asterisk'\n    | 'triangle'\n    | 'plus'\n    | 'minus';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n}\n\nconst STROKE = 0.8;\n\nfunction insertSvg(\n  width: number,\n  height: number,\n  stroke = 0,\n  content?: string\n) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${width + stroke} ${height + stroke}\"\n  >${content}</svg>`;\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\nexport function getIcon(opt: IconOptions = {}): WebmapIcoOptions {\n  // default values\n  const shape = opt.shape || 'circle';\n  const color = opt.color || 'blue';\n  const strokeColor = opt.strokeColor || 'white';\n  const size = opt.size || 12;\n\n  const anchor = size / 2;\n  const defSize = 12;\n  const stroke = typeof opt.stroke === 'number' ? opt.stroke : STROKE;\n  const scale = size / defSize;\n\n  const pathAlias = svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(size, size, stroke * scale, path);\n  const fistChild = svg.firstChild as SVGElement;\n\n  const transform = `scale(${scale})`;\n\n  fistChild.setAttribute('fill', color);\n  if (stroke) {\n    fistChild.setAttribute('stroke', strokeColor);\n    fistChild.setAttribute('stroke-width', String(stroke));\n  }\n  fistChild.setAttribute('transform', transform);\n  const s = new XMLSerializer();\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: [anchor, anchor],\n    html: s.serializeToString(svg),\n    svg\n  };\n}\n","/**\n * @module item\n */\nexport type SelfFilter<X extends any> = (x: X) => boolean;\nexport type RelationFunction<X extends any> = (x: X) => X | X[] | undefined;\n\nexport function filterIn<F extends any = any>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F) => !!x,\n  relationFunc: RelationFunction<F>,\n  _filtered: F[] = []\n): F[] {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      _filtered.push(item);\n    }\n    const relChild = relationFunc(item);\n    if (relChild) {\n      if (Array.isArray(relChild)) {\n        children = relChild;\n      } else {\n        children.push(relChild);\n      }\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      filterIn(children[fry], filterFunc, relationFunc, _filtered);\n    }\n  }\n\n  return _filtered;\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\nimport { filterIn } from './TreeUtil';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  // region Parents\n  setParent(parent: Item) {\n    this._parent = parent;\n  }\n\n  addChild(child: Item) {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return filterIn(parent, filterFunc, (x: I) => x.tree.getParent() as I);\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n  // endregion\n\n  // region Child\n  find(filterFunc?: (item: Item) => boolean) {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    })[0];\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return this._children as T[];\n  }\n}\n","/**\n * @module item\n */\nimport { Item } from '../Item';\nimport { ItemBasePropertyOptions } from '../interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\n// import StrictEventEmitter from 'strict-event-emitter-types/types/src';\n\n// export interface BasePropertyEvents<V, O> {\n//   'change': {value: V, options: O};\n//   'change-tree': {value: V, options: O, item: Item};\n// }\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>\n> {\n  options: O;\n\n  // emitter: StrictEventEmitter<EventEmitter, BasePropertyEvents<V, O>> = new EventEmitter();\n  emitter = EventEmitter && new EventEmitter();\n  name: string;\n\n  item: Item;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: Item, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty() {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent() {\n    return this.item.tree.getParent();\n  }\n\n  isGroup() {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked() {\n    if (this._blocked === undefined) {\n      const parents = this.item.tree.getParents();\n      if (parents) {\n        const isBlocked = parents.find((x: Item) => {\n          const parentProp = x.properties && x.properties.property(this.name);\n          if (parentProp) {\n            return !parentProp.get();\n          }\n          return false;\n        });\n        this._blocked = !!isBlocked;\n      } else {\n        this._blocked = false;\n      }\n    }\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O) {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O) {\n    this._callOnSet(value, options);\n  }\n\n  getContainer() {\n    return this._container;\n  }\n\n  destroy() {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O) {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O) {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach(x => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', { value, options, item: this.item });\n        }\n      });\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\nimport { ItemOptions } from './interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n  emitter = EventEmitter && new EventEmitter();\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties() {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","/**\n * @module item\n */\nimport { BaseProperty } from './BaseProperty';\nimport { Item } from '../Item';\n\nimport { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle'\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O) {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false })\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue() {\n    return (\n      this.get() &&\n      this.getParents().every(x => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  _prepareValue(value?: any): V | undefined {\n    return value;\n  }\n\n  _turnOff(options?: O) {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChilds(options);\n    }\n  }\n\n  _turnOn(options?: O) {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChilds(options);\n    }\n  }\n\n  block(options?: O) {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  _block(options?: O) {\n    this._turnOff(options);\n  }\n\n  unBlock(options?: O) {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  _unBlock(options?: O) {\n    this._turnOn(options);\n  }\n\n  blockChilds(options?: O) {\n    this.item.tree.getDescendants().forEach(x => this._blockChild(x, options));\n  }\n\n  unblockChilds(options?: O) {\n    this.item.tree.getChildren().forEach(x => this._unBlockChild(x, options));\n  }\n\n  _blockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  _unBlockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  _propagation(value?: V, options?: O) {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false\n            }\n          });\n        }\n      }\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { BaseProperty } from './BaseProperty';\nimport { CheckProperty } from './CheckProperty';\nimport { Item } from '../Item';\n\nimport {\n  ItemBasePropertyOptions,\n  Type,\n  ItemPropertyConfig,\n  ItemPropertyTypes\n} from '../interfaces';\n\nexport class ItemProperties {\n  static handlers: { [name: string]: Type<BaseProperty> } = {\n    CheckProperty\n  };\n\n  options = {};\n\n  private _properties: { [propName: string]: BaseProperty } = {};\n  private _propertiesList: string[];\n\n  constructor(\n    public item: Item,\n    propertiesList?: ItemPropertyConfig<keyof ItemPropertyTypes>[]\n  ) {\n    this._propertiesList = []; // ordered list\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    this._setPropertyHandler(propOpt);\n  }\n\n  _setPropertyHandler(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    const handlers = ItemProperties.handlers;\n    let handler = propOpt.handler;\n    if (!handler && propOpt.type) {\n      switch (propOpt.type) {\n        case 'boolean':\n          handler = handlers.CheckProperty;\n          break;\n        case 'string':\n          handler = handlers.BaseProperty;\n          break;\n        default:\n          handler = handlers.BaseProperty;\n      }\n    }\n    if (handler && propOpt.name) {\n      const options = { ...(propOpt || {}) };\n      this._properties[propOpt.name] = new handler(\n        propOpt.name,\n        this.item,\n        options\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  update() {\n    this.list().forEach(x => {\n      x.update();\n    });\n  }\n\n  get(name: string) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.get();\n    }\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>\n  ) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.set(value, options);\n    }\n  }\n\n  property(name: string) {\n    return this._properties[name];\n  }\n\n  list() {\n    return this._propertiesList.map(x => this._properties[x]);\n  }\n\n  destroy() {\n    for (const p in this._properties) {\n      const prop = this.property(p);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\n\nexport * from './interfaces';\nexport * from './properties/BaseProperty';\nexport * from './properties/CheckProperty';\nexport * from './properties/ItemProperties';\n\nexport { Item };\nexport default Item;\n"],"sourceRoot":""}