{"version":3,"sources":["webpack:///./node_modules/vuex-module-decorators/dist/esm/index.js"],"names":["addPropertiesToObject","target","source","_loop_1","k","Object","defineProperty","get","_i","_a","keys","length","getModuleName","module","_vmdModuleName","Error","VuexModule","this","actions","mutations","state","getters","namespaced","modules","getModule","moduleClass","store","moduleName","_statics","genStatic","_genStatic","storeModule","reservedKeys","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","Symbol","iterator","n","v","op","TypeError","call","pop","push","moduleDecoratorFactory","moduleOptions","constructor","stateFactory$1","prototype","s","forEach","key","indexOf","hasOwnProperty","stateFactory","getOwnPropertyNames","funcName","descriptor","getOwnPropertyDescriptor","rootState","rootGetters","thisObj","context","modOpt","name","statics","staticStateGenerator","staticGetterGenerator","args","arguments","commit","concat","staticMutationGenerator","_b","dispatch","staticActionGenerators","dynamic","registerModule","registerDynamicModule","Module","modOrOpt","actionDecoratorFactory","params","undefined","_c","rawError","_d","root","assign","actionFunction","action","payload","actionPayload","moduleAccessor","e_1","toString","stack","handler","Action","targetOrParams","Mutation","mutationFunction"],"mappings":"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","file":"vendors~main~1c4c9cf1-1ef3d54.js","sourcesContent":["/**\r\n * Takes the properties on object from parameter source and adds them to the object\r\n * parameter target\r\n * @param {object} target  Object to have properties copied onto from y\r\n * @param {object} source  Object with properties to be copied to x\r\n */\r\nfunction addPropertiesToObject(target, source) {\r\n    var _loop_1 = function (k) {\r\n        Object.defineProperty(target, k, {\r\n            get: function () { return source[k]; }\r\n        });\r\n    };\r\n    for (var _i = 0, _a = Object.keys(source || {}); _i < _a.length; _i++) {\r\n        var k = _a[_i];\r\n        _loop_1(k);\r\n    }\r\n}\r\n/**\r\n * Returns a namespaced name of the module to be used as a store getter\r\n * @param module\r\n */\r\nfunction getModuleName(module) {\r\n    if (!module._vmdModuleName) {\r\n        throw new Error(\"ERR_GET_MODULE_NAME : Could not get module accessor.\\n      Make sure your module has name, we can't make accessors for unnamed modules\\n      i.e. @Module({ name: 'something' })\");\r\n    }\r\n    return \"vuexModuleDecorators/\" + module._vmdModuleName;\r\n}\n\nvar VuexModule = /** @class */ (function () {\r\n    function VuexModule(module) {\r\n        this.actions = module.actions;\r\n        this.mutations = module.mutations;\r\n        this.state = module.state;\r\n        this.getters = module.getters;\r\n        this.namespaced = module.namespaced;\r\n        this.modules = module.modules;\r\n    }\r\n    return VuexModule;\r\n}());\r\nfunction getModule(moduleClass, store) {\r\n    var moduleName = getModuleName(moduleClass);\r\n    if (store && store.getters[moduleName]) {\r\n        return store.getters[moduleName];\r\n    }\r\n    else if (moduleClass._statics) {\r\n        return moduleClass._statics;\r\n    }\r\n    var genStatic = moduleClass._genStatic;\r\n    if (!genStatic) {\r\n        throw new Error(\"ERR_GET_MODULE_NO_STATICS : Could not get module accessor.\\n      Make sure your module has name, we can't make accessors for unnamed modules\\n      i.e. @Module({ name: 'something' })\");\r\n    }\r\n    var storeModule = genStatic(store);\r\n    if (store) {\r\n        store.getters[moduleName] = storeModule;\r\n    }\r\n    else {\r\n        moduleClass._statics = storeModule;\r\n    }\r\n    return storeModule;\r\n}\n\nvar reservedKeys = ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit'];\r\nfunction stateFactory(module) {\r\n    var state = new module.prototype.constructor({});\r\n    var s = {};\r\n    Object.keys(state).forEach(function (key) {\r\n        if (reservedKeys.indexOf(key) !== -1) {\r\n            if (typeof state[key] !== 'undefined') {\r\n                throw new Error(\"ERR_RESERVED_STATE_KEY_USED: You cannot use the following\\n        ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\\n        as fields in your module. These are reserved as they have special purpose in Vuex\");\r\n            }\r\n            return;\r\n        }\r\n        if (state.hasOwnProperty(key)) {\r\n            if (typeof state[key] !== 'function') {\r\n                s[key] = state[key];\r\n            }\r\n        }\r\n    });\r\n    return s;\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nfunction staticStateGenerator(module, modOpt, statics) {\r\n    var state = modOpt.stateFactory ? module.state() : module.state;\r\n    Object.keys(state).forEach(function (key) {\r\n        if (state.hasOwnProperty(key)) {\r\n            // If not undefined or function means it is a state value\r\n            if (['undefined', 'function'].indexOf(typeof state[key]) === -1) {\r\n                Object.defineProperty(statics, key, {\r\n                    get: function () {\r\n                        return statics.store.state[modOpt.name][key];\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction staticGetterGenerator(module, modOpt, statics) {\r\n    Object.keys(module.getters).forEach(function (key) {\r\n        if (module.namespaced) {\r\n            Object.defineProperty(statics, key, {\r\n                get: function () {\r\n                    return statics.store.getters[modOpt.name + \"/\" + key];\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            Object.defineProperty(statics, key, {\r\n                get: function () {\r\n                    return statics.store.getters[key];\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\nfunction staticMutationGenerator(module, modOpt, statics) {\r\n    Object.keys(module.mutations).forEach(function (key) {\r\n        if (module.namespaced) {\r\n            statics[key] = function () {\r\n                var _a;\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                (_a = statics.store).commit.apply(_a, [modOpt.name + \"/\" + key].concat(args));\r\n            };\r\n        }\r\n        else {\r\n            statics[key] = function () {\r\n                var _a;\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                (_a = statics.store).commit.apply(_a, [key].concat(args));\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction staticActionGenerators(module, modOpt, statics) {\r\n    Object.keys(module.actions).forEach(function (key) {\r\n        if (module.namespaced) {\r\n            statics[key] = function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                return __awaiter(this, void 0, void 0, function () {\r\n                    var _a;\r\n                    return __generator(this, function (_b) {\r\n                        return [2 /*return*/, (_a = statics.store).dispatch.apply(_a, [modOpt.name + \"/\" + key].concat(args))];\r\n                    });\r\n                });\r\n            };\r\n        }\r\n        else {\r\n            statics[key] = function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                return __awaiter(this, void 0, void 0, function () {\r\n                    var _a;\r\n                    return __generator(this, function (_b) {\r\n                        return [2 /*return*/, (_a = statics.store).dispatch.apply(_a, [key].concat(args))];\r\n                    });\r\n                });\r\n            };\r\n        }\r\n    });\r\n}\n\nfunction registerDynamicModule(module, modOpt) {\r\n    if (!modOpt.name) {\r\n        throw new Error('Name of module not provided in decorator options');\r\n    }\r\n    if (!modOpt.store) {\r\n        throw new Error('Store not provided in decorator options when using dynamic option');\r\n    }\r\n    modOpt.store.registerModule(modOpt.name, // TODO: Handle nested modules too in future\r\n    module);\r\n}\r\nfunction moduleDecoratorFactory(moduleOptions) {\r\n    return function (constructor) {\r\n        var module = constructor;\r\n        var stateFactory$1 = function () { return stateFactory(module); };\r\n        if (!module.state) {\r\n            module.state = moduleOptions && moduleOptions.stateFactory ? stateFactory$1 : stateFactory$1();\r\n        }\r\n        if (!module.getters) {\r\n            module.getters = {};\r\n        }\r\n        if (!module.namespaced) {\r\n            module.namespaced = moduleOptions && moduleOptions.namespaced;\r\n        }\r\n        Object.getOwnPropertyNames(module.prototype).forEach(function (funcName) {\r\n            var descriptor = Object.getOwnPropertyDescriptor(module.prototype, funcName);\r\n            if (descriptor.get && module.getters) {\r\n                module.getters[funcName] = function (state, getters, rootState, rootGetters) {\r\n                    var thisObj = { context: { state: state, getters: getters, rootState: rootState, rootGetters: rootGetters } };\r\n                    addPropertiesToObject(thisObj, state);\r\n                    addPropertiesToObject(thisObj, getters);\r\n                    var got = descriptor.get.call(thisObj);\r\n                    return got;\r\n                };\r\n            }\r\n        });\r\n        var modOpt = moduleOptions;\r\n        if (modOpt.name) {\r\n            Object.defineProperty(constructor, '_genStatic', {\r\n                value: function (store) {\r\n                    var statics = { store: store || modOpt.store };\r\n                    if (!statics.store) {\r\n                        throw new Error(\"ERR_STORE_NOT_PROVIDED: To use getModule(), either the module\\n            should be decorated with store in decorator, i.e. @Module({store: store}) or\\n            store should be passed when calling getModule(), i.e. getModule(MyModule, this.$store)\");\r\n                    }\r\n                    // ===========  For statics ==============\r\n                    // ------ state -------\r\n                    staticStateGenerator(module, modOpt, statics);\r\n                    // ------- getters -------\r\n                    if (module.getters) {\r\n                        staticGetterGenerator(module, modOpt, statics);\r\n                    }\r\n                    // -------- mutations --------\r\n                    if (module.mutations) {\r\n                        staticMutationGenerator(module, modOpt, statics);\r\n                    }\r\n                    // -------- actions ---------\r\n                    if (module.actions) {\r\n                        staticActionGenerators(module, modOpt, statics);\r\n                    }\r\n                    return statics;\r\n                }\r\n            });\r\n            Object.defineProperty(constructor, '_vmdModuleName', {\r\n                value: modOpt.name\r\n            });\r\n        }\r\n        if (modOpt.dynamic) {\r\n            registerDynamicModule(module, modOpt);\r\n        }\r\n        return constructor;\r\n    };\r\n}\r\nfunction Module(modOrOpt) {\r\n    if (typeof modOrOpt === 'function') {\r\n        /*\r\n         * @Module decorator called without options (directly on the class definition)\r\n         */\r\n        moduleDecoratorFactory({})(modOrOpt);\r\n    }\r\n    else {\r\n        /*\r\n         * @Module({...}) decorator called with options\r\n         */\r\n        return moduleDecoratorFactory(modOrOpt);\r\n    }\r\n}\n\nfunction actionDecoratorFactory(params) {\r\n    var _a = params || {}, _b = _a.commit, commit = _b === void 0 ? undefined : _b, _c = _a.rawError, rawError = _c === void 0 ? false : _c, _d = _a.root, root = _d === void 0 ? false : _d;\r\n    return function (target, key, descriptor) {\r\n        var module = target.constructor;\r\n        if (!module.hasOwnProperty('actions')) {\r\n            module.actions = Object.assign({}, module.actions);\r\n        }\r\n        var actionFunction = descriptor.value;\r\n        var action = function (context, payload) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var actionPayload, moduleName, moduleAccessor, thisObj, e_1;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            _a.trys.push([0, 5, , 6]);\r\n                            actionPayload = null;\r\n                            if (!module._genStatic) return [3 /*break*/, 2];\r\n                            moduleName = getModuleName(module);\r\n                            moduleAccessor = context.rootGetters[moduleName]\r\n                                ? context.rootGetters[moduleName]\r\n                                : getModule(module);\r\n                            moduleAccessor.context = context;\r\n                            return [4 /*yield*/, actionFunction.call(moduleAccessor, payload)];\r\n                        case 1:\r\n                            actionPayload = _a.sent();\r\n                            return [3 /*break*/, 4];\r\n                        case 2:\r\n                            thisObj = { context: context };\r\n                            addPropertiesToObject(thisObj, context.state);\r\n                            addPropertiesToObject(thisObj, context.getters);\r\n                            return [4 /*yield*/, actionFunction.call(thisObj, payload)];\r\n                        case 3:\r\n                            actionPayload = _a.sent();\r\n                            _a.label = 4;\r\n                        case 4:\r\n                            if (commit) {\r\n                                context.commit(commit, actionPayload);\r\n                            }\r\n                            return [2 /*return*/, actionPayload];\r\n                        case 5:\r\n                            e_1 = _a.sent();\r\n                            throw rawError\r\n                                ? e_1\r\n                                : new Error('ERR_ACTION_ACCESS_UNDEFINED: Are you trying to access ' +\r\n                                    'this.someMutation() or this.someGetter inside an @Action? \\n' +\r\n                                    'That works only in dynamic modules. \\n' +\r\n                                    'If not dynamic use this.context.commit(\"mutationName\", payload) ' +\r\n                                    'and this.context.getters[\"getterName\"]' +\r\n                                    '\\n' +\r\n                                    new Error(\"Could not perform action \" + key.toString()).stack +\r\n                                    '\\n' +\r\n                                    e_1.stack);\r\n                        case 6: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        module.actions[key] = root ? { root: root, handler: action } : action;\r\n    };\r\n}\r\n/**\r\n * The @Action decorator turns an async function into an Vuex action\r\n *\r\n * @param targetOrParams the module class\r\n * @param key name of the action\r\n * @param descriptor the action function descriptor\r\n * @constructor\r\n */\r\nfunction Action(targetOrParams, key, descriptor) {\r\n    if (!key && !descriptor) {\r\n        /*\r\n         * This is the case when `targetOrParams` is params.\r\n         * i.e. when used as -\r\n         * <pre>\r\n            @Action({commit: 'incrCount'})\r\n            async getCountDelta() {\r\n              return 5\r\n            }\r\n         * </pre>\r\n         */\r\n        return actionDecoratorFactory(targetOrParams);\r\n    }\r\n    else {\r\n        /*\r\n         * This is the case when @Action is called on action function\r\n         * without any params\r\n         * <pre>\r\n         *   @Action\r\n         *   async doSomething() {\r\n         *    ...\r\n         *   }\r\n         * </pre>\r\n         */\r\n        actionDecoratorFactory()(targetOrParams, key, descriptor);\r\n    }\r\n}\n\nfunction Mutation(target, key, descriptor) {\r\n    var module = target.constructor;\r\n    if (!module.hasOwnProperty('mutations')) {\r\n        module.mutations = Object.assign({}, module.mutations);\r\n    }\r\n    var mutationFunction = descriptor.value ? descriptor.value : function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return ({});\r\n    };\r\n    var mutation = function (state, payload) {\r\n        mutationFunction.call(state, payload);\r\n    };\r\n    module.mutations[key] = mutation;\r\n}\n\nfunction mutationActionDecoratorFactory(params) {\r\n    return function (target, key, descriptor) {\r\n        var module = target.constructor;\r\n        if (!module.hasOwnProperty('mutations')) {\r\n            module.mutations = Object.assign({}, module.mutations);\r\n        }\r\n        if (!module.hasOwnProperty('actions')) {\r\n            module.actions = Object.assign({}, module.actions);\r\n        }\r\n        var mutactFunction = descriptor.value;\r\n        var action = function (context, payload) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var actionPayload, e_1;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            _a.trys.push([0, 2, , 3]);\r\n                            return [4 /*yield*/, mutactFunction.call(context, payload)];\r\n                        case 1:\r\n                            actionPayload = _a.sent();\r\n                            context.commit(key, actionPayload);\r\n                            return [3 /*break*/, 3];\r\n                        case 2:\r\n                            e_1 = _a.sent();\r\n                            if (params.rawError) {\r\n                                throw e_1;\r\n                            }\r\n                            else {\r\n                                console.error('Could not perform action ' + key.toString());\r\n                                console.error(e_1);\r\n                            }\r\n                            return [3 /*break*/, 3];\r\n                        case 3: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        var mutation = function (state, payload) {\r\n            if (!params.mutate) {\r\n                params.mutate = Object.keys(payload);\r\n            }\r\n            for (var _i = 0, _a = params.mutate; _i < _a.length; _i++) {\r\n                var stateItem = _a[_i];\r\n                if (state.hasOwnProperty(stateItem) && payload.hasOwnProperty(stateItem)) {\r\n                    state[stateItem] = payload[stateItem];\r\n                }\r\n                else {\r\n                    throw new Error(\"ERR_MUTATE_PARAMS_NOT_IN_PAYLOAD\\n          In @MutationAction, mutate: ['a', 'b', ...] array keys must\\n          match with return type = {a: {}, b: {}, ...} and must\\n          also be in state.\");\r\n                }\r\n            }\r\n        };\r\n        module.actions[key] = params.root ? { root: true, handler: action } : action;\r\n        module.mutations[key] = mutation;\r\n    };\r\n}\r\n/**\r\n * The @MutationAction decorator turns this into an action that further calls a mutation\r\n * Both the action and the mutation are generated for you\r\n *\r\n * @param paramsOrTarget the params or the target class\r\n * @param key the name of the function\r\n * @param descriptor the function body\r\n * @constructor\r\n */\r\nfunction MutationAction(paramsOrTarget, key, descriptor) {\r\n    if (!key && !descriptor) {\r\n        /*\r\n         * This is the case when `paramsOrTarget` is params.\r\n         * i.e. when used as -\r\n         * <pre>\r\n            @MutationAction({mutate: ['incrCount']})\r\n            async getCountDelta() {\r\n              return {incrCount: 5}\r\n            }\r\n         * </pre>\r\n         */\r\n        return mutationActionDecoratorFactory(paramsOrTarget);\r\n    }\r\n    else {\r\n        /*\r\n         * This is the case when `paramsOrTarget` is target.\r\n         * i.e. when used as -\r\n         * <pre>\r\n            @MutationAction\r\n            async getCountDelta() {\r\n              return {incrCount: 5}\r\n            }\r\n         * </pre>\r\n         */\r\n        mutationActionDecoratorFactory({})(paramsOrTarget, key, descriptor);\r\n    }\r\n}\n\nexport { Action, Module, Mutation, MutationAction, VuexModule, getModule };\n//# sourceMappingURL=index.js.map\n"],"sourceRoot":""}