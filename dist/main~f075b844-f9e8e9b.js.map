{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/icons/src/index.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/image_icons.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/geom_type.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/VectorAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/MvtAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/TileAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/ZoomControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/CompassControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/AttributionControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/MapboxglMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createButtonControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/index.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeUtil.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeHelper.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/BaseProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/Item.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/CheckProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/ItemProperties.ts","webpack:///./nextgisweb_frontend/packages/item/src/index.ts"],"names":["svgPath","brill","circle","rect","marker","cross","star","triangle","plus","minus","asterisk","getIcon","opt","shape","color","strokeColor","size","anchor","stroke","scale","pathAlias","svg","width","height","content","s","DOMParser","parseFromString","documentElement","insertSvg","fistChild","firstChild","transform","setAttribute","String","type","iconSize","iconAnchor","html","XMLSerializer","serializeToString","canvg","er","getImageData","img","canvas","window","document","createElement","context","getContext","Error","HTMLImageElement","drawImage","Canvg","fromString","start","ID","map","options","this","_layerId","allowedByType","line","fill","icon","concat","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","typeAliasForFilter","backAliases","a","layerType","backAlias","push","findMostFrequentGeomType","arr","counts","fry","length","maxName","c","maxCount","geometryFilter","geometry","backType","indexOf","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","like","ilike","reversOperations","PAINT","opacity","radius","selected","featureIdName","_types","_selectedFeatureIds","_sourceId","source","_selectionName","$onLayerClick","_onLayerClick","bind","addLayer","layer","types","paint","_onAddLayer","t","geomType","_detectPaintType","_getLayerNameFromType","geomFilter","undefined","_addLayer","_getNativeFilter","selectedPaint","selectionLayer","_getSelectionLayerNameFromType","selectedLayout","_addEventsListeners","propertiesFilter","filters","_filterProperties","_updatePropertiesFilter","removeFilter","_updateFilter","select","properties","_selectProperties","unselect","removeLayer","forEach","layerId","_updateWithNativeFilter","filter","nativeFilter","name","layout","minZoom","maxZoom","mType","layerOpt","id","visibility","_getAdditionalLayerOptions","minzoom","maxzoom","x","setFilter","sourceId","_updateLayerPaint","layerName","layers","selName","_paint","nativePaint","_createPaintForType","p","setLayoutProperty","setPaintProperty","mapboxPaint","_registerImage","allowed","allowedType","find","Array","isArray","paramName","duration","_getFeatureFilterId","feature","_featureFilterId","hasImage","svgStr","Promise","resolve","Image","crossOrigin","src","btoa","onload","imageData","image","addImage","_selectFeature","_unselectFeature","selLayerName","selectProperties","filterProperties","propertyFilters","_convertToMapboxFilter","reverse","_operationsAliases","field","operation","value","operationAlias","isFeatureSelected","filterId","e","preventDefault","reduce","b","features_","queryRenderedFeatures","point","isSelected","unselectOnSecondClick","onLayerClick","falsePaint","selectable","on","getCanvas","style","cursor","BaseAdapter","MvtAdapter","sources","includes","url","addSource","tiles","sourceLayer","subdomains","split","replace","headers","transformRequests","resourceType","staticUrl","sourceOptions","tileSize","attribution","layerOptions","before","OPTIONS","Object","assign","TileAdapter","showCompass","_createButton","className","ariaLabel","fn","element","alias","label","title","showZoom","_features","_sources","data","addData","getSource","removeSource","clearLayer","cb","features","setData","detectedType","geojson","f","geometries","g","detectType","filterGeometries","fid","_filterFun","_filter","getLayers","filtered","_filteredFeatureIds","_getFeatures","visible","fun","getSelected","_getPaintFromCallback","selectedFeatureIds","multiselect","index","splice","selectionArray","filteredArray","filter_","_data","ok","newFeatures","geomCollection","toSave","createControl","control","getDefaultPosition","onAdd","classList","add","bar","addClass","appendChild","_container","onRemove","parentNode","removeChild","remove","fitBoundsOptions","emitter","layerAdapters","MapboxglMapAdapter","controlAdapters","isLoaded","_universalEvents","_sourceDataLoading","__setLayerOrder","_setLayerOrder","create","reject","accessToken","target","mapOpt","container","attributionControl","bounds","fitOptions","transformRequest","transformed","_transformRequest","version","center","zoom","once","emit","destroy","getContainer","setView","jumpTo","setCenter","latLng","getCenter","lng","lat","setZoom","getZoom","fitBounds","fitBoundOptions","linear","setRotation","angle","showLayer","layerIds","_toggleLayer","hideLayer","_map","setLayerOrder","order","setLayerOpacity","_onMapLoad","then","getLayer","createButtonControl","link","HTMLElement","innerHTML","child","firstElementChild","lineHeight","offsetHeight","onClick","stopPropagation","addEventListener","parent","removeEventListener","addControl","position","removeControl","onMapClick","evt","lngLat","y","pixel","top","left","_resolve","console","log","baseLayers","orderedLayers","l","baseLayer","sort","nextLayer","nextLayerId","mem","_getLayerIds","moveLayer","firstRealLayer","_layers","getDependLayers","status","_onMapSourceData","dataType","isSourceLoaded","_onDataLoad","_onMapError","keys","tile","params","r","TILE","MVT","OSM","OsmAdapter","GEOJSON","ZOOM","ZoomControl","COMPASS","CompassControl","ATTRIBUTION","AttributionControl","filterIn","item","filterFunc","relationFunc","_filtered","children","relChild","events","_children","setParent","_parent","addChild","getParent","getParents","tree","getRoot","toReturn","getChildren","all","getDescendants","EventEmitter","_blocked","_value","getProperty","call","isGroup","isBlocked","parents","parentProp","property","get","set","_prepareValue","update","_fireChangeEvent","getValue","_callOnSet","_removeEventsListener","onSet","prop","CheckProperty","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","getHierarchyValue","every","turnOff","hierarchy","blockChilds","turnOn","unblockChilds","block","_block","_unBlock","_blockChild","_unBlockChild","BaseProperty","propertiesList","_properties","_propertiesList","_setPropertyHandler","propOpt","handlers","ItemProperties","handler","list","initProperties"],"mappings":"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","file":"main~f075b844-f9e8e9b.js","sourcesContent":["/**\n * @module icons\n */\n\n// tslint:disable:max-line-length\nimport { IconOptions as WebmapIcoOptions } from '@nextgis/webmap';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star:\n    '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>'\n};\n\nexport interface IconOptions {\n  shape?:\n    | 'circle'\n    | 'brill'\n    | 'rect'\n    | 'marker'\n    | 'star'\n    | 'asterisk'\n    | 'triangle'\n    | 'plus'\n    | 'minus';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n}\n\nconst STROKE = 0.8;\n\nfunction insertSvg(\n  width: number,\n  height: number,\n  stroke = 0,\n  content?: string\n) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${width + stroke} ${height + stroke}\"\n  >${content}</svg>`;\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\nexport function getIcon(opt: IconOptions = {}): WebmapIcoOptions {\n  // default values\n  const shape = opt.shape || 'circle';\n  const color = opt.color || 'blue';\n  const strokeColor = opt.strokeColor || 'white';\n  const size = opt.size || 12;\n\n  const anchor = size / 2;\n  const defSize = 12;\n  const stroke = typeof opt.stroke === 'number' ? opt.stroke : STROKE;\n  const scale = size / defSize;\n\n  const pathAlias = svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(size, size, stroke * scale, path);\n  const fistChild = svg.firstChild as SVGElement;\n\n  const transform = `scale(${scale})`;\n\n  fistChild.setAttribute('fill', color);\n  if (stroke) {\n    fistChild.setAttribute('stroke', strokeColor);\n    fistChild.setAttribute('stroke-width', String(stroke));\n  }\n  fistChild.setAttribute('transform', transform);\n  const s = new XMLSerializer();\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: [anchor, anchor],\n    html: s.serializeToString(svg),\n    svg\n  };\n}\n","let canvg: any;\ntry {\n  canvg = require('canvg');\n} catch (er) {\n  // ignore\n}\ninterface GetImgOpt {\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  sdf?: string;\n  pixelRatio?: number;\n}\n\n// const defAddImgOpt = {\n//   width: 12,\n//   height: 12,\n//   x: 0,\n//   y: 0,\n//   sdf: undefined,\n//   pixelRatio: 2\n// };\n\n// // from /mapbox-gl/src/util/browser.js\nexport function getImageData(\n  img: string | HTMLImageElement,\n  opt: GetImgOpt\n): ImageData {\n  const canvas = window.document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('failed to create canvas 2d context');\n  }\n  canvas.setAttribute('width', String(opt.width));\n  canvas.setAttribute('height', String(opt.height));\n  if (!canvg && img instanceof HTMLImageElement) {\n    context.drawImage(img, 0, 0, opt.width, opt.height);\n  } else if (typeof img === 'string') {\n    if (canvg.Canvg) {\n      // for canvg v.3.x.x\n      const v = canvg.Canvg.fromString(context, img);\n      v.start();\n    } else {\n      // for canvg v.2.x.x\n      canvg(canvas, img);\n    }\n  }\n  return context.getImageData(0, 0, opt.width, opt.height);\n}\n\nexport function getImage(svgStr: string, opt: GetImgOpt): Promise<ImageData> {\n  return new Promise(resolve => {\n    if (canvg) {\n      resolve(getImageData(svgStr, opt));\n    } else {\n      const svgImage = new Image();\n      svgImage.crossOrigin = 'Anonymous';\n      svgImage.src = 'data:image/svg+xml;base64,' + btoa(svgStr);\n\n      svgImage.onload = () => {\n        const imageData = getImageData(svgImage, opt);\n        resolve(imageData);\n      };\n    }\n  });\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map } from 'mapbox-gl';\nimport { BaseLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\nexport abstract class BaseAdapter<O extends AdapterOptions = AdapterOptions>\n  implements BaseLayerAdapter<Map, TLayer, O> {\n  layer?: TLayer;\n  protected readonly _layerId: string;\n\n  constructor(public map: Map, public options: O) {\n    this._layerId = `layer-${ID++}`;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  abstract addLayer(options: O): TLayer | Promise<TLayer> | undefined;\n}\n","import {\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  FeatureCollection,\n  Feature,\n  GeometryCollection\n} from 'geojson';\nimport { VectorAdapterLayerType } from '@nextgis/webmap';\n\nexport const allowedParams: ([string, string] | string)[] = [\n  'color',\n  'opacity'\n];\nexport const allowedByType = {\n  circle: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity'],\n    ['strokeColor', 'stroke-color'],\n    ['strokeOpacity', 'stroke-opacity'],\n    ['weight', 'stroke-width'],\n    'radius'\n  ],\n  line: [\n    ['strokeColor', 'color'],\n    ['strokeOpacity', 'opacity'],\n    ['weight', 'width']\n  ],\n  fill: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity']\n  ],\n  icon: allowedParams.concat([])\n};\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'circle',\n  LineString: 'line',\n  MultiPoint: 'circle',\n  Polygon: 'fill',\n  MultiLineString: 'line',\n  MultiPolygon: 'fill',\n  GeometryCollection: 'fill'\n};\n\nexport const typeAliasForFilter: {\n  [key in VectorAdapterLayerType]: GeoJsonGeometryTypes;\n} = {\n  circle: 'Point',\n  line: 'LineString',\n  fill: 'Polygon',\n  icon: 'Point'\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {\n  icon: ['Point']\n};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[]\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      f => f.geometry.type\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      g => g.type\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n\n// Static functions\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType\n): boolean {\n  const backType = backAliases[type];\n  if (backType) {\n    return backType.indexOf(geometry) !== -1;\n  }\n  return false;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  IconOptions,\n  VectorLayerAdapter,\n  VectorAdapterOptions,\n  PropertiesFilter,\n  Operations,\n  DataLayerFilter,\n  PropertyFilter,\n  FilterOptions,\n  checkIfPropertyFilter\n} from '@nextgis/webmap';\nimport {\n  Feature as F,\n  GeometryObject,\n  Geometry,\n  GeoJsonProperties\n} from 'geojson';\nimport {\n  Map,\n  MapLayerMouseEvent,\n  AnySourceData,\n  AnyLayout,\n  Layer,\n  MapboxGeoJSONFeature\n  // BackgroundPaint, FillPaint, FillExtrusionPaint, LinePaint, SymbolPaint,\n  // RasterPaint, CirclePaint, HeatmapPaint, HillshadePaint,\n} from 'mapbox-gl';\n\n// type MapboxPaint = BackgroundPaint | FillPaint | FillExtrusionPaint | LinePaint | SymbolPaint |\n//   RasterPaint | CirclePaint | HeatmapPaint | HillshadePaint;\n\nimport { getImage } from '../util/image_icons';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { BaseAdapter } from './BaseAdapter';\nimport { typeAliasForFilter, allowedByType } from '../util/geom_type';\n\nexport const operationsAliases: { [key in Operations]: string } = {\n  gt: '>',\n  lt: '<',\n  ge: '>=',\n  le: '<=',\n  eq: '==',\n  ne: '!=',\n  in: 'in',\n  notin: '!in',\n  // NOT SUPPORTED\n  like: '==',\n  // NOT SUPPORTED\n  ilike: '=='\n};\n\nconst reversOperations: { [key in Operations]: string } = {\n  gt: operationsAliases.le,\n  lt: operationsAliases.ge,\n  ge: operationsAliases.lt,\n  le: operationsAliases.gt,\n  eq: operationsAliases.ne,\n  ne: operationsAliases.eq,\n  in: operationsAliases.notin,\n  notin: operationsAliases.in,\n  like: operationsAliases.ne,\n  ilike: operationsAliases.ne\n};\n\nexport interface Feature<\n  G extends GeometryObject | null = Geometry,\n  P = GeoJsonProperties\n> extends F<G, P> {\n  _featureFilterId?: string;\n}\n\nconst PAINT = {\n  color: 'blue',\n  opacity: 1,\n  radius: 10\n};\n\ntype MapboxLayerType = 'fill' | 'line' | 'symbol' | 'circle';\n\nexport abstract class VectorAdapter<\n  O extends VectorAdapterOptions = VectorAdapterOptions\n> extends BaseAdapter<O>\n  implements VectorLayerAdapter<Map, TLayer, O, Feature> {\n  selected = false;\n\n  protected featureIdName = 'id';\n  protected _types: VectorAdapterLayerType[] = ['fill', 'circle', 'line'];\n  protected readonly _sourceId: string;\n  protected readonly _selectionName: string;\n  protected _selectedFeatureIds: (number | string)[] | false = [];\n\n  protected _selectProperties?: PropertiesFilter;\n  protected _filterProperties?: PropertiesFilter;\n\n  private $onLayerClick?: (e: MapLayerMouseEvent) => void;\n\n  constructor(public map: Map, public options: O) {\n    super(map, options);\n    this._sourceId = this.options.source\n      ? (this.options.source as string)\n      : `source-${this._layerId}`;\n\n    if (this.options.featureIdName) {\n      this.featureIdName = this.options.featureIdName;\n    } else if (this.options.source) {\n      this.featureIdName = '$id';\n    } else {\n      this.featureIdName = '_fid';\n    }\n\n    this._selectionName = this._layerId + '-highlighted';\n    this.$onLayerClick = this._onLayerClick.bind(this);\n  }\n\n  async addLayer(options: O): Promise<TLayer> {\n    options = this.options = { ...this.options, ...(options || {}) };\n\n    this.layer = [];\n    const types = (this._types = options.type ? [options.type] : this._types);\n    if (options.paint) {\n      this._onAddLayer(this._sourceId);\n      // const types = this._types;\n      for (const t of types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          let type = t;\n          if (t === 'circle') {\n            const paintType = this._detectPaintType(options.paint);\n            if (paintType === 'icon') {\n              type = 'icon';\n            }\n          }\n          const layer = this._getLayerNameFromType(t);\n          const geomFilter =\n            types.length > 1 ? ['==', '$type', geomType] : undefined;\n\n          await this._addLayer(layer, type, [\n            geomFilter,\n            this._getNativeFilter()\n          ]);\n          this.layer.push(layer);\n          if (options.selectedPaint) {\n            const selectionLayer = this._getSelectionLayerNameFromType(t);\n            await this._addLayer(\n              selectionLayer,\n              type,\n              [geomFilter, ['in', this.featureIdName, '']],\n              this.options.selectedLayout\n            );\n            this.layer.push(selectionLayer);\n          }\n        }\n      }\n    }\n\n    this._addEventsListeners();\n\n    return this.layer;\n  }\n\n  propertiesFilter(filters: PropertiesFilter, options?: FilterOptions) {\n    this._filterProperties = filters;\n    this._updatePropertiesFilter();\n  }\n\n  removeFilter() {\n    this._filterProperties = undefined;\n    this._updateFilter();\n  }\n\n  select(properties?: DataLayerFilter<F, TLayer> | PropertiesFilter) {\n    if (typeof properties !== 'function') {\n      this._selectProperties = properties;\n      this._updateFilter();\n    }\n    this.selected = true;\n  }\n\n  unselect() {\n    this._selectProperties = undefined;\n    this._updateFilter();\n    this.selected = false;\n  }\n\n  removeLayer() {\n    const map = this.map;\n    if (this.layer) {\n      this.layer.forEach(layerId => {\n        map.removeLayer(layerId);\n      });\n    }\n  }\n\n  protected _updateWithNativeFilter(filter: any[]) {\n    const nativeFilter = this._getNativeFilter();\n    if (nativeFilter.length) {\n      filter.push(nativeFilter);\n    }\n    return filter;\n  }\n\n  protected _getNativeFilter() {\n    return (this.options.nativeFilter\n      ? this.options.nativeFilter\n      : []) as PropertyFilter;\n  }\n\n  protected async _addLayer(\n    name: string,\n    type: VectorAdapterLayerType,\n    filter?: any[],\n    layout?: AnyLayout\n  ) {\n    const { minZoom, maxZoom } = this.options;\n    let mType: MapboxLayerType;\n    if (type === 'icon') {\n      mType = 'symbol';\n    } else {\n      mType = type;\n    }\n    layout = (layout || this.options.layout || {}) as AnyLayout;\n    const layerOpt: Layer = {\n      id: name,\n      type: mType,\n      source: this._sourceId,\n      layout: {\n        visibility: 'none',\n        ...layout\n      },\n      ...this._getAdditionalLayerOptions()\n    };\n    if (minZoom) {\n      layerOpt.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOpt.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(layerOpt);\n\n    const filters = ['all', ...(filter || [])].filter(x => x);\n    if (filters.length > 1) {\n      this.map.setFilter(layerOpt.id, filters);\n    }\n  }\n\n  protected _onAddLayer(sourceId: string, options?: AnySourceData) {\n    // ignore\n  }\n\n  protected async _updateLayerPaint(type: VectorAdapterLayerType) {\n    const layerName = this._getLayerNameFromType(type);\n\n    if (this.options.paint) {\n      const layers: [string, VectorAdapterLayerPaint | GetPaintCallback][] = [\n        [layerName, this.options.paint]\n      ];\n      if (this.options.selectedPaint) {\n        const selName = this._getSelectionLayerNameFromType(type);\n        layers.push([selName, this.options.selectedPaint]);\n      }\n\n      for (const [name, paint] of layers) {\n        let _paint: any;\n        if (this.options.nativePaint) {\n          _paint =\n            typeof this.options.nativePaint === 'boolean'\n              ? paint\n              : this.options.nativePaint;\n        } else {\n          _paint = await this._createPaintForType(paint, type, name);\n        }\n\n        if ('icon-image' in _paint) {\n          // If true, the icon will be visible even if it collides with other previously drawn symbols.\n          _paint['icon-allow-overlap'] = true;\n          for (const p in _paint) {\n            this.map.setLayoutProperty(name, p, _paint[p]);\n          }\n        } else {\n          for (const p in _paint) {\n            this.map.setPaintProperty(name, p, _paint[p]);\n          }\n        }\n      }\n    }\n  }\n\n  protected _getLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._layerId;\n  }\n\n  protected _getSelectionLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._selectionName;\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name?: string\n  ): Promise<any> {\n    if (typeof paint !== 'function') {\n      const mapboxPaint: any = {};\n      const _paint = { ...PAINT, ...(paint || {}) };\n      if (paint.type === 'icon' && paint.html) {\n        await this._registerImage(paint);\n        return {\n          'icon-image': paint.html\n        };\n      } else {\n        for (const p in _paint) {\n          const allowed = allowedByType[type];\n          if (allowed) {\n            const allowedType = allowed.find(x => {\n              if (typeof x === 'string') {\n                return x === p;\n              } else if (Array.isArray(x)) {\n                return x[0] === p;\n              }\n              return false;\n            });\n            if (allowedType) {\n              const paramName = Array.isArray(allowedType)\n                ? allowedType[1]\n                : allowedType;\n              // @ts-ignore\n              mapboxPaint[type + '-' + paramName] = _paint[p];\n            }\n          }\n        }\n        mapboxPaint[type + '-opacity-transition'] = { duration: 0 };\n        return mapboxPaint;\n      }\n    }\n  }\n\n  protected _getFeatureFilterId(feature: Feature): string | number | undefined {\n    // @ts-ignore\n    const id = feature._featureFilterId;\n    if (id !== undefined) {\n      return id;\n    } else if (\n      feature.properties &&\n      feature.properties[this.featureIdName] !== undefined\n    ) {\n      return feature.properties[this.featureIdName];\n    }\n    return feature.id;\n  }\n\n  protected async _registerImage(paint: IconOptions) {\n    if (paint.html) {\n      const imageExist = this.map.hasImage(paint.html);\n      if (!imageExist) {\n        let width = 12;\n        let height = 12;\n        if (paint.iconSize) {\n          width = paint.iconSize[0];\n          height = paint.iconSize[1];\n        }\n        const image = await getImage(paint.html, {\n          width,\n          height\n        });\n\n        this.map.addImage(paint.html, image);\n      }\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _unselectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _getAdditionalLayerOptions() {\n    return {};\n  }\n\n  protected _updateFilter() {\n    this._updatePropertiesFilter();\n  }\n\n  protected _updatePropertiesFilter() {\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          const selectProperties = this._selectProperties;\n          const filterProperties = this._filterProperties;\n          const propertyFilters =\n            filterProperties && this._convertToMapboxFilter(filterProperties);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              let filters: any[] = [];\n              if (selectProperties || this._selectedFeatureIds) {\n                if (selectProperties) {\n                  filters = this._convertToMapboxFilter(selectProperties) || [];\n                } else if (this._selectedFeatureIds) {\n                  filters = [\n                    ['in', this.featureIdName, ...this._selectedFeatureIds]\n                  ];\n                }\n                if (propertyFilters) {\n                  propertyFilters.forEach(x => filters.push(x));\n                }\n                this.map.setFilter(selLayerName, [\n                  'all',\n                  geomFilter,\n                  ...filters\n                ]);\n              } else {\n                filters = ['in', '$id', ''];\n                this.map.setFilter(selLayerName, filters);\n              }\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filters_: any[] = ['all', geomFilter];\n            this._updateWithNativeFilter(filters_);\n            if (selectProperties) {\n              const selectFilters = this._convertToMapboxFilter(\n                selectProperties,\n                true\n              );\n              selectFilters.forEach(x => filters_.push(x));\n            } else if (this._selectedFeatureIds) {\n              filters_.push([\n                '!in',\n                this.featureIdName,\n                ...this._selectedFeatureIds\n              ]);\n            }\n            if (propertyFilters) {\n              propertyFilters.forEach(x => filters_.push(x));\n            }\n            this.map.setFilter(layerName, filters_);\n          }\n        }\n      });\n    }\n  }\n\n  protected _convertToMapboxFilter(filters: PropertiesFilter, reverse = false) {\n    const _operationsAliases = reverse ? reversOperations : operationsAliases;\n    const filter = filters.map(x => {\n      if (typeof x === 'string') {\n        return x;\n      } else if (checkIfPropertyFilter(x)) {\n        const [field, operation, value] = x;\n        const operationAlias = _operationsAliases[operation];\n        if (operation === 'in' || operation === 'notin') {\n          return [operationAlias, field, ...value];\n        }\n        return [operationAlias, field, value];\n      }\n    });\n    return filter;\n  }\n\n  protected isFeatureSelected(feature: Feature) {\n    if (this._selectedFeatureIds) {\n      const filterId = this._getFeatureFilterId(feature);\n      if (filterId) {\n        return this._selectedFeatureIds.indexOf(filterId) !== -1;\n      }\n    }\n    return false;\n  }\n\n  private _onLayerClick(e: MapLayerMouseEvent) {\n    e.preventDefault();\n    // const features = this.map.queryRenderedFeatures(e.point, {\n    //   layers: this.layer\n    // });\n    if (this.layer) {\n      const features = this.layer.reduce((a, b) => {\n        const features_ = this.map.queryRenderedFeatures(e.point, {\n          layers: [b]\n        });\n        const c = a.concat(features_);\n        return c;\n      }, [] as MapboxGeoJSONFeature[]);\n      const feature = features[0] as Feature;\n      if (feature) {\n        let isSelected = this.isFeatureSelected(feature);\n        if (isSelected) {\n          if (this.options && this.options.unselectOnSecondClick) {\n            this._unselectFeature(feature);\n          }\n        } else {\n          this._selectFeature(feature);\n        }\n        isSelected = this.isFeatureSelected(feature);\n        if (this.options.onLayerClick) {\n          this.options.onLayerClick({\n            layer: this,\n            feature,\n            selected: isSelected\n          });\n        }\n      }\n    }\n  }\n\n  private _detectPaintType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback\n  ): string | undefined {\n    if ('type' in paint) {\n      return paint.type;\n    } else if (typeof paint === 'function') {\n      try {\n        const falsePaint = paint({\n          type: 'Feature',\n          properties: {},\n          geometry: {} as Geometry\n        });\n        return this._detectPaintType(falsePaint);\n      } catch (er) {\n        //\n      }\n    }\n  }\n\n  private _addEventsListeners() {\n    if (this.layer && this.options && this.options.selectable) {\n      this.layer.forEach(x => {\n        if (this.$onLayerClick) {\n          const onLayerClick = this.$onLayerClick;\n          this.map.on('click', x, (e: MapLayerMouseEvent) => {\n            onLayerClick(e);\n          });\n        }\n\n        this.map.on('mousemove', x, () => {\n          this.map.getCanvas().style.cursor = 'pointer';\n        });\n        this.map.on('mouseleave', x, () => {\n          this.map.getCanvas().style.cursor = '';\n        });\n      });\n    }\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { MvtAdapterOptions } from '@nextgis/webmap';\nimport { VectorAdapter } from './VectorAdapter';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nexport class MvtAdapter extends VectorAdapter<MvtAdapterOptions> {\n  static sources: string[] = [];\n\n  source?: string;\n\n  async addLayer(options: MvtAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    this._updateLayerPaint(this.options.type || 'fill');\n\n    return layer;\n  }\n\n  protected _getAdditionalLayerOptions() {\n    const exist = MvtAdapter.sources.includes(this.options.url);\n    if (!exist) {\n      this.map.addSource(this.options.url, {\n        type: 'vector',\n        tiles: [this.options.url]\n      });\n      this.source = this.options.url;\n      MvtAdapter.sources.push(this.options.url);\n    }\n    const mvtLayerOptions: Partial<mapboxgl.Layer> = {\n      source: this.options.url,\n      'source-layer': this.options.sourceLayer\n    };\n    return mvtLayerOptions;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { BaseAdapter } from './BaseAdapter';\nimport { RasterSource, ResourceType, Layer } from 'mapbox-gl';\n\nexport class TileAdapter extends BaseAdapter<TileAdapterOptions>\n  implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    options = { ...this.options, ...(options || {}) };\n    const { minZoom, maxZoom } = options;\n    let tiles: string[];\n    if (options && options.subdomains) {\n      tiles = options.subdomains.split('').map(x => {\n        const subUrl = options.url.replace('{s}', x);\n        return subUrl;\n      });\n    } else {\n      tiles = [options.url];\n    }\n    if (options.headers) {\n      // @ts-ignore\n      const transformRequests = this.map.transformRequests;\n      transformRequests.push((url: string, resourceType: ResourceType) => {\n        let staticUrl = url;\n        staticUrl = staticUrl.replace(/(z=\\d+)/, 'z={z}');\n        staticUrl = staticUrl.replace(/(x=\\d+)/, 'x={x}');\n        staticUrl = staticUrl.replace(/(y=\\d+)/, 'y={y}');\n        if (staticUrl === options.url) {\n          return {\n            url,\n            headers: options.headers\n          };\n        }\n      });\n    }\n\n    const sourceOptions: RasterSource = {\n      type: 'raster',\n      // point to our third-party tiles. Note that some examples\n      // show a \"url\" property. This only applies to tilesets with\n      // corresponding TileJSON (such as mapbox tiles).\n      tiles,\n      tileSize: 256 // opt && opt.tileSize ||\n    };\n    if (options.attribution) {\n      sourceOptions.attribution = options.attribution;\n    }\n    const layerOptions: Layer = {\n      id: this._layerId,\n      type: 'raster',\n      layout: {\n        visibility: 'none'\n      },\n      source: sourceOptions\n      // TODO: clean remove before options from all existing apps\n    };\n\n    if (minZoom) {\n      layerOptions.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOptions.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(\n      layerOptions,\n      // @ts-ignore\n      options.before\n    );\n    const layer = (this.layer = [this._layerId]);\n    return layer;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileAdapter } from './TileAdapter';\n\nconst OPTIONS = {\n  url: 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n  attribution:\n    '&copy; <a href=\"http://osm.org/copyright\" target=\"_blank\">OpenStreetMap</a> contributors',\n  subdomains: 'abc'\n};\n\nexport class OsmAdapter extends TileAdapter implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    return super.addLayer(Object.assign({}, OPTIONS, options));\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\nimport { ZoomControlOptions } from '@nextgis/webmap';\n\nexport class ZoomControl extends NavigationControl {\n  options: ZoomControlOptions & any;\n\n  constructor(options: ZoomControlOptions & any = {}) {\n    options = { ...options, showCompass: false };\n    super(options);\n  }\n\n  _createButton(className: string, ariaLabel: string, fn: () => any) {\n    // @ts-ignore\n    const element = super._createButton(className, ariaLabel, fn);\n    const aliases: any = {\n      'Zoom in': 'zoomInTitle',\n      'Zoom out': 'zoomOutTitle'\n    };\n    const alias = aliases[ariaLabel];\n    const label = alias && this.options[alias];\n    if (label) {\n      element.title = label;\n      element.setAttribute('aria-label', label);\n    }\n\n    return element;\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\n\nexport class CompassControl extends NavigationControl {\n  constructor(options = {}) {\n    options = Object.assign({}, options, { showZoom: false });\n    super(options);\n  }\n}\n","// import { MapControl } from '@nextgis/webmap';\nimport { AttributionControl as AC } from 'mapbox-gl';\n\nexport class AttributionControl extends AC {}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map, GeoJSONSource, GeoJSONSourceRaw } from 'mapbox-gl';\nimport {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  DataLayerFilter,\n  LayerDefinition,\n  PropertiesFilter\n} from '@nextgis/webmap';\nimport { featureFilter } from '@nextgis/utils';\nimport {\n  GeoJsonObject,\n  FeatureCollection,\n  GeometryCollection,\n  GeometryObject\n} from 'geojson';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { VectorAdapter, Feature } from './VectorAdapter';\nimport {\n  detectType,\n  typeAlias,\n  typeAliasForFilter,\n  geometryFilter\n} from '../util/geom_type';\n\nlet ID = 0;\n\nexport class GeoJsonAdapter extends VectorAdapter<GeoJsonAdapterOptions> {\n  selected = false;\n  source?: string;\n  private _features: Feature[] = [];\n  private _filteredFeatureIds?: (string | number)[] | undefined;\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _sources: Record<string, GeoJSONSource> = {};\n\n  constructor(public map: Map, public options: GeoJsonAdapterOptions) {\n    super(map, options);\n    this.source = this._sourceId;\n  }\n\n  async addLayer(options: GeoJsonAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    if (this.options.data) {\n      this.addData(this.options.data);\n    }\n    return layer;\n  }\n\n  removeLayer() {\n    super.removeLayer();\n    const source = this.map.getSource(this._sourceId);\n    if (source) {\n      this.map.removeSource(this._sourceId);\n    }\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean) {\n    let features: Feature[] = [];\n    const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n    if (cb) {\n      features = this._features = this._features.filter(x => !cb(x));\n    }\n    source.setData({ type: 'FeatureCollection', features });\n  }\n\n  async addData(data: GeoJsonObject) {\n    let type: VectorAdapterLayerType | undefined;\n    if (this.options.type) {\n      type = this.options.type;\n    }\n    if (!type && data) {\n      const detectedType = detectType(data);\n      type = typeAlias[detectedType];\n    }\n    if (data && type) {\n      const features = this.filterGeometries(data, type);\n      features.forEach(x => {\n        // to avoid id = 0 is false\n        const fid = '_' + ID++;\n        x._featureFilterId = fid;\n        if (x.properties) {\n          x.properties[this.featureIdName] = fid;\n        }\n      });\n      if (this._filterFun) {\n        this._filter(this._filterFun);\n      }\n      await this._updateLayerPaint(type);\n      const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n      source.setData({ type: 'FeatureCollection', features: this._features });\n    }\n  }\n\n  getLayers() {\n    const filtered = this._filteredFeatureIds;\n    const filterProperties = this._filterProperties;\n    if (filterProperties) {\n      this._updateWithNativeFilter(filterProperties);\n    }\n    return this._getFeatures().map(feature => {\n      let visible = false;\n      if (filterProperties && feature.properties) {\n        visible = featureFilter(feature, filterProperties);\n      } else if (filtered) {\n        const id = this._getFeatureFilterId(feature);\n        if (id !== undefined) {\n          visible = filtered.indexOf(id) !== -1;\n        }\n      }\n      return {\n        feature,\n        visible\n      };\n    });\n  }\n\n  filter(fun: DataLayerFilter<Feature, TLayer>) {\n    this._filterFun = fun;\n    this._filter(fun);\n  }\n\n  removeFilter() {\n    this._filterFun = undefined;\n    this._filteredFeatureIds = undefined;\n    this._updateFilter();\n  }\n\n  getSelected() {\n    const features: LayerDefinition<Feature, TLayer>[] = [];\n    this._getFeatures().forEach(x => {\n      const id = this._getFeatureFilterId(x);\n      if (\n        id &&\n        this._selectedFeatureIds &&\n        this._selectedFeatureIds.indexOf(id) !== -1\n      ) {\n        features.push({ feature: x });\n      }\n    });\n    return features;\n  }\n\n  select(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter(x => find({ feature: x }));\n        this._selectFeature(features);\n      } else {\n        this.selected = true;\n        this._selectProperties = find;\n        super._updateFilter();\n      }\n    } else if (!this.selected) {\n      this._selectFeature(this._getFeatures());\n    }\n  }\n\n  unselect(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    this._selectProperties = undefined;\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter(x => find({ feature: x }));\n        this._unselectFeature(features);\n        this.selected = Array.isArray(this._selectedFeatureIds) ? true : false;\n      }\n    } else if (this.selected) {\n      this.selected = false;\n      this._unselectFeature();\n    }\n  }\n\n  protected _onAddLayer(sourceId: string) {\n    let source = this.map.getSource(sourceId) as GeoJSONSource;\n    if (!source) {\n      const sourceOpt: GeoJSONSourceRaw = {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features: []\n        }\n      };\n      const _opts: (keyof GeoJsonAdapterOptions)[] = [\n        'cluster',\n        'clusterMaxZoom',\n        'clusterRadius'\n      ];\n      _opts.forEach(x => {\n        const opt = this.options[x] as GeoJsonAdapterOptions;\n        if (opt !== undefined) {\n          //@ts-ignore\n          sourceOpt[x] = opt;\n        }\n      });\n      this.map.addSource(sourceId, sourceOpt);\n      source = this.map.getSource(sourceId) as GeoJSONSource;\n    }\n    this._sources[sourceId] = source;\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ): Promise<any> {\n    if (typeof paint === 'function') {\n      return await this._getPaintFromCallback(paint, type, name);\n    } else {\n      return super._createPaintForType(paint, type, name);\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    let selectedFeatureIds = this._selectedFeatureIds || [];\n    if (this.options && !this.options.multiselect) {\n      selectedFeatureIds = [];\n    }\n    let features: Feature[] = [];\n    if (Array.isArray(feature)) {\n      features = feature;\n    } else {\n      features = [feature];\n    }\n    features.forEach(f => {\n      const id = this._getFeatureFilterId(f);\n      if (id !== undefined) {\n        selectedFeatureIds.push(id);\n      }\n    });\n    this._selectedFeatureIds = selectedFeatureIds;\n    this._updateFilter();\n  }\n\n  protected _unselectFeature(feature?: Feature | Feature[]) {\n    if (feature) {\n      let features: Feature[] = [];\n      if (Array.isArray(feature)) {\n        features = feature;\n      } else {\n        features = [feature];\n      }\n      if (features.length) {\n        features.forEach(f => {\n          const id = this._getFeatureFilterId(f);\n          const selected = this._selectedFeatureIds;\n          if (selected && id !== undefined) {\n            const index = selected.indexOf(id);\n            if (index !== -1) {\n              selected.splice(index, 1);\n            }\n          }\n        });\n      }\n    } else {\n      this._selectedFeatureIds = false;\n    }\n    this._updateFilter();\n  }\n\n  protected _updateFilter() {\n    // it is not yet possible to use callbacks and properties filters together\n    if (this._filterProperties || this._selectProperties) {\n      return super._updateFilter();\n    }\n    const selected = this._selectedFeatureIds;\n    let selectionArray: (string | number)[] = [];\n    const filteredArray: (string | number)[] = [];\n    const filtered = this._filteredFeatureIds;\n    if (filtered) {\n      this._getFeatures().forEach(x => {\n        const id = this._getFeatureFilterId(x);\n        if (id !== undefined && filtered.indexOf(id) !== -1) {\n          if (selected && selected.indexOf(id) !== -1) {\n            selectionArray.push(id);\n          } else {\n            filteredArray.push(id);\n          }\n        }\n      });\n    } else if (selected) {\n      selectionArray = selected;\n    }\n    this.selected = !!selected;\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              this.map.setFilter(selLayerName, [\n                'all',\n                geomFilter,\n                ['in', this.featureIdName, ...selectionArray]\n              ]);\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filter_: any[] = ['all', geomFilter];\n            if (filtered) {\n              filter_.push(['in', this.featureIdName, ...filteredArray]);\n            } else {\n              filter_.push(['!in', this.featureIdName, ...selectionArray]);\n              this._updateWithNativeFilter(filter_);\n            }\n            this.map.setFilter(layerName, filter_);\n          }\n        }\n      });\n    }\n  }\n\n  private _getFeatures(): Feature[] {\n    if (this.source) {\n      // const features = this.map.querySourceFeatures(this.source);\n      // return features;\n\n      const source = this.map.getSource(this.source);\n      if (source) {\n        // @ts-ignore\n        return source._data?.features || [];\n      }\n    }\n    return this._features;\n  }\n\n  private _filter(fun: DataLayerFilter<Feature, TLayer>) {\n    const filtered: (string | number)[] = [];\n    this._getFeatures().forEach(feature => {\n      const ok = fun({ feature });\n      const id = this._getFeatureFilterId(feature);\n      if (ok && id) {\n        filtered.push(id);\n      }\n    });\n    this._filteredFeatureIds = filtered;\n    this._updateFilter();\n  }\n\n  private filterGeometries(\n    data: GeoJsonObject,\n    type: VectorAdapterLayerType\n  ): Feature[] {\n    let newFeatures: Feature[] = [];\n    if (data.type === 'FeatureCollection') {\n      const features = (data as FeatureCollection).features.filter(f =>\n        geometryFilter(f.geometry.type, type)\n      ) as Feature[];\n      (data as FeatureCollection).features = features;\n      newFeatures = features;\n    } else if (data.type === 'Feature') {\n      const allow = geometryFilter((data as Feature).geometry.type, type);\n      if (!allow) {\n        return [];\n      }\n      newFeatures.push(data as Feature);\n    } else if (data.type === 'GeometryCollection') {\n      const geomCollection = data as GeometryCollection;\n      geomCollection.geometries = geomCollection.geometries.filter(g =>\n        geometryFilter(g.type, type)\n      );\n      newFeatures = geomCollection.geometries.map(x => {\n        const f: Feature = {\n          type: 'Feature',\n          geometry: x as GeometryObject,\n          properties: {}\n        };\n        return f;\n      });\n    } else if (typeAlias[data.type]) {\n      const obj: Feature = {\n        type: 'Feature',\n        geometry: data as GeometryObject,\n        properties: {}\n      };\n      newFeatures = [obj];\n    }\n    this._features = this._features.concat(newFeatures);\n    return newFeatures;\n  }\n\n  private async _getPaintFromCallback(\n    paint: GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ) {\n    const style: any = {};\n    for (const feature of this._features) {\n      const _paint = paint(feature);\n      if (_paint.type === 'icon') {\n        await this._registerImage(_paint);\n        if (feature.properties) {\n          feature.properties['_icon-image-' + name] = _paint.html;\n        }\n        style['icon-image'] = `{_icon-image-${name}}`;\n      } else {\n        for (const p in _paint) {\n          // @ts-ignore\n          const toSave = _paint[p];\n          if (feature.properties) {\n            feature.properties[`_paint_${p}_${name}`] = toSave;\n          }\n          style[p] = ['get', `_paint_${p}_${name}`];\n        }\n      }\n    }\n    if ('icon-image' in style) {\n      return style;\n    }\n    const styleFromCb = this._createPaintForType(style, type, name);\n    return styleFromCb;\n  }\n}\n","import { MapControl, CreateControlOptions } from '@nextgis/webmap';\nimport { IControl } from 'mapbox-gl';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {}\n): IControl {\n  class Control implements IControl {\n    private _container?: HTMLElement;\n\n    getDefaultPosition() {\n      return 'top-left';\n    }\n\n    onAdd() {\n      const element = document.createElement('div');\n      const content: HTMLElement = control.onAdd();\n      element.classList.add('mapboxgl-ctrl');\n      if (options.bar) {\n        // add custom css for boarder style\n        element.classList.add('mapboxgl-bar');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      element.appendChild(content);\n      this._container = element;\n      return this._container;\n    }\n\n    onRemove() {\n      if (this._container) {\n        const parent = this._container.parentNode;\n        if (parent) {\n          parent.removeChild(this._container);\n        }\n      }\n      return control.onRemove();\n    }\n\n    remove() {\n      this.onRemove();\n    }\n  }\n\n  return new Control();\n  // return control;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  MapAdapter,\n  FitOptions,\n  MapControl,\n  ControlPositions,\n  ButtonControlOptions,\n  LngLatArray,\n  MapOptions,\n  LayerAdapter,\n  LngLatBoundsArray,\n  WebMapEvents,\n  CreateControlOptions\n} from '@nextgis/webmap';\nimport { sleep, debounce } from '@nextgis/utils';\nimport { MvtAdapter } from './layer-adapters/MvtAdapter';\nimport mapboxgl, {\n  Map,\n  IControl,\n  MapEventType,\n  EventData,\n  MapboxOptions,\n  RequestParameters,\n  ResourceType,\n  FitBoundsOptions\n} from 'mapbox-gl';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter';\nimport { EventEmitter } from 'events';\nimport { ZoomControl } from './controls/ZoomControl';\nimport { CompassControl } from './controls/CompassControl';\nimport { AttributionControl } from './controls/AttributionControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { createControl } from './controls/createControl';\nimport { createButtonControl } from './controls/createButtonControl';\n\nexport type TLayer = string[];\ntype TLayerAdapter = LayerAdapter<Map, TLayer>;\n\nconst fitBoundsOptions: FitOptions = {\n  // padding: 100\n};\n\nexport interface MapboxglMapAdapterOptions extends MapOptions {\n  style?: Partial<mapboxgl.Style> | string;\n  accessToken?: string;\n}\n\nexport class MapboxglMapAdapter implements MapAdapter<Map, TLayer, IControl> {\n  static layerAdapters = {\n    TILE: TileAdapter,\n    // IMAGE: TileAdapter,\n    MVT: MvtAdapter,\n    OSM: OsmAdapter,\n    GEOJSON: GeoJsonAdapter\n  };\n\n  static controlAdapters: { [name: string]: any } = {\n    ZOOM: ZoomControl,\n    COMPASS: CompassControl,\n    ATTRIBUTION: AttributionControl\n  };\n\n  options: MapboxglMapAdapterOptions = {};\n  map!: Map;\n\n  emitter = new EventEmitter();\n\n  layerAdapters = MapboxglMapAdapter.layerAdapters;\n  controlAdapters = MapboxglMapAdapter.controlAdapters;\n  isLoaded = false;\n\n  private _universalEvents: (keyof WebMapEvents)[] = [\n    'zoomstart',\n    'zoom',\n    'zoomend',\n    'movestart',\n    'move',\n    'moveend'\n  ];\n\n  private _sourceDataLoading: { [name: string]: any[] } = {};\n  private _sortTimerId?: number;\n  private __setLayerOrder: (layers: { [x: string]: TLayerAdapter }) => void;\n\n  constructor() {\n    this.__setLayerOrder = debounce(layers => this._setLayerOrder(layers));\n  }\n\n  // create(options: MapOptions = {target: 'map'}) {\n  create(options: MapboxglMapAdapterOptions) {\n    return new Promise((resolve, reject) => {\n      if (!this.map) {\n        this.options = options;\n        if (options.accessToken) {\n          mapboxgl.accessToken = options.accessToken;\n        }\n        if (options.target) {\n          const mapOpt: MapboxOptions = {\n            container: options.target,\n            attributionControl: false,\n            // @ts-ignore\n            bounds: options.bounds,\n            fitBoundsOptions: { ...options.fitOptions, ...fitBoundsOptions },\n            transformRequest: (url: string, resourceType: ResourceType) => {\n              const transformed = this._transformRequest(url, resourceType);\n              if (transformed) {\n                return transformed;\n              } else {\n                return {\n                  url\n                };\n              }\n            }\n          };\n          if (typeof options.style === 'string') {\n            mapOpt.style = options.style;\n          } else {\n            mapOpt.style = {\n              ...{\n                version: 8,\n                name: 'Empty style',\n                sources: {},\n                layers: []\n              },\n              ...options.style\n            };\n          }\n          if (options.center !== undefined) {\n            mapOpt.center = options.center;\n          }\n          if (options.zoom !== undefined) {\n            mapOpt.zoom = options.zoom - 1;\n          }\n          if (options.maxZoom) {\n            mapOpt.maxZoom = options.maxZoom - 1;\n          }\n          if (options.minZoom) {\n            mapOpt.minZoom = options.minZoom - 1;\n          }\n          this.map = new Map(mapOpt);\n          this.map.once('load', () => {\n            // @ts-ignore\n            this.map.transformRequests = [];\n            this.isLoaded = true;\n            this.emitter.emit('create', this);\n            resolve(this);\n          });\n          this._addEventsListeners();\n        }\n      }\n    });\n  }\n\n  destroy() {\n    if (this.map) {\n      this.map.remove();\n    }\n  }\n\n  getContainer() {\n    return this.map && this.map.getContainer();\n  }\n\n  setView(center: LngLatArray, zoom?: number) {\n    if (this.map) {\n      const options: mapboxgl.CameraOptions = { center };\n      if (zoom) {\n        options.zoom = zoom - 1;\n      }\n      this.map.jumpTo(options);\n    }\n  }\n\n  setCenter(latLng: LngLatArray): void {\n    if (this.map) {\n      this.map.setCenter(latLng);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    if (this.map) {\n      const center = this.map.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom - 1);\n    }\n  }\n\n  getZoom(): number | undefined {\n    if (this.map) {\n      const zoom = this.map.getZoom();\n      if (zoom < 1) {\n        return undefined;\n      }\n      return zoom ? zoom + 1 : undefined;\n    }\n  }\n\n  // [extent_left, extent_bottom, extent_right, extent_top];\n  async fitBounds(\n    e: LngLatBoundsArray,\n    options: FitOptions = {}\n  ): Promise<void> {\n    if (this.map) {\n      const fitBoundOptions: FitBoundsOptions = {\n        linear: true,\n        duration: 0,\n        ...options,\n        ...fitBoundsOptions\n      };\n      this.map.fitBounds(\n        [\n          [e[0], e[1]],\n          [e[2], e[3]]\n        ],\n        fitBoundOptions\n      );\n      sleep(fitBoundOptions.duration);\n    }\n  }\n\n  setRotation(angle: number): void {\n    // ignore\n  }\n\n  showLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach(layerId => {\n        this._toggleLayer(layerId, true);\n      });\n  }\n\n  hideLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach(layerId => {\n        this._toggleLayer(layerId, false);\n      });\n  }\n\n  removeLayer(layerIds: string[]): void {\n    const _map = this.map;\n    if (_map && layerIds && Array.isArray(layerIds)) {\n      layerIds.forEach(layerId => {\n        _map.removeLayer(layerId);\n        const source = _map.getSource(layerId);\n        if (source) {\n          _map.removeSource(layerId);\n        }\n      });\n    }\n  }\n\n  setLayerOrder(\n    layerIds: string[],\n    order: number,\n    layers: { [x: string]: TLayerAdapter }\n  ): void {\n    this.__setLayerOrder(layers);\n  }\n\n  setLayerOpacity(layerIds: string[], opacity: number): void {\n    const _map = this.map;\n    if (_map) {\n      layerIds.forEach(layerId => {\n        this._onMapLoad().then(() => {\n          const layer = _map.getLayer(layerId);\n          if (layer) {\n            if (layer.type === 'symbol') {\n              _map.setPaintProperty(layerId, 'text-opacity', opacity);\n              _map.setPaintProperty(layerId, 'icon-opacity', opacity);\n            } else {\n              _map.setPaintProperty(layerId, layer.type + '-opacity', opacity);\n            }\n          }\n        });\n      });\n    }\n  }\n\n  createControl(control: MapControl, options?: CreateControlOptions): IControl {\n    return createControl(control, options);\n  }\n\n  createButtonControl(options: ButtonControlOptions): IControl {\n    return createButtonControl(options);\n  }\n\n  addControl(\n    control: IControl,\n    position: ControlPositions\n  ): IControl | undefined {\n    if (this.map) {\n      this.map.addControl(control, position);\n      return control;\n    }\n  }\n\n  removeControl(control: IControl): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  onMapClick(evt: MapEventType['click'] & EventData): void {\n    const latLng = evt.lngLat;\n    const { x, y } = evt.point;\n\n    this.emitter.emit('click', { latLng, pixel: { top: y, left: x } });\n  }\n\n  private _onMapLoad(cb?: () => any): Promise<Map> {\n    return new Promise<Map>(resolve => {\n      const _resolve = () => {\n        if (cb) {\n          cb();\n        }\n        if (this.map) {\n          resolve(this.map);\n        }\n      };\n      if (this.isLoaded) {\n        // map.loaded()\n        _resolve();\n      } else if (this.map) {\n        this.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  private _setLayerOrder(layers: { [x: string]: TLayerAdapter }): void {\n    console.log(layers);\n    const _map = this.map;\n    if (_map) {\n      const baseLayers: TLayerAdapter[] = [];\n      let orderedLayers: TLayerAdapter[] = [];\n      for (const l in layers) {\n        const layer = layers[l];\n        if (layer.options.baseLayer) {\n          baseLayers.push(layer);\n        } else {\n          orderedLayers.push(layer);\n        }\n      }\n\n      orderedLayers = orderedLayers.sort((a, b) => {\n        return a.options.order !== undefined && b.options.order !== undefined\n          ? a.options.order - b.options.order\n          : 0;\n      });\n\n      for (let fry = 0; fry < orderedLayers.length; fry++) {\n        const nextLayer = orderedLayers[fry + 1];\n        const nextLayerId = nextLayer && nextLayer.layer && nextLayer.layer[0];\n        const mem = orderedLayers[fry];\n        const _layers = this._getLayerIds(mem);\n        _layers.forEach(x => {\n          _map.moveLayer(x, nextLayerId);\n        });\n      }\n      const firstRealLayer = orderedLayers.find(x => Array.isArray(x.layer));\n      if (firstRealLayer) {\n        const firstLayerId = this._getLayerIds(firstRealLayer)[0];\n        // normalize layer ordering\n        baseLayers.forEach(x => {\n          if (x.layer) {\n            x.layer.forEach(y => {\n              _map.moveLayer(y, firstLayerId);\n            });\n          }\n        });\n      }\n    }\n  }\n\n  private _getLayerIds(mem: TLayerAdapter): string[] {\n    let _layers: TLayer = [];\n    if (mem) {\n      if (Array.isArray(mem.layer)) {\n        _layers = mem.layer;\n      } else if (mem.getDependLayers) {\n        const dependLayers = mem.getDependLayers();\n        dependLayers.forEach(x => {\n          // @ts-ignore Update x interface\n          const layer: TLayer = (x.layer && x.layer.layer) || x;\n          if (Array.isArray(layer)) {\n            layer.forEach(y => {\n              _layers.push(y);\n            });\n          }\n        });\n      }\n    }\n    return _layers;\n  }\n\n  private _toggleLayer(layerId: string, status: boolean): void {\n    this._onMapLoad().then(_map => {\n      _map.setLayoutProperty(\n        layerId,\n        'visibility',\n        status ? 'visible' : 'none'\n      );\n    });\n  }\n\n  private _onMapSourceData(data: mapboxgl.MapSourceDataEvent & EventData) {\n    if (data.dataType === 'source') {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-loaded', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onMapError(\n    data: mapboxgl.ErrorEvent & mapboxgl.MapSourceDataEvent & EventData\n  ) {\n    if (this._sourceDataLoading[data.sourceId]) {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-error', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onDataLoad(\n    data: { sourceId: string; tile: any },\n    isLoaded = false,\n    emit: (sourceId: string) => void\n  ) {\n    // if all sources is loaded emmit event for all and clean mem\n    if (isLoaded) {\n      Object.keys(this._sourceDataLoading).forEach(x => {\n        emit(x);\n      });\n      this._sourceDataLoading = {};\n    } else {\n      // check if all tiles in layer is loaded\n      const tiles = this._sourceDataLoading[data.sourceId];\n      if (tiles && data.tile) {\n        const index = tiles.indexOf(data.tile);\n        if (index !== -1) {\n          this._sourceDataLoading[data.sourceId].splice(index, 1);\n        }\n        // if no more loaded tiles in layer emit event and clean mem only for this layer\n        if (!tiles.length) {\n          emit(data.sourceId);\n          delete this._sourceDataLoading[data.sourceId];\n        }\n      }\n    }\n  }\n\n  private _transformRequest(\n    url: string,\n    resourceType: ResourceType\n  ): RequestParameters | undefined {\n    // @ts-ignore\n    const transformRequests = this.map && this.map.transformRequests;\n    if (transformRequests) {\n      for (const r of transformRequests) {\n        const params = r(url, resourceType) as RequestParameters;\n        if (params) {\n          return params;\n        }\n      }\n      return undefined;\n    }\n  }\n\n  private _addEventsListeners(): void {\n    const _map = this.map;\n    if (_map) {\n      // write mem for start loaded layers\n      _map.on('sourcedataloading', data => {\n        this._sourceDataLoading[data.sourceId] =\n          this._sourceDataLoading[data.sourceId] || [];\n        if (data.tile) {\n          this._sourceDataLoading[data.sourceId].push(data.tile);\n        }\n      });\n      // emmit data-loaded for each layer or all sources is loaded\n      _map.on('sourcedata', this._onMapSourceData.bind(this));\n      _map.on('error', this._onMapError.bind(this));\n      _map.on('click', evt => {\n        this.onMapClick(evt);\n      });\n\n      this._universalEvents.forEach(e => {\n        _map.on(e, () => this.emitter.emit(e, this));\n      });\n    }\n  }\n}\n","import { ButtonControlOptions } from '@nextgis/webmap';\nimport { createControl } from './createControl';\n\nexport function createButtonControl(options: ButtonControlOptions) {\n  const link = document.createElement('button');\n  link.className = 'mapboxgl-ctrl-icon';\n\n  link.setAttribute('role', 'button');\n  if (options.title) {\n    link.title = options.title;\n    link.setAttribute('aria-label', options.title);\n  }\n\n  if (options.html) {\n    if (options.html instanceof HTMLElement) {\n      link.appendChild(options.html);\n    } else {\n      link.innerHTML = options.html;\n    }\n    const child = link.firstElementChild as HTMLElement;\n    if (child) {\n      child.style.width = '100%';\n      child.style.height = '100%';\n      child.style.lineHeight = (link.offsetHeight || 30) + 'px';\n    }\n  }\n  if (options.addClass) {\n    options.addClass.split(' ').forEach(x => link.classList.add(x));\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n  if (options.onClick !== undefined) {\n    link.addEventListener('click', onClick);\n  }\n\n  return createControl(\n    {\n      onAdd() {\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      }\n    },\n    { bar: true, addClass: 'mapboxgl-ctrl-group' }\n  );\n}\n","/**\n * @module mapboxgl-map-adapter\n */\n\nimport { MapboxglMapAdapter } from './MapboxglMapAdapter';\nexport * from './MapboxglMapAdapter';\nexport default MapboxglMapAdapter;\n","/**\n * @module item\n */\nexport type SelfFilter<X extends any> = (x: X) => boolean;\nexport type RelationFunction<X extends any> = (x: X) => X | X[] | undefined;\n\nexport function filterIn<F extends any = any>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F) => !!x,\n  relationFunc: RelationFunction<F>,\n  _filtered: F[] = []\n): F[] {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      _filtered.push(item);\n    }\n    const relChild = relationFunc(item);\n    if (relChild) {\n      if (Array.isArray(relChild)) {\n        children = relChild;\n      } else {\n        children.push(relChild);\n      }\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      filterIn(children[fry], filterFunc, relationFunc, _filtered);\n    }\n  }\n\n  return _filtered;\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\nimport { filterIn } from './TreeUtil';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  // region Parents\n  setParent(parent: Item) {\n    this._parent = parent;\n  }\n\n  addChild(child: Item) {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return filterIn(parent, filterFunc, (x: I) => x.tree.getParent() as I);\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n  // endregion\n\n  // region Child\n  find(filterFunc?: (item: Item) => boolean) {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    })[0];\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return this._children as T[];\n  }\n}\n","/**\n * @module item\n */\nimport { Item } from '../Item';\nimport { ItemBasePropertyOptions } from '../interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\n// import StrictEventEmitter from 'strict-event-emitter-types/types/src';\n\n// export interface BasePropertyEvents<V, O> {\n//   'change': {value: V, options: O};\n//   'change-tree': {value: V, options: O, item: Item};\n// }\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>\n> {\n  options: O;\n\n  // emitter: StrictEventEmitter<EventEmitter, BasePropertyEvents<V, O>> = new EventEmitter();\n  emitter = EventEmitter && new EventEmitter();\n  name: string;\n\n  item: Item;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: Item, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty() {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent() {\n    return this.item.tree.getParent();\n  }\n\n  isGroup() {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked() {\n    if (this._blocked === undefined) {\n      const parents = this.item.tree.getParents();\n      if (parents) {\n        const isBlocked = parents.find((x: Item) => {\n          const parentProp = x.properties && x.properties.property(this.name);\n          if (parentProp) {\n            return !parentProp.get();\n          }\n          return false;\n        });\n        this._blocked = !!isBlocked;\n      } else {\n        this._blocked = false;\n      }\n    }\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O) {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O) {\n    this._callOnSet(value, options);\n  }\n\n  getContainer() {\n    return this._container;\n  }\n\n  destroy() {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O) {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O) {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach(x => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', { value, options, item: this.item });\n        }\n      });\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\nimport { ItemOptions } from './interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n  emitter = EventEmitter && new EventEmitter();\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties() {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","/**\n * @module item\n */\nimport { BaseProperty } from './BaseProperty';\nimport { Item } from '../Item';\n\nimport { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle'\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O) {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false })\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue() {\n    return (\n      this.get() &&\n      this.getParents().every(x => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  _prepareValue(value?: any): V | undefined {\n    return value;\n  }\n\n  _turnOff(options?: O) {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChilds(options);\n    }\n  }\n\n  _turnOn(options?: O) {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChilds(options);\n    }\n  }\n\n  block(options?: O) {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  _block(options?: O) {\n    this._turnOff(options);\n  }\n\n  unBlock(options?: O) {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  _unBlock(options?: O) {\n    this._turnOn(options);\n  }\n\n  blockChilds(options?: O) {\n    this.item.tree.getDescendants().forEach(x => this._blockChild(x, options));\n  }\n\n  unblockChilds(options?: O) {\n    this.item.tree.getChildren().forEach(x => this._unBlockChild(x, options));\n  }\n\n  _blockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  _unBlockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  _propagation(value?: V, options?: O) {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false\n            }\n          });\n        }\n      }\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { BaseProperty } from './BaseProperty';\nimport { CheckProperty } from './CheckProperty';\nimport { Item } from '../Item';\n\nimport {\n  ItemBasePropertyOptions,\n  Type,\n  ItemPropertyConfig,\n  ItemPropertyTypes\n} from '../interfaces';\n\nexport class ItemProperties {\n  static handlers: { [name: string]: Type<BaseProperty> } = {\n    CheckProperty\n  };\n\n  options = {};\n\n  private _properties: { [propName: string]: BaseProperty } = {};\n  private _propertiesList: string[];\n\n  constructor(\n    public item: Item,\n    propertiesList?: ItemPropertyConfig<keyof ItemPropertyTypes>[]\n  ) {\n    this._propertiesList = []; // ordered list\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    this._setPropertyHandler(propOpt);\n  }\n\n  _setPropertyHandler(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    const handlers = ItemProperties.handlers;\n    let handler = propOpt.handler;\n    if (!handler && propOpt.type) {\n      switch (propOpt.type) {\n        case 'boolean':\n          handler = handlers.CheckProperty;\n          break;\n        case 'string':\n          handler = handlers.BaseProperty;\n          break;\n        default:\n          handler = handlers.BaseProperty;\n      }\n    }\n    if (handler && propOpt.name) {\n      const options = { ...(propOpt || {}) };\n      this._properties[propOpt.name] = new handler(\n        propOpt.name,\n        this.item,\n        options\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  update() {\n    this.list().forEach(x => {\n      x.update();\n    });\n  }\n\n  get(name: string) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.get();\n    }\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>\n  ) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.set(value, options);\n    }\n  }\n\n  property(name: string) {\n    return this._properties[name];\n  }\n\n  list() {\n    return this._propertiesList.map(x => this._properties[x]);\n  }\n\n  destroy() {\n    for (const p in this._properties) {\n      const prop = this.property(p);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\n\nexport * from './interfaces';\nexport * from './properties/BaseProperty';\nexport * from './properties/CheckProperty';\nexport * from './properties/ItemProperties';\n\nexport { Item };\nexport default Item;\n"],"sourceRoot":""}