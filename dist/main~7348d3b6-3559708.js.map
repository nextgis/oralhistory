{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/qms-kit/src/utils/updateQmsOptions.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/utils/loadJson.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/utils/createQmsAdapter.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/QmsKit.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/properties-filter/src/propertiesFilter.ts","webpack:///./nextgisweb_frontend/packages/paint/src/typeHelpers.ts","webpack:///./nextgisweb_frontend/packages/paint/src/fromPaintExpression.ts","webpack:///./nextgisweb_frontend/packages/paint/src/preparePaint.ts"],"names":["alias","tms","loadJson","url","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","JSON","parse","er","open","send","createQmsAdapter","webMap","map","options","this","baseLayer","addLayer","qms","qmsId","console","error","type","webMapAdapter","mapAdapter","layerAdapters","QmsAdapter","maxZoom","minZoom","protocol","location","replace","name","attribution","copyright_text","z_max","z_min","updateQmsOptions","getLayerAdapters","createAdapter","webmap","_createAdapter","utils","like","b","a","iLike","String","toUpperCase","re","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","ne","in","indexOf","notin","ilike","checkIfPropertyFilter","filter","pf","length","featureFilter","feature","filters","properties","$id","id","propertiesFilter","logic","filterFunction","p","operation","operationExec","value_","match","cleanField","filters_","x","Array","isArray","some","every","isPaint","paint","Object","prototype","toString","call","isPaintCallback","isIcon","get","args","field","lookup","property","featureExpression","defValue","cases","splice","fry","expression","expressionFun","createPropertyExpressionCb","excludeExpressionList","preparePaint","defaultPaint","getPaintFunctions","newPaint","isPropertiesPaint","mask","paintsFilters","forEach","push","find","getPaint","from","updatePaintOptionFromCallback","value","withExpression","expressions","p_","val","fromCb","createExpressionCallback","fill","undefined","stroke","strokeColor","strokeOpacity","color","fillColor","opacity","fillOpacity"],"mappings":"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","file":"main~7348d3b6-3559708.js","sourcesContent":["/**\n * @module qms-kit\n */\nimport { LayerAdaptersOptions, AdapterOptions } from '@nextgis/webmap';\n\nimport { QmsBasemap, QmsLayerType } from '../interfaces';\n\nexport const alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE',\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  const serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min,\n  };\n}\n","/**\n * @module qms-kit\n */\nimport { fixUrlStr } from '@nextgis/utils';\n\nexport function loadJson<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n","/**\n * @module qms-kit\n */\nimport { WebMap, BaseLayerAdapter } from '@nextgis/webmap';\nimport { Type, mixinProperties } from '@nextgis/utils';\nimport { QmsAdapterOptions, QmsBasemap, QmsAdapter as QA } from '../interfaces';\nimport { alias, updateQmsOptions } from './updateQmsOptions';\nimport { loadJson } from './loadJson';\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = 'https://qms.nextgis.com'\n): Type<BaseLayerAdapter> {\n  class QmsAdapter<M = any> implements BaseLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      this.options = options;\n      this.options.baseLayer = true;\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        try {\n          this.qms = await loadJson<QmsBasemap>(\n            url + '/api/v1/geoservices/' + options.qmsId\n          );\n        } catch (er) {\n          console.error(er);\n        }\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const webMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (webMapAdapter) {\n          mixinProperties(QmsAdapter, webMapAdapter, [\n            'showLayer',\n            'hideLayer',\n          ]);\n          if (type === 'TILE') {\n            options = {\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms),\n            };\n            this.options = options;\n            const adapter = new webMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","/**\n * @module qms-kit\n */\n\nimport WebMap, { StarterKit, Type, BaseLayerAdapter } from '@nextgis/webmap';\nimport { QmsOptions } from './interfaces';\nimport { createQmsAdapter } from './utils/createQmsAdapter';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter,\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com',\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap)),\n      },\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<BaseLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n","/**\n * @module qms-kit\n */\n\nimport { QmsKit } from './QmsKit';\n\nexport * from './interfaces';\n\nexport { QmsKit };\nexport default QmsKit;\n","/**\n * @module utils\n */\nimport { Feature, GeoJsonProperties } from 'geojson';\nimport { reEscape } from '@nextgis/utils';\n\n/**\n * gt - greater (>)\n * lt - lower (<)\n * ge - greater or equal (>=)\n * le - lower or equal (<=)\n * eq - equal (=)\n * ne - not equal (!=)\n * like - LIKE SQL statement (for strings compare)\n * ilike - ILIKE SQL statement (for strings compare)\n */\nexport type Operations =\n  | 'gt'\n  | 'lt'\n  | 'ge'\n  | 'le'\n  | 'eq'\n  | 'ne'\n  | 'in'\n  | 'notin'\n  | 'like'\n  | 'ilike';\n\n/**\n * field, operation, value\n * ['foo', 'eq', 'bar']\n * ['count', 'ge', 20]\n */\nexport type PropertyFilter<T extends any = any> = [string, Operations, T];\n\nexport type PropertiesFilter<T extends any = any> = (\n  | 'all'\n  | 'any'\n  | PropertyFilter<T>\n  | PropertiesFilter<T>\n)[];\n\nfunction like(b: string, a: string, iLike?: boolean) {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operations]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function featureFilter(feature: Feature, filters: PropertiesFilter) {\n  const properties: GeoJsonProperties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter(\n  properties: { [field: string]: any },\n  filters: PropertiesFilter\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (checkIfPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          let prop = '';\n          const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n            prop = properties[cleanField];\n            return field.replace(cleanField, value);\n          });\n          return operationExec(prop, value_);\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n","import {\n  Expression,\n  Paint,\n  PropertiesPaint,\n  VectorAdapterLayerPaint,\n  GeometryPaint,\n  GetPaintCallback,\n  IconOptions,\n  IconPaint,\n} from './interfaces';\n\nexport function isExpression(value: any): value is Expression {\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconOptions): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { Feature } from 'geojson';\nimport {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  Expression,\n  ExpressionName,\n} from './interfaces';\nimport { isExpression } from './typeHelpers';\n\ntype ExpressionFun = (feature: Feature, args: any[]) => SimpleType;\n\nfunction get(feature: Feature, args: any[]) {\n  const field = args[0];\n  return feature.properties && feature.properties[field];\n}\n\nfunction match(feature: Feature, args: any[]) {\n  const [lookup, ...cases] = args;\n  let property = lookup;\n  if (Array.isArray(lookup)) {\n    property = featureExpression(feature, lookup as Expression);\n  }\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry];\n    if (key === property) {\n      return cases[fry + 1];\n    }\n  }\n  return defValue;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFun } = {\n  get,\n  match,\n};\n\ntype SimpleType = string | number | boolean | undefined;\n\ntype PropertyExpressionCb = (feature: Feature) => SimpleType;\n\nfunction featureExpression(feature: Feature, expression: Expression) {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(feature, args);\n  }\n  return undefined;\n}\n\nfunction createPropertyExpressionCb(\n  expression: Expression\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    return featureExpression(feature, expression);\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: VectorAdapterLayerPaint\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","/**\n * @module webmap\n */\nimport { featureFilter } from '@nextgis/properties-filter';\nimport { Feature } from 'geojson';\nimport {\n  Paint,\n  VectorAdapterLayerPaint,\n  GeometryPaint,\n  GetPaintFunction,\n  GetCustomPaintOptions,\n  PropertiesPaint,\n  PropertyPaint,\n} from './interfaces';\nimport { isPaintCallback, isPropertiesPaint, isPaint } from './typeHelpers';\nimport { createExpressionCallback } from './fromPaintExpression';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions: { [name: string]: GetPaintFunction }\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  propertiesPaint.forEach((x) => {\n    if (x) {\n      if (Array.isArray(x)) {\n        paintsFilters.push(x);\n      } else {\n        mask = x as VectorAdapterLayerPaint;\n      }\n    }\n  });\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nexport function preparePaint(\n  paint: Paint,\n  defaultPaint: GeometryPaint,\n  getPaintFunctions: { [name: string]: GetPaintFunction }\n): Paint {\n  let newPaint: Paint | undefined;\n  if (isPaintCallback(paint)) {\n    return (feature: Feature) => {\n      return preparePaint(\n        paint(feature),\n        defaultPaint,\n        getPaintFunctions\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint(\n        createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint(getPaint, defaultPaint, getPaintFunctions);\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    const expressionCallback = createExpressionCallback(paint);\n    if (expressionCallback) {\n      return (feature: Feature) => {\n        return preparePaint(\n          expressionCallback(feature),\n          defaultPaint,\n          getPaintFunctions\n        ) as VectorAdapterLayerPaint;\n      };\n    }\n\n    newPaint = { ...paint };\n    newPaint.fill = newPaint.fill !== undefined ? newPaint.fill : true;\n    newPaint.stroke =\n      newPaint.stroke !== undefined\n        ? newPaint.stroke\n        : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  }\n  if (newPaint) {\n    if (isPaintCallback(newPaint)) {\n      return newPaint;\n    } else if (isPaint(newPaint)) {\n      newPaint = { ...defaultPaint, ...newPaint };\n    }\n  } else {\n    newPaint = { ...defaultPaint };\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n"],"sourceRoot":""}